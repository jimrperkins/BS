[
  {
    "objectID": "recreate_aa.html",
    "href": "recreate_aa.html",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "",
    "text": "In this tutorial, we will explore the arachidonic acid metabolism pathway by constructing and analyzing a protein-protein interaction (PPI) network using data from STRINGdb and the igraph package in R. This tutorial will guide you through the process of:\n\nDownloading interaction data from STRINGdb.\nVisualizing the network using igraph.\nCalculating basic network metrics to better understand its structure.\n\nWe will use two key genes involved in this pathway, PTGS1 and ALOX5, to extract a small interaction network.\nThis work is based on the paper of Perkins et al., 2015. The arachidonic acid pathway is a key pathway in inflammation, and includes the targets of AINES (aspirin, ibuprofen and company), COX1/2 (PTGS1/PTGS2). Here it is:\n\n\n\nArachidonic Acid Pathway\n\n\nPerkins JR, Sanak M, Canto G, Blanca M, Cornejo-García JA. Unravelling adverse reactions to NSAIDs using systems biology. Trends Pharmacol Sci. 2015 Mar;36(3):172-80"
  },
  {
    "objectID": "recreate_aa.html#step-1-set-up-your-workspace",
    "href": "recreate_aa.html#step-1-set-up-your-workspace",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 1: Set up your workspace",
    "text": "Step 1: Set up your workspace\n\nOpen your terminal.\nCreate a new directory for this project:\nmkdir string_tutorial\nNavigate to the new directory:\ncd string_tutorial"
  },
  {
    "objectID": "recreate_aa.html#step-2-use-curl-to-download-the-network-data",
    "href": "recreate_aa.html#step-2-use-curl-to-download-the-network-data",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 2: Use curl to download the network data",
    "text": "Step 2: Use curl to download the network data\nRun the following command in your terminal to fetch the data:\ncurl -o string_ints.txt \"https://string-db.org/api/tsv/interaction_partners?identifiers=PTGS1%0dALOX5\"\nThis command saves the interaction data to a file named string_ints.txt. The data format is tab-separated values (TSV)."
  },
  {
    "objectID": "recreate_aa.html#step-3-preview-the-file",
    "href": "recreate_aa.html#step-3-preview-the-file",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 3: Preview the file",
    "text": "Step 3: Preview the file\nUse the less command to inspect the file:\nless string_ints.txt\nThe file might be difficult to read due to its raw format. Let’s load it into R for better analysis."
  },
  {
    "objectID": "recreate_aa.html#step-4-import-the-data",
    "href": "recreate_aa.html#step-4-import-the-data",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 4: Import the data",
    "text": "Step 4: Import the data\nStart by reading the file into R:\n\nstring_data &lt;- read.csv(\"string_ints.txt\", sep = \"\\t\")\nhead(string_data)\n\n            stringId_A           stringId_B preferredName_A preferredName_B\n1 9606.ENSP00000354612 9606.ENSP00000244043           PTGS1           PTGIS\n2 9606.ENSP00000354612 9606.ENSP00000342385           PTGS1           PTGES\n3 9606.ENSP00000354612 9606.ENSP00000363512           PTGS1           ALOX5\n4 9606.ENSP00000354612 9606.ENSP00000345341           PTGS1          PTGES2\n5 9606.ENSP00000354612 9606.ENSP00000293761           PTGS1          ALOX15\n6 9606.ENSP00000354612 9606.ENSP00000251535           PTGS1          ALOX12\n  ncbiTaxonId score nscore fscore pscore ascore escore dscore tscore\n1        9606 0.973      0      0      0  0.059  0.322    0.9  0.633\n2        9606 0.973      0      0      0  0.000  0.000    0.9  0.741\n3        9606 0.970      0      0      0  0.130  0.000    0.9  0.692\n4        9606 0.962      0      0      0  0.000  0.000    0.9  0.635\n5        9606 0.960      0      0      0  0.068  0.046    0.9  0.607\n6        9606 0.960      0      0      0  0.201  0.000    0.9  0.544\n\n\nThis displays the first few rows of the dataset. Each row represents an interaction between two proteins. The columns provide information such as interaction scores."
  },
  {
    "objectID": "recreate_aa.html#step-5-understand-the-dataset-structure",
    "href": "recreate_aa.html#step-5-understand-the-dataset-structure",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 5: Understand the dataset structure",
    "text": "Step 5: Understand the dataset structure\nTo better understand the dataset:\n\nWhat does each row represent? Each row corresponds to a protein-protein interaction.\nWhat does each column represent? Columns include protein identifiers and various interaction scores (explained below).\n\nCheck the dimensions of the dataset:\n\ndim(string_data)\n\n[1] 310  13"
  },
  {
    "objectID": "recreate_aa.html#step-6-explanation-of-scores",
    "href": "recreate_aa.html#step-6-explanation-of-scores",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 6: Explanation of Scores",
    "text": "Step 6: Explanation of Scores\nSTRINGdb provides several interaction scores to evaluate the confidence and sources of protein-protein interactions. Below is a detailed explanation of each score:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nscore\nThe combined interaction score, representing the overall confidence level of the interaction, calculated from all other scores.\n\n\nnscore\nThe neighborhood score, indicating the likelihood of interaction based on the presence of shared neighbors in the network.\n\n\nfscore\nThe fusion score, derived from genomic context and indicating whether the two proteins are part of the same operon or are likely co-transcribed.\n\n\npscore\nThe phylogenetic profile score, based on co-occurrence of the proteins across multiple species, suggesting functional association.\n\n\nascore\nThe co-expression score, calculated from experimental or computational evidence that the two genes/proteins are expressed together under similar conditions.\n\n\nescore\nThe experimental score, derived from curated experimental interaction data, such as co-immunoprecipitation or yeast two-hybrid assays.\n\n\ndscore\nThe database score, based on known interactions reported in curated biological databases, like KEGG or Reactome.\n\n\ntscore\nThe text mining score, obtained by mining scientific literature for co-mentions of the two proteins in relevant contexts.\n\n\n\nThese scores provide a comprehensive assessment of the interaction’s reliability and the sources of evidence supporting it."
  },
  {
    "objectID": "recreate_aa.html#step-7-extract-gene-pairs",
    "href": "recreate_aa.html#step-7-extract-gene-pairs",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 7: Extract gene pairs",
    "text": "Step 7: Extract gene pairs\nFirst, select the columns containing the interacting proteins:\n\ngene_pairs &lt;- string_data[, 3:4]\n\nConvert these pairs into a matrix:\n\ngene_pairs_matrix &lt;- as.matrix(gene_pairs)\nhead(gene_pairs_matrix)\n\n     preferredName_A preferredName_B\n[1,] \"PTGS1\"         \"PTGIS\"        \n[2,] \"PTGS1\"         \"PTGES\"        \n[3,] \"PTGS1\"         \"ALOX5\"        \n[4,] \"PTGS1\"         \"PTGES2\"       \n[5,] \"PTGS1\"         \"ALOX15\"       \n[6,] \"PTGS1\"         \"ALOX12\""
  },
  {
    "objectID": "recreate_aa.html#step-8-create-the-igraph-object",
    "href": "recreate_aa.html#step-8-create-the-igraph-object",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 8: Create the igraph object",
    "text": "Step 8: Create the igraph object\nUse the matrix to create a graph:\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nnetwork &lt;- graph_from_edgelist(gene_pairs_matrix)"
  },
  {
    "objectID": "recreate_aa.html#step-9-basic-visualization",
    "href": "recreate_aa.html#step-9-basic-visualization",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 9: Basic visualization",
    "text": "Step 9: Basic visualization\nLet’s visualize the network:\n\nplot(network)"
  },
  {
    "objectID": "recreate_aa.html#step-10-customize-the-visualization",
    "href": "recreate_aa.html#step-10-customize-the-visualization",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 10: Customize the visualization",
    "text": "Step 10: Customize the visualization\nExperiment with layouts and styling:\n\nplot(network, edge.color = \"orange\", vertex.color = \"gray50\")\n\n\n\n\n\n\n\nlayout &lt;- layout_in_circle(network)\nplot(network, layout = layout)\n\n\n\n\n\n\n\nlayout &lt;- layout_with_fr(network)\nplot(network, layout = layout)\n\n\n\n\n\n\n\n\nToo many nodes? We can simplify the network by filtering interactions based on their scores."
  },
  {
    "objectID": "recreate_aa.html#step-11-filter-interactions",
    "href": "recreate_aa.html#step-11-filter-interactions",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 11: Filter interactions",
    "text": "Step 11: Filter interactions\nKeep only high-confidence interactions with a score &gt; 0.92:\n\nstring_subset &lt;- subset(string_data, score &gt; 0.92)\ngene_pairs_subset &lt;- string_subset[, 3:4]\ngene_pairs_subset_matrix &lt;- as.matrix(gene_pairs_subset)\nnetwork &lt;- graph_from_edgelist(gene_pairs_subset_matrix)\nplot(network)"
  },
  {
    "objectID": "recreate_aa.html#step-12-degree-distribution",
    "href": "recreate_aa.html#step-12-degree-distribution",
    "title": "Tutorial: Representing and Investigating the Arachidonic Acid Metabolism Pathway Using STRINGdb and igraph",
    "section": "Step 12: Degree distribution",
    "text": "Step 12: Degree distribution\nAs we are more than aware by now, degree of a node is the number of connections it has. Let’s calculate the degree for all nodes:\n\ndeg &lt;- degree(network, mode = \"all\")\nhist(deg, breaks = 1:vcount(network) - 1, main = \"Histogram of Node Degree\")\n\n\n\n\n\n\n\n\nWhile not particularly informative in this case, degree distribution is a fundamental metric in network analysis."
  },
  {
    "objectID": "minimal_analysis.html",
    "href": "minimal_analysis.html",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "",
    "text": "Este es un ejemplo mínimo del análisis de un término HPO utilizando técnicas de biología de sistemas para comprender mejor los mecanismos subyacentes, incluyendo los pasos más importantes en el flujo de trabajo del análisis. Comenzamos con un término HPO, “morfología anormal del corpúsculo renal”, y sugerimos procesos subyacentes importantes, como el sistema inmunológico y las vías del complemento; la mitocondria, la respiración aeróbica y la producción de ATP. Sin embargo, existen muchas formas en que se puede ampliar el análisis. Puedes cambiar el umbral de puntuación utilizado para obtener interacciones de STRINGdb, agregar genes adicionales basados en interacciones con genes asociados a fenotipos conocidos, investigar otros métodos de agrupación, explorar otras bases de datos y fuentes de anotación para el análisis de enriquecimiento, o considerar herramientas adicionales de visualización, otras metricas, etc."
  },
  {
    "objectID": "minimal_analysis.html#descarga-manual",
    "href": "minimal_analysis.html#descarga-manual",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "Descarga Manual",
    "text": "Descarga Manual\n\nNavega al sitio web de la Ontología de Fenotipos Humanos (HPO).\nBusca abnormal renal corpuscle morphology en la barra de búsqueda.\nHaz clic en el fenotipo para ver los detalles.\nLocaliza la lista de genes asociados y descárgala en formato de texto (Export Associations).\n\nANOTA el codigo HPO del fenotipo, nos va a hacer falta para el siguiente paso:"
  },
  {
    "objectID": "minimal_analysis.html#uso-de-la-api",
    "href": "minimal_analysis.html#uso-de-la-api",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "Uso de la API",
    "text": "Uso de la API\n\n¿Qué es una API?\nUna Interfaz de Programación de Aplicaciones (API) permite que diferentes aplicaciones de software se comuniquen entre sí. En nuestro caso, nos permite acceder programáticamente a datos de la HPO. Puedes usar una API para obtener automáticamente la lista de genes sin tener que descargarla manualmente. PUEDES USAR OTRAS LENGUAJES DE PROGAMACION SI PREFERIS\nPara usar la API, aquí hay un ejemplo de cómo obtener genes programáticamente. Primero, necesitamos instalar y cargar las bibliotecas necesarias:\n\n# Install necessary packages if not already installed\nif (!requireNamespace(\"httr\", quietly = TRUE)) {\n  install.packages(\"httr\")\n}\nif (!requireNamespace(\"jsonlite\", quietly = TRUE)) {\n  install.packages(\"jsonlite\")\n}\n\nlibrary(httr)\nlibrary(jsonlite)\n\n# API request to get genes associated with the HPO term for abnormal renal corpuscle morphology\nhpo_id &lt;- \"HP:0031263\"  # HPO ID for abnormal renal corpuscle morphology\n\nurl &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id)\n\nresponse &lt;- GET(url)\ndata &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\ngenes &lt;- fromJSON(data)$genes\n\n# Display the first few genes\nhead(genes)\n\n               id    name\n1    NCBIGene:396 ARHGDIA\n2   NCBIGene:1286  COL4A4\n3   NCBIGene:1285  COL4A3\n4  NCBIGene:57728   WDR19\n5   NCBIGene:3075     CFH\n6 NCBIGene:254428 SLC41A1\n\n# Display all the genes (uncomment)\n# print(genes)"
  },
  {
    "objectID": "analisis_topo.html",
    "href": "analisis_topo.html",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "",
    "text": "La biología de sistemas se basa en el uso de redes para entender las interacciones complejas en sistemas biológicos. En este tutorial, exploraremos los conceptos fundamentales de grafos y redes utilizando el paquete igraph en R.\nPrimero, aseguramos de tener instalado el paquete igraph:\n\n\nUn grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos.\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_4 = 1\\), \\(k_1 = k_2 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(E\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior, tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 1) = 2\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación previa, obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n¿Es conexo (g_high)? TRUE \n\n\nGrafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- make_graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n¿Es conexo (g_low)? TRUE \n\n\nGrafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo.html#qué-es-un-grafo",
    "href": "analisis_topo.html#qué-es-un-grafo",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "",
    "text": "Un grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos.\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_4 = 1\\), \\(k_1 = k_2 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(E\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior, tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 1) = 2\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación previa, obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n¿Es conexo (g_high)? TRUE \n\n\nGrafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- make_graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n¿Es conexo (g_low)? TRUE \n\n\nGrafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo.html#tipos-de-modelos-random-de-grafos",
    "href": "analisis_topo.html#tipos-de-modelos-random-de-grafos",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Tipos de modelos “random” de grafos",
    "text": "Tipos de modelos “random” de grafos\n\nGrafo de isla\nCreamos un grafo simple para ilustrar la funcionalidad básica.\n\n# Crear un grafo de isla\nset.seed(42)\ng &lt;- sample_islands(3, 10, 5/10, 1)\nplot(g, vertex.label=V(g)$name, main=\"Grafo de Isla\")\n\n\n\n\n\n\n\n\nLa función sample_islands genera un grafo que representa un conjunto de islas. En este modelo, cada “isla” es un conjunto de nodos altamente conectados, y hay pocas conexiones entre las islas. Este tipo de red se utiliza a menudo para modelar sistemas donde existen grupos interconectados, pero con poca interacción entre esos grupos.\nCaracterísticas:\nNodos dentro de una isla están densamente conectados. Pocas o ninguna conexión entre islas. Se observa un alto coeficiente de clustering dentro de las islas (More on this later :).\n\n**Que son los argumentos de la funcion? Como afectan las propiedades del grafo producido?\n\n\n\nEjemplos de modelos de grafos aleatorios\n\nModelo de Erdős-Rényi\n\n\n# Grafo Erdős-Rényi\ng_er &lt;- sample_gnp(100, p = 0.05)\nplot(g_er, vertex.size=5, main=\"Grafo Erdős-Rényi\")\n\n\n\n\n\n\n\n\nLa función sample_gnp genera un grafo aleatorio utilizando el modelo de Erdős-Rényi, donde se crea un grafo al agregar aristas de forma aleatoria entre un conjunto de nodos. Cada arista se incluye con una probabilidad p. Este modelo es útil para estudiar propiedades de grafos en general y es una buena representación de redes donde cada conexión es independiente.\nCaracterísticas:\nCada par de nodos tiene una probabilidad p de estar conectado. Puede generar redes densas o dispersas, dependiendo de p. Generalmente, presenta un coeficiente de clustering más bajo en comparación con redes altamente agrupadas (More on this later :).\n\nModelo de Barabási-Albert (scale-free)\n\n\n# Grafo Barabási-Albert\ng_ba &lt;- sample_pa(100)\nplot(g_ba, vertex.size=5, main=\"Grafo Barabási-Albert\")\n\n\n\n\n\n\n\n\nLa función sample_pa genera un grafo siguiendo el modelo de Barabási-Albert, que es un modelo de red de escala libre. Este modelo simula el crecimiento de redes donde nuevos nodos se conectan a nodos existentes con una probabilidad proporcional a su grado, lo que significa que los nodos más conectados tienen más probabilidades de recibir nuevas conexiones.\nCaracterísticas:\nGenera redes de escala libre con una distribución de grado que sigue una ley de potencia (more later). Presenta nodos hubs (nodos con un grado alto). Centralidad de grado generalmente alta en nodos muy conectados (more on this later)."
  },
  {
    "objectID": "analisis_topo.html#personalización-de-redes-en-igraph",
    "href": "analisis_topo.html#personalización-de-redes-en-igraph",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Personalización de redes en igraph",
    "text": "Personalización de redes en igraph\nAun mas ejemplos de personalización de redes, combinando factores, en un solo bloque de código con comentarios explicativos.\n\n# Personalización de redes en igraph\n\n# Grafo de ejemplo\ng &lt;- sample_gnp(20, p = 0.1)\n\n# Personalizar atributos de nodos\nV(g)$color &lt;- ifelse(degree(g) &gt; 2, \"red\", \"blue\")  # Color por grado\nV(g)$size &lt;- degree(g) * 3  # Tamaño de nodo proporcional al grado\nV(g)$label &lt;- paste0(\"Node:\", V(g))  # Etiquetas de nodos\n\n# Personalizar atributos de aristas\nE(g)$color &lt;- \"gray\"  # Color de aristas\nE(g)$width &lt;- 2  # Ancho de aristas\n\n# Graficar el grafo personalizado\nplot(g, vertex.label=V(g)$label, edge.arrow.size=0.5, \n     main=\"Grafo Personalizado: Atributos de Nodos y Aristas\")"
  },
  {
    "objectID": "analisis_topo.html#coeficiente-de-clustering-local",
    "href": "analisis_topo.html#coeficiente-de-clustering-local",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Coeficiente de Clustering local",
    "text": "Coeficiente de Clustering local\nEl coeficiente de clustering es una medida que indica la tendencia de los nodos en una red a agruparse en clústeres. Un alto coeficiente de clustering para un nodo (local) sugiere que un nodo es parte de una comunidad densa. En biología, esto puede ser relevante para estudiar interacciones entre proteínas, donde un alto coeficiente de clustering entre varios genes puede indicar una comunidad de proteínas que interactúan fuertemente entre sí.\nSe puede definir como:\n\\[\nC(v) = \\frac{2 \\times \\text{number of triangles through } v}{\\text{degree}(v) \\times (\\text{degree}(v) - 1)}\n\\]\nO quizas mas intuitivemente, puede definirse en términos de la proporción de triángulos presentes en el grafo en comparación con el número total de triángulos posibles que pueden formarse a partir de los vecinos de un nodo. Esta definición se centra en la noción de “triángulos” y se expresa como:\n\\[\nC(v) = \\frac{\\text{Número de triángulos en los vecinos de } v}{\\text{Número total de triángulos posibles entre los vecinos de } v}\n\\]\n\nInterpretación\n\nUn coeficiente de clustering cercano a 1 indica que los vecinos de un nodo están muy interconectados, formando un clúster denso.\nUn coeficiente de clustering cercano a 0 indica que los vecinos de un nodo están poco interconectados.\n\nEsta definición es útil para visualizar cómo las interacciones locales entre los nodos contribuyen a la estructura global de la red, y es especialmente relevante en el contexto de redes sociales y biológicas, donde se pueden observar grupos de interacciones fuertes entre ciertos nodos.\n\n\nCódigo para Calcular y Visualizar el Coeficiente de Clustering local\n\n# Crear una red aleatoria\nset.seed(42)\ng_clustering &lt;- sample_gnp(n = 15, p = 0.15, directed = FALSE)\n\n# Calcular el coeficiente de clustering por nodo\nvertex_clustering &lt;- transitivity(g_clustering, type = \"local\")\nV(g_clustering)$color &lt;- ifelse(vertex_clustering &gt; 0, \"red\", \"lightblue\")\n\n# Visualizar la red con coeficiente de clustering - si los vecinos estan conectadas, se visualiza en rojo!\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = \"Coeficiente de Clustering Local\")\n\n\n\n\n\n\n\n\nEste código calcula e imprime los coeficientes local de un pequeño grafo aleatorio y visualiza los nodos según el coeficiente de clustering &gt; 1, donde los nodos rojos tienen un coeficiente &gt; 1 (por lo menos un par de interactores interaccionan entre ellos - en otras palabras - FORMAN UN TRIANGULO) y los nodos azules tienen un coeficiente bajo."
  },
  {
    "objectID": "analisis_topo.html#coeficiente-de-clustering-global",
    "href": "analisis_topo.html#coeficiente-de-clustering-global",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Coeficiente de Clustering Global",
    "text": "Coeficiente de Clustering Global\n\nDefinición: El coeficiente de clustering global es una medida global que describe la tendencia general de la red de formar triángulos (conexiones entre tres nodos). Proporciona una visión general de la densidad de la red en términos de interacciones entre vecinos de los nodos.\nCálculo:\n\nUna forma común de calcular el coeficiente de clustering global es tomando el promedio de los coeficientes de clustering locales de todos los nodos en la red:\n\n\n\\[\n  C_{\\text{global}} = \\frac{1}{N} \\sum_{v \\in G} C(v)\n\\]\nDonde (N) es el número de nodos en el grafo y (C(v)) es el coeficiente de clustering local del nodo (v).\n\nAlternativamente, se puede definir como la relación entre el número de triángulos (tripletas de nodos completamente conectados) y el número de tripletas conectadas (un triplete es cualquier conjunto de 3 nodos conectados por 2 aristas):\n\n\\[ C\\_{\\text{global}} = \\frac{3 \\times \\text{Número de triángulos}}{\\text{Número de tripletas conectadas}} \\]\n\nInterpretación: Un coeficiente de clustering global cercano a 1 significa que la red está altamente agrupada (muchos nodos tienen coeficientes de clustering altos), mientras que un valor cercano a 0 sugiere que la red es más aleatoria, con menos agrupamientos locales.\n\n\nlibrary(igraph)\nset.seed(333)\n# High Global Clustering Coefficient - Small-World Network\ng_high_clustering &lt;- sample_smallworld(dim = 1, size = 30, nei = 3, p = 0.05)\nglobal_clustering_high &lt;- transitivity(g_high_clustering, type = \"global\")\ncat(\"Global Clustering Coefficient (High):\", global_clustering_high, \"\\n\")\n\nGlobal Clustering Coefficient (High): 0.4379085 \n\n# Low Global Clustering Coefficient - Random Network\ng_low_clustering &lt;- sample_gnp(30, p = 0.05, directed = FALSE)\nglobal_clustering_low &lt;- transitivity(g_low_clustering, type = \"global\")\ncat(\"Global Clustering Coefficient (Low):\", global_clustering_low, \"\\n\")\n\nGlobal Clustering Coefficient (Low): 0.1 \n\n# Plotting both networks\npar(mfrow = c(1, 2))\nplot(g_high_clustering, main = paste(\"High Clustering (Coeff:\", round(global_clustering_high, 2), \")\"),\n     vertex.size = 8, vertex.label = NA, edge.color = \"dodgerblue\")\nplot(g_low_clustering, main = paste(\"Low Clustering (Coeff:\", round(global_clustering_low, 2), \")\"),\n     vertex.size = 8, vertex.label = NA, edge.color = \"tomato\")\n\n\n\n\n\n\n\npar(mfrow = c(1, 1))\n\n\nEjemplo en biología\nEn las redes de interacción de proteínas, los genes que codifican proteínas que interactúan entre sí tienden a formar grupos o módulos con un alto coeficiente de clustering. Esto es relevante para identificar vías metabólicas o complejos proteicos."
  },
  {
    "objectID": "analisis_topo.html#centralidad",
    "href": "analisis_topo.html#centralidad",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Centralidad",
    "text": "Centralidad\nLa centralidad se refiere a la importancia de un nodo dentro de una red. Existen varios tipos de centralidad, entre ellos:\n\nCentralidad de grado (degree centrality): Número de conexiones directas de un nodo.\n\n\\[\nC_g(v) = \\text{degree}(v)\n\\]\n\nCentralidad de Intermediación (Betweenness Centrality):\nLa centralidad de intermediación es una medida clave en la teoría de redes que indica cuántas veces un nodo actúa como “puente” o intermediario entre otros nodos. Es un concepto crucial para entender la estructura de la red en términos de control o flujo de información, recursos, o influencia a través de los nodos de la red.\n\nDefinición Matemática:\nLa centralidad de intermediación de un nodo \\(v\\) en una red se define como:\n\\[\nC_b(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n\\]\n\n\\(\\sigma_{st}\\) es el número total de caminos más cortos entre los nodos \\(s\\) y \\(t\\).\n\\(\\sigma_{st}(v\\) es el número de esos caminos más cortos que pasan por el nodo \\(v\\).\n\nLa centralidad de intermediación calcula, para un nodo dado, la fracción de caminos más cortos entre todos los pares de nodos \\(s\\) y \\(t\\) en la red que pasan a través de él. Cuanto mayor sea este valor, más “importante” es ese nodo en la red en términos de conectar diferentes partes de la misma.\n\n\n\nExplicación Conceptual:\nLa centralidad de intermediación mide el papel de un nodo como intermediario entre otros nodos de la red. Un nodo con una centralidad de intermediación alta es uno que está en el medio de muchos caminos más cortos entre otros nodos. Esencialmente, estos nodos tienen un poder significativo en términos de control del flujo de información o recursos a través de la red.\n\n\nRelevancia en Biología:\nEn el contexto biológico, la centralidad de intermediación tiene aplicaciones en varias áreas, como las redes de interacción proteína-proteína (PPI), las redes metabólicas, y las redes de regulación génica. Identificar los nodos con alta centralidad de intermediación puede ayudar a entender los puntos de control clave o los “puentes” que facilitan la comunicación entre diferentes partes de una red biológica.\n\nEjemplos en Biología:\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nEn una red de interacción proteína-proteína, las proteínas con alta centralidad de intermediación pueden ser aquellas que conectan diferentes “modulos” funcionales dentro de la red. Estas proteínas actúan como puntos de control para la transmisión de señales entre distintas funciones celulares. Si una proteína con alta centralidad de intermediación se ve afectada por mutaciones, podría tener un impacto significativo en varias vías biológicas o incluso en la enfermedad.\nEjemplo: En una red PPI de una célula humana, una proteína como TP53 (p53), que tiene un papel central en la regulación del ciclo celular y la respuesta al daño del ADN, podría tener una alta centralidad de intermediación. Si p53 se ve alterada o desregulada, puede afectar numerosas vías celulares relacionadas con el cáncer, como la apoptosis, la reparación del ADN y la regulación del ciclo celular.\n\nRedes Metabólicas:\n\nEn una red metabólica, un metabolito o enzima con alta centralidad de intermediación puede ser clave para conectar diversas rutas metabólicas. Estos metabolitos actúan como puentes entre diferentes procesos metabólicos, lo que permite una integración eficiente de los recursos celulares.\nEjemplo: El ATP (adenosín trifosfato), que es esencial para casi todas las reacciones bioquímicas celulares, puede actuar como un nodo con alta centralidad de intermediación en una red metabólica. La alteración de la producción o el uso de ATP afecta una multitud de rutas metabólicas y es crucial para la función celular.\n\nRedes de Regulación Génica:\n\nEn las redes de regulación génica, los factores de transcripción que conectan diferentes conjuntos de genes pueden tener una alta centralidad de intermediación. Estos factores de transcripción no solo regulan la expresión de un conjunto de genes, sino que también actúan como intermediarios para la integración de diversas señales celulares.\nEjemplo: El factor de transcripción NF-kB es un nodo con alta centralidad de intermediación en las redes de regulación génica. Controla la expresión de genes implicados en la respuesta inmune y en procesos inflamatorios. Si NF-kB está desregulado, puede contribuir a enfermedades como el cáncer, enfermedades autoinmunes y trastornos inflamatorios.\n\n\n\n\nCódigo R para Calcular y Visualizar la Centralidad de Intermediación:\n\nset.seed(123)\ng &lt;- sample_gnp(10, p = 0.5)\n\n# Calculate betweenness centrality for all nodes\nbetweenness_centrality &lt;- betweenness(g)\n\n# Normalize the betweenness values for better visualization (optional)\nbetweenness_normalized &lt;- (betweenness_centrality - min(betweenness_centrality)) / \n    (max(betweenness_centrality) - min(betweenness_centrality))\n\n# Visualize the graph with nodes colored by betweenness centrality\nplot(g, \n     vertex.size = 20, \n     vertex.color = heat.colors(100, rev=TRUE)[round(betweenness_normalized * 99) + 1], # Color nodes based on centrality # Optionally remove labels\n     main = \"Graph colored by Betweenness Centrality\")"
  },
  {
    "objectID": "analisis_topo.html#propiedades-de-las-redes-de-escala-libre",
    "href": "analisis_topo.html#propiedades-de-las-redes-de-escala-libre",
    "title": "Análisis de grafos y topología de redes (I): Topología; Coef clustering; Centralidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Propiedades de las Redes de Escala Libre:",
    "text": "Propiedades de las Redes de Escala Libre:\n\n1. Distribución de Grado:\nLa distribución de grado en las redes de escala libre sigue una ley de potencia, lo que significa que el número de nodos con un cierto grado ( k ) (número de conexiones) disminuye rápidamente a medida que ( k ) aumenta. Matemáticamente, esto se expresa como:\n\\[\nP(k) \\sim k^{-\\gamma}\n\\]\nDonde:\n\n\\(P(k)\\) es la probabilidad de que un nodo tenga un grado \\(k\\).\n\\(k\\) es el grado de un nodo (el número de conexiones que tiene).\n\\(\\gamma\\) es el exponente de la ley de potencia, que típicamente se encuentra entre 2 y 3 en la mayoría de redes de escala libre.\n\nEste tipo de distribución es característica de redes autoorganizadas o generadas por crecimiento preferencial, donde nuevos nodos tienden a conectarse preferentemente a los nodos que ya están muy conectados. Esta propiedad genera hubs o nodos centrales, que son cruciales para la conectividad de la red.\n\nEjemplo en Biología: Redes de Interacción Proteína-Proteína (PPI)\nEn redes de interacción proteína-proteína (PPI), las proteínas más fundamentales para las funciones celulares tienden a tener un alto grado de conectividad, es decir, son hubs. Estas proteínas suelen ser las que orquestan múltiples procesos celulares, como la transcripción genética, la reparación del ADN y la señalización celular.\n\nEjemplo: BRCA1 (Breast Cancer 1) es una proteína clave en la reparación del ADN y en la regulación del ciclo celular. En las redes de interacción proteína-proteína (PPI), BRCA1 actúa como un hub, conectando muchas otras proteínas involucradas en procesos esenciales como la reparación del ADN, el control del ciclo celular, y la respuesta al daño genético. Debido a su papel central en estas vías, BRCA1 es crucial para la estabilidad genética de la célula.\n\nLa alteración o mutación de BRCA1 está asociada con un mayor riesgo de desarrollar cáncer de mama y ovario. Las mutaciones en BRCA1 afectan su capacidad para interactuar con otras proteínas de la red, lo que compromete la reparación del ADN y aumenta la probabilidad de que ocurran mutaciones genéticas que conduzcan al cáncer. En este caso, BRCA1 no solo es un hub en una red de interacciones, sino que también es un punto crítico para mantener la integridad genética celular.\n\n\n\n2. Centralidad y Robustez:\nUna de las características interesantes de las redes de escala libre es que, debido a la existencia de hubs, estas redes son robustas frente a fallos aleatorios. Esto significa que si se eliminan nodos de la red de manera aleatoria, la conectividad global de la red no se verá gravemente afectada, ya que los nodos de baja conectividad no son esenciales para la red. Sin embargo, si se atacan los hubs (nodos altamente conectados), la red puede volverse muy vulnerable, ya que la eliminación de estos nodos puede desconectar grandes partes de la red.\n\nEjemplo en Biología: Redes Neuronales\nEn las redes neuronales, los hubs son neuronas clave que conectan diferentes regiones del cerebro. La red de conectividad cerebral sigue una estructura de escala libre, donde ciertas neuronas tienen muchas conexiones con otras, permitiendo una comunicación eficiente entre regiones cerebrales distantes. Estas neuronas de alto grado son críticas para el procesamiento de información en el cerebro.\n\nEjemplo: El córtex prefrontal tiene neuronas de alta centralidad en las redes neuronales, que facilitan la integración de información de diferentes áreas cerebrales. Si se dañan estas neuronas (por ejemplo, en enfermedades neurodegenerativas), pueden ocurrir disfunciones cognitivas importantes.\n\n\n\n\n3. Vulnerabilidad a Ataques Dirigidos:\nDebido a su estructura jerárquica, las redes de escala libre son vulnerables a ataques dirigidos a los hubs. Al eliminar estos nodos clave, la conectividad de la red puede colapsar rápidamente, lo que afecta su funcionamiento global.\n\nEjemplo en biología: En las redes de interacción proteína-proteína, eliminar las proteínas clave (hubs) podría interrumpir varias vías biológicas simultáneamente, lo que llevaría a enfermedades o disfunciones celulares.\n\nTambien puede ser aprovechado - por ejemplo en el diseño de antibioticos, puede que buscan dianas que son hubs: atacar una proteina hub para afectar al maximo posible el funcionamiento de la bacteria\n\nEjemplo de Análisis de Redes de Escala Libre\nEn R, podemos generar y analizar una red de escala libre utilizando el modelo de Barabási-Albert (BA), que es un modelo clásico para generar redes de escala libre. A continuación se muestra un código en R que genera una red de escala libre y visualiza la distribución de grados:\n\n# Crear una red de escala libre usando el modelo de Barabási-Albert\ng_sf &lt;- sample_pa(1000)\n\n# Obtener la distribución de grado\ndegree_distribution &lt;- degree(g_sf)\n\n# Visualizar la distribución de grado\nhist(degree_distribution, breaks=50, main=\"Distribución de Grado de una Red de Escala Libre\", \n     xlab=\"Grado\", ylab=\"Frecuencia\")"
  },
  {
    "objectID": "func_enric.html",
    "href": "func_enric.html",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "",
    "text": "El análisis de enriquecimiento funcional (Functional Enrichment Analysis, FEA) es una metodología utilizada para identificar las categorías biológicas o procesos (por ejemplo, vías metabólicas, funciones moleculares) que están sobrerrepresentadas en un conjunto de genes frente a un conjunto de fondo.\n\n\nEl análisis de enriquecimiento funcional identifica temas o procesos biológicos (como rutas o funciones moleculares) que están sobre-representados en un conjunto de genes comparado con un conjunto de fondo.\n\n\n\nEl FEA ayuda a interpretar la relevancia biológica de grandes conjuntos de datos, como aquellos obtenidos en experimentos de genómica o transcriptómica, proporcionando contexto biológico para los hallazgos.\nEl FEA generalmente involucra tres componentes principales:\n\nConjunto de genes de consulta (por ejemplo, conjunto de genes sin ordenar o clasificado).\nSistema de clasificación funcional – bases de datos de vías, ontologías y otras categorías funcionales.\nAlgoritmo de enriquecimiento – compara los genes de consulta con el sistema de clasificación funcional para identificar categorías sobrerrepresentadas."
  },
  {
    "objectID": "func_enric.html#definición",
    "href": "func_enric.html#definición",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "",
    "text": "El análisis de enriquecimiento funcional identifica temas o procesos biológicos (como rutas o funciones moleculares) que están sobre-representados en un conjunto de genes comparado con un conjunto de fondo."
  },
  {
    "objectID": "func_enric.html#idea-clave",
    "href": "func_enric.html#idea-clave",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "",
    "text": "El FEA ayuda a interpretar la relevancia biológica de grandes conjuntos de datos, como aquellos obtenidos en experimentos de genómica o transcriptómica, proporcionando contexto biológico para los hallazgos.\nEl FEA generalmente involucra tres componentes principales:\n\nConjunto de genes de consulta (por ejemplo, conjunto de genes sin ordenar o clasificado).\nSistema de clasificación funcional – bases de datos de vías, ontologías y otras categorías funcionales.\nAlgoritmo de enriquecimiento – compara los genes de consulta con el sistema de clasificación funcional para identificar categorías sobrerrepresentadas."
  },
  {
    "objectID": "func_enric.html#ejemplos-de-conjuntos-de-genes-de-consulta",
    "href": "func_enric.html#ejemplos-de-conjuntos-de-genes-de-consulta",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "Ejemplos de conjuntos de genes de consulta:",
    "text": "Ejemplos de conjuntos de genes de consulta:\n\nListas no ordenadas: Genes asociados a un fenotipo, como los genes relacionados con términos de HPO (Human Phenotype Ontology), genes implicados en expresión diferencial, módulos de co-expresión o hubs de red.\nListas ordenadas: Genes ordenados por cambios en la expresión (por ejemplo, log2 de cambio en la expresión o significancia estadística).\n\nEstos conjuntos de genes se comparan luego con una base de datos de categorías funcionales para identificar términos o procesos enriquecidos en el conjunto de interés."
  },
  {
    "objectID": "func_enric.html#bases-de-datos-de-vías",
    "href": "func_enric.html#bases-de-datos-de-vías",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "1. Bases de datos de vías:",
    "text": "1. Bases de datos de vías:\nSon colecciones de interacciones moleculares y procesos que representan rutas biológicas como transducción de señales, vías metabólicas y regulación génica.\n\nEjemplos de bases de datos de vías:\n\nKEGG (Kyoto Encyclopedia of Genes and Genomes): Vías metabólicas y de señalización.\nReactome: Eventos moleculares detallados en rutas biológicas.\nBioCarta: Procesos celulares y vías de señalización."
  },
  {
    "objectID": "func_enric.html#ontologías",
    "href": "func_enric.html#ontologías",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "2. Ontologías:",
    "text": "2. Ontologías:\nSon representaciones jerárquicas de conceptos biológicos y sus relaciones. Permiten organizar el conocimiento biológico en términos amplios o específicos.\n\nEjemplos de ontologías:\n\nGene Ontology (GO):\n\nBiological Process (BP): Funciones biológicas realizadas por un conjunto de genes.\nMolecular Function (MF): Actividades de los genes o proteínas individuales.\nCellular Component (CC): Ubicaciones de los productos génicos dentro de las células.\n\nHuman Phenotype Ontology (HPO): Anomalías fenotípicas asociadas con enfermedades humanas."
  },
  {
    "objectID": "func_enric.html#análisis-de-sobrerrepresentación-ora",
    "href": "func_enric.html#análisis-de-sobrerrepresentación-ora",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "Análisis de Sobrerrepresentación (ORA)",
    "text": "Análisis de Sobrerrepresentación (ORA)\n\n¿Cómo calcula el p-valor el test exacto de Fisher?\nEl test exacto de Fisher se utiliza para calcular el p-valor en el análisis de sobrerrepresentación. A continuación, te muestro un ejemplo con valores reales.\nImaginemos que estamos analizando el término GO GO:0007155 (“adhesion celular”) en un conjunto de genes y queremos comprobar si está sobrerrepresentado en el conjunto de genes de consulta frente al fondo.\n\n\nTabla de contingencia:\n\n\n\n\n\n\n\n\n\nGenes con GO:0007155\nGenes sin GO:0007155\n\n\n\n\nGenes de Consulta\n25\n75\n\n\nGenes de Fondo\n100\n800\n\n\n\n#### Cálculo del p-valor:\nEl p-valor se calcula con el test exacto de Fisher utilizando la siguiente fórmula:\n\\[\n  P = \\frac{(a+b)! (c+d)! (a+c)! (b+d)!}{a! b! c! d! (a+b+c+d)!}\n\\]\nDonde:\n\na = 25 (genes de consulta con GO:0007155)\nb = 75 (genes de consulta sin GO:0007155)\nc = 100 (genes de fondo con GO:0007155)\nd = 800 (genes de fondo sin GO:0007155)\n\nEl cálculo se realiza con el siguiente código en R:\n\n# Tabla de contingencia\na &lt;- 25  # Genes de consulta con GO:0007155\nb &lt;- 75  # Genes de consulta sin GO:0007155\nc &lt;- 100 # Genes de fondo con GO:0007155\nd &lt;- 800 # Genes de fondo sin GO:0007155\n\n# Realizar el test exacto de Fisher\nfisher_result &lt;- fisher.test(matrix(c(a, b, c, d), nrow = 2))\n\n# Mostrar el p-valor\nfisher_result$p.value\n\n[1] 0.0003224737\n\n\nEste código devolverá el p-valor, que indica si el término GO:0007155 está sobrerrepresentado en el conjunto de genes de consulta."
  },
  {
    "objectID": "func_enric.html#implementación-de-ora-en-clusterprofiler",
    "href": "func_enric.html#implementación-de-ora-en-clusterprofiler",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "Implementación de ORA en clusterProfiler",
    "text": "Implementación de ORA en clusterProfiler\nAhora que hemos cubierto la teoría, pasemos a la implementación práctica de ORA utilizando el paquete clusterProfiler en R.\n\n1. Cargar el Paquete\n\n# Cargar el paquete clusterProfiler y base de datos humano\nlibrary(clusterProfiler)\n\n\n\n\nclusterProfiler v4.14.3 Learn more at https://yulab-smu.top/contribution-knowledge-mining/\n\nPlease cite:\n\nG Yu. Thirteen years of clusterProfiler. The Innovation. 2024,\n5(6):100722\n\n\n\nAttaching package: 'clusterProfiler'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nlibrary(org.Hs.eg.db)\n\nLoading required package: AnnotationDbi\n\n\nLoading required package: stats4\n\n\nLoading required package: BiocGenerics\n\n\n\nAttaching package: 'BiocGenerics'\n\n\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n\n\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, saveRDS, setdiff,\n    table, tapply, union, unique, unsplit, which.max, which.min\n\n\nLoading required package: Biobase\n\n\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n\n\nLoading required package: IRanges\n\n\nLoading required package: S4Vectors\n\n\n\nAttaching package: 'S4Vectors'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    rename\n\n\nThe following object is masked from 'package:utils':\n\n    findMatches\n\n\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n\n\n\nAttaching package: 'IRanges'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    slice\n\n\n\nAttaching package: 'AnnotationDbi'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    select\n\n\n\n\nlibrary(enrichplot)\n\nenrichplot v1.26.2 Learn more at https://yulab-smu.top/contribution-knowledge-mining/\n\nPlease cite:\n\nGuangchuang Yu, Li-Gen Wang, and Qing-Yu He. ChIPseeker: an\nR/Bioconductor package for ChIP peak annotation, comparison and\nvisualization. Bioinformatics. 2015, 31(14):2382-2383\n\n\n\n\n2. Definir los Genes de Interés\nSupongamos que tenemos un conjunto de genes de interés que han sido identificados en un experimento (por ejemplo, genes asociados con cáncer).\n\n# Lista de genes de interés (nombres reales de genes)\ngenes_of_interest &lt;- c(\"BRCA1\", \"TP53\", \"EGFR\", \"MYC\", \"KRAS\")\n\n\n\n3. Realizar el Análisis de Sobrerrepresentación\nUsamos la función enrichGO() para realizar el análisis de sobrerrepresentación de términos GO: Biological Process (BP).\n\n# Realizar el análisis de ORA con términos GO: Biological Process\ngo_enrich &lt;- enrichGO(gene = genes_of_interest, \n                      OrgDb = org.Hs.eg.db, \n                      keyType = \"SYMBOL\", \n                      ont = \"BP\", \n                      pAdjustMethod = \"BH\",  # Ajuste de p-valor con método Benjamini-Hochberg\n                      pvalueCutoff = 0.05)   # Umbral de significancia\n\nhead(as.data.frame(go_enrich))[1:5,]\n\n                   ID                                    Description GeneRatio\nGO:0009314 GO:0009314                          response to radiation       5/5\nGO:0060251 GO:0060251         regulation of glial cell proliferation       3/5\nGO:1902895 GO:1902895     positive regulation of miRNA transcription       3/5\nGO:0014009 GO:0014009                       glial cell proliferation       3/5\nGO:2000630 GO:2000630 positive regulation of miRNA metabolic process       3/5\n             BgRatio RichFactor FoldEnrichment   zScore       pvalue\nGO:0009314 442/18986 0.01131222       42.95475 14.48509 6.688266e-09\nGO:0060251  42/18986 0.07142857      271.22857 28.45449 1.003511e-07\nGO:1902895  56/18986 0.05357143      203.42143 24.62101 2.420427e-07\nGO:0014009  61/18986 0.04918033      186.74754 23.58310 3.141295e-07\nGO:2000630  67/18986 0.04477612      170.02388 22.49402 4.179279e-07\n               p.adjust       qvalue                   geneID Count\nGO:0009314 5.190095e-06 1.182767e-06 BRCA1/TP53/EGFR/MYC/KRAS     5\nGO:0060251 3.893621e-05 8.873147e-06           TP53/EGFR/KRAS     3\nGO:1902895 4.947356e-05 1.127450e-05            TP53/EGFR/MYC     3\nGO:0014009 4.947356e-05 1.127450e-05           TP53/EGFR/KRAS     3\nGO:2000630 4.947356e-05 1.127450e-05            TP53/EGFR/MYC     3\n\n\n\n\n4. Visualizar los Resultados\nPodemos visualizar los resultados de ORA en un gráfico de puntos utilizando la función dotplot():\n\n# Visualizar los resultados de ORA\ndotplot(go_enrich)\n\n\n\n\n\n\n\n\nEste gráfico mostrará los términos de GO que están significativamente enriquecidos en el conjunto de genes de interés."
  },
  {
    "objectID": "func_enric.html#gene-set-enrichment-analysis-gsea",
    "href": "func_enric.html#gene-set-enrichment-analysis-gsea",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "Gene Set Enrichment Analysis (GSEA)",
    "text": "Gene Set Enrichment Analysis (GSEA)\nEl Gene Set Enrichment Analysis (GSEA) es una metodología utilizada para determinar si los genes de un conjunto específico (o gene set) están distribuidos de manera enriquecida en las posiciones altas o bajas de una lista ordenada de genes. A diferencia de otros métodos, como el Análisis de Sobrerrepresentación (ORA), GSEA no requiere un umbral predefinido para seleccionar genes significativos. En cambio, utiliza toda la lista de genes ordenados de acuerdo a una métrica, como el cambio en la expresión génica o el valor p, para identificar si las categorías funcionales (como Gene Ontology (GO) o vías de KEGG) están asociadas con genes más relevantes.\n\n¿Cómo funciona GSEA?\nEl algoritmo de GSEA calcula una puntuación de enriquecimiento (Enrichment Score, ES) para cada conjunto de genes basado en cómo estos genes se distribuyen en la lista ordenada de genes. Esta puntuación refleja cuán “enriquecidos” están los genes de un conjunto en las primeras o últimas posiciones de la lista.\n\n\nPuntuación de Enriquecimiento (ES) y el Hit Score\nEn GSEA, la puntuación de enriquecimiento (ES) se calcula utilizando un hit score que aumenta o disminuye conforme se recorre la lista de genes. El proceso es el siguiente:\n\nOrdenar los genes: Primero, se ordenan los genes en función de una métrica de interés (por ejemplo, el log2 fold change entre dos condiciones experimentales).\nPuntuación del “hit”: A medida que se recorre la lista de genes ordenados, la puntuación aumenta cuando un gen que pertenece al conjunto de genes de interés (“hit”) aparece en la lista. Cada vez que un gen de la lista pertenece al conjunto de genes, se suma un valor positivo al hit score. En caso contrario, la puntuación disminuye, lo que puede causar que el hit score baje en valores negativos.\nMáxima puntuación de hit (ES): La puntuación de enriquecimiento (ES) es el valor máximo alcanzado por el hit score a medida que se avanza por la lista. Es decir, se recorre la lista de genes, acumulando el hit score conforme aparecen genes del conjunto de interés. La puntuación ES será el valor más alto que alcance el hit score durante todo el recorrido.\n\n\n\nNormalización de la Puntuación de Enriquecimiento (ES)\nLa puntuación ES puede normalizarse para evitar sesgos debido al tamaño del conjunto de genes. La normalización se realiza dividiendo la puntuación ES entre el tamaño del conjunto de genes, lo que permite hacer comparaciones más justas entre diferentes conjuntos de genes."
  },
  {
    "objectID": "func_enric.html#ejemplo-de-gsea-con-r",
    "href": "func_enric.html#ejemplo-de-gsea-con-r",
    "title": "Análisis de Enriquecimiento Funcional (Functional Enrichment Analysis, FEA) con R",
    "section": "Ejemplo de GSEA con R",
    "text": "Ejemplo de GSEA con R\nEn este ejemplo, utilizaremos una lista de genes ordenados por log2 fold change y realizaremos un análisis de GSEA para determinar si los conjuntos de genes asociados con ciertas vías están enriquecidos en los genes con mayor cambio de expresión.\n\n1. Instalar y cargar las bibliotecas necesarias\nPrimero, necesitamos instalar y cargar los paquetes necesarios para realizar GSEA en R, como clusterProfiler y org.Hs.eg.db (base de datos de genes humanos).\n\n# Cargar los paquetes necesarios (como con ORA)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nlibrary(enrichplot)\n\n\n\n2. Preparar los datos de entrada\nSupongamos que tenemos una lista de genes ordenados por log2 fold change. Para este ejemplo, utilizamos genes simulados con su respectivo valor de log2 fold change.\n\n# Define significant genes associated with apoptosis (example GO term)\nsignificant_genes &lt;- c(\n  \"TP53\", \"BAX\", \"CASP3\", \"CASP8\", \"FAS\", \"FASLG\", \"BCL2\", \"BCL2L1\",\n  \"CYCS\", \"BAD\", \"BID\", \"DIABLO\", \"XIAP\", \"TRAF2\", \"TNFRSF10B\"\n)\n\n# Get 500 random gene symbols from org.Hs.eg.db (or another source)\nlibrary(org.Hs.eg.db)\nall_genes &lt;- keys(org.Hs.eg.db, keytype = \"SYMBOL\")\nset.seed(321)  # Ensure reproducibility\nrandom_genes &lt;- sample(setdiff(all_genes, significant_genes), 5000)\n\n# Assign log2FC values\nset.seed(321)\nlog2FC_significant &lt;- runif(length(significant_genes), 2, 5)\nlog2FC_random &lt;- runif(length(random_genes), -1, 1)  # Smaller log2FC for random genes\n\n# Combine into a single data frame\ngene_list &lt;- data.frame(\n  Gene = c(significant_genes, random_genes),\n  log2FC = c(log2FC_significant, log2FC_random)\n)\n\n# Prepare named vector for gseGO input\ngene_list_vector &lt;- setNames(gene_list$log2FC, gene_list$Gene)\n\n# Sort gene list in descending order\ngene_list_vector &lt;- sort(gene_list_vector, decreasing = TRUE)\n\n# Preview the top of the gene list\nhead(gene_list_vector)\n\n     TP53       BAX       BAD      XIAP       BID TNFRSF10B \n 4.867681  4.811857  4.419787  4.299015  3.817163  3.776516 \n\n\n\n\n3. Realizar el análisis de GSEA\nUtilizamos el paquete clusterProfiler para realizar GSEA sobre los términos de Gene Ontology (GO) en el subdominio de Biological Process (BP).\n\n# Realizar el análisis GSEA para los términos GO: Biological Process (BP)\ngseGO_results &lt;- gseGO(\n   geneList = gene_list_vector,\n   OrgDb = org.Hs.eg.db,  \n   keyType = \"SYMBOL\",\n   ont = \"BP\",            # Biological Process\n   pvalueCutoff = 0.05\n)\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nWarning in fgseaMultilevel(pathways = pathways, stats = stats, minSize =\nminSize, : For some of the pathways the P-values were likely overestimated. For\nsuch pathways log2err is set to NA.\n\n\nWarning in fgseaMultilevel(pathways = pathways, stats = stats, minSize =\nminSize, : For some pathways, in reality P-values are less than 1e-10. You can\nset the `eps` argument to zero for better estimation.\n\n\nleading edge analysis...\n\n\ndone...\n\n head(gseGO_results)\n\n                   ID                                  Description setSize\nGO:0097190 GO:0097190                  apoptotic signaling pathway      25\nGO:0043065 GO:0043065     positive regulation of apoptotic process      26\nGO:0043068 GO:0043068 positive regulation of programmed cell death      26\nGO:0008219 GO:0008219                                   cell death      57\nGO:0012501 GO:0012501                        programmed cell death      57\nGO:0006915 GO:0006915                            apoptotic process      56\n           enrichmentScore      NES pvalue     p.adjust       qvalue rank\nGO:0097190       0.8868159 3.200067  1e-10 2.515385e-09 8.178138e-10   15\nGO:0043065       0.8602230 3.152060  1e-10 2.515385e-09 8.178138e-10   15\nGO:0043068       0.8602230 3.152060  1e-10 2.515385e-09 8.178138e-10   15\nGO:0008219       0.6887329 3.136304  1e-10 2.515385e-09 8.178138e-10   15\nGO:0012501       0.6887329 3.136304  1e-10 2.515385e-09 8.178138e-10   15\nGO:0006915       0.6892837 3.101842  1e-10 2.515385e-09 8.178138e-10   15\n                            leading_edge\nGO:0097190 tags=56%, list=0%, signal=56%\nGO:0043065 tags=50%, list=0%, signal=50%\nGO:0043068 tags=50%, list=0%, signal=50%\nGO:0008219 tags=26%, list=0%, signal=27%\nGO:0012501 tags=26%, list=0%, signal=27%\nGO:0006915 tags=27%, list=0%, signal=27%\n                                                                               core_enrichment\nGO:0097190      TP53/BAX/BAD/BID/TNFRSF10B/BCL2/CYCS/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\nGO:0043065           TP53/BAX/BAD/BID/TNFRSF10B/BCL2/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\nGO:0043068           TP53/BAX/BAD/BID/TNFRSF10B/BCL2/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\nGO:0008219 TP53/BAX/BAD/XIAP/BID/TNFRSF10B/BCL2/CYCS/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\nGO:0012501 TP53/BAX/BAD/XIAP/BID/TNFRSF10B/BCL2/CYCS/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\nGO:0006915 TP53/BAX/BAD/XIAP/BID/TNFRSF10B/BCL2/CYCS/FAS/DIABLO/FASLG/BCL2L1/CASP8/CASP3/TRAF2\n\n# Visualizar los resultados\ngseaplot2(gseGO_results, geneSetID = 1, title = gseGO_results$Description[1])\n\n\n\n\n\n\n\n\n\n\n4. Interpretación de los resultados\nLa tabla muestra los términos GO enriquecidos. Los términos GO que tienen una puntuación de ES alta y valores de p bajos son los más significativos.\nEl gráfico generado por gseaplot2 demuestra que los genes relacionados con la apoptosis aparecen hacia el principio de la lista, lo que da como resultado un valor de enriquecimiento (ES) muy alto. Esto no debería sorprendernos, ya que forzamos que estos genes se encuentren al principio de la lista asignándoles valores de FC muy altos.\n\n\n5. Ejemplo de buena puntuación de GSEA\nSupongamos que en el conjunto de genes tenemos una vía de cáncer de mama que incluye genes como BRCA1, TP53, y PIK3CA. Si esta vía está bien representada en los genes con log2 fold change altos (es decir, los genes más diferenciales), el valor de ES será alto, indicando que esta vía está enriquecida en los genes más relevantes.\nEl análisis de GSEA nos ayudará a identificar si las vías relacionadas con el cáncer de mama están particularmente enriquecidas en genes con alto cambio de expresión, lo que podría sugerir que estos genes son importantes para el fenotipo observado."
  },
  {
    "objectID": "analisis_topo_1.html",
    "href": "analisis_topo_1.html",
    "title": "Biología de Sistemas",
    "section": "",
    "text": "La modularidad es una medida de la estructura de una red que evalúa la fortaleza de la división de la red en módulos o comunidades. Un módulo es un conjunto de nodos que están más densamente conectados entre sí en comparación con otros nodos de la red. La modularidad es útil para identificar comunidades o agrupamientos dentro de la red.\nLa modularidad se calcula comparando la densidad de conexiones dentro de los módulos con la que se esperaría en una red aleatoria con la misma distribución de grados.\n\n\nLa modularidad, ( Q ), de una partición en módulos se calcula usando la siguiente ecuación:\n\\[\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n\\]\ndonde: - \\(m\\) es el número total de aristas en la red. - \\(A_{ij}\\) es el valor en la posición \\((i, j)\\) de la matriz de adyacencia, donde \\(A_{ij} = 1\\) si hay una arista entre los nodos \\(i\\) y \\(j\\), y \\(0\\) en caso contrario. - \\(k_i\\) y \\(k_j\\) son los grados de los nodos \\(i\\) y \\(j\\), respectivamente. - \\(\\delta(c_i, c_j)\\) es la función delta de Kronecker, que es 1 si \\(c_i = c_j\\) (es decir, los nodos \\(i\\) y \\(j\\) están en el mismo módulo) y 0 en caso contrario.\nLa modularidad \\(Q\\) varía entre -1 y 1, donde valores cercanos a 1 indican una alta modularidad, es decir, una red con comunidades bien definidas. Valores cercanos a 0 o negativos indican una estructura comunitaria poco definida o inexistente.\nAquí tienes la sección revisada con dos ejemplos utilizando sample_islands, que ilustran redes con modularidad alta y baja. Esta función crea redes con distintas “islas” o comunidades y nos permite ajustar el número de nodos y el nivel de conectividad entre comunidades para observar el efecto en la modularidad."
  },
  {
    "objectID": "analisis_topo_1.html#modularity-en-redes",
    "href": "analisis_topo_1.html#modularity-en-redes",
    "title": "Biología de Sistemas",
    "section": "",
    "text": "La modularidad es una medida de la estructura de una red que evalúa la fortaleza de la división de la red en módulos o comunidades. Un módulo es un conjunto de nodos que están más densamente conectados entre sí en comparación con otros nodos de la red. La modularidad es útil para identificar comunidades o agrupamientos dentro de la red.\nLa modularidad se calcula comparando la densidad de conexiones dentro de los módulos con la que se esperaría en una red aleatoria con la misma distribución de grados.\n\n\nLa modularidad, ( Q ), de una partición en módulos se calcula usando la siguiente ecuación:\n\\[\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n\\]\ndonde: - \\(m\\) es el número total de aristas en la red. - \\(A_{ij}\\) es el valor en la posición \\((i, j)\\) de la matriz de adyacencia, donde \\(A_{ij} = 1\\) si hay una arista entre los nodos \\(i\\) y \\(j\\), y \\(0\\) en caso contrario. - \\(k_i\\) y \\(k_j\\) son los grados de los nodos \\(i\\) y \\(j\\), respectivamente. - \\(\\delta(c_i, c_j)\\) es la función delta de Kronecker, que es 1 si \\(c_i = c_j\\) (es decir, los nodos \\(i\\) y \\(j\\) están en el mismo módulo) y 0 en caso contrario.\nLa modularidad \\(Q\\) varía entre -1 y 1, donde valores cercanos a 1 indican una alta modularidad, es decir, una red con comunidades bien definidas. Valores cercanos a 0 o negativos indican una estructura comunitaria poco definida o inexistente.\nAquí tienes la sección revisada con dos ejemplos utilizando sample_islands, que ilustran redes con modularidad alta y baja. Esta función crea redes con distintas “islas” o comunidades y nos permite ajustar el número de nodos y el nivel de conectividad entre comunidades para observar el efecto en la modularidad."
  },
  {
    "objectID": "analisis_topo_1.html#modularidad-en-redes-y-su-cálculo-en-igraph",
    "href": "analisis_topo_1.html#modularidad-en-redes-y-su-cálculo-en-igraph",
    "title": "Biología de Sistemas",
    "section": "Modularidad en Redes y su Cálculo en igraph",
    "text": "Modularidad en Redes y su Cálculo en igraph\nLa modularidad en redes se refiere a la tendencia de los nodos a agruparse en comunidades o módulos. Este concepto es fundamental en el análisis de redes complejas, ya que una modularidad alta indica que la red tiene comunidades bien definidas, donde las conexiones dentro de cada comunidad son densas y las conexiones entre comunidades son escasas. En biología, esta estructura modular es común en redes como las de interacción proteica y rutas metabólicas.\n\nEcuación de la Modularidad\nLa modularidad de una partición de la red en comunidades se calcula mediante la fórmula:\n[ Q = _{i,j} (c_i, c_j) ]\ndonde: - ( A_{ij} ) es la matriz de adyacencia de la red (1 si hay una conexión entre (i) y (j), 0 en caso contrario), - ( k_i ) y ( k_j ) son los grados de los nodos (i) y (j), - ( m ) es el número total de enlaces en la red, - ( (c_i, c_j) ) es una función que es 1 si los nodos (i) y (j) están en la misma comunidad y 0 en caso contrario.\nEsta ecuación permite calcular un valor de modularidad ( Q ) para evaluar qué tan bien definida está la estructura modular de una red.\n\n\nEjemplos de Redes con Alta y Baja Modularidad usando sample_islands\n\nEjemplo 1: Red con Alta Modularidad\nEn este ejemplo, crearemos una red con varias comunidades bien definidas, donde los nodos dentro de cada comunidad están fuertemente conectados entre sí, pero las conexiones entre comunidades son escasas. Esto genera una alta modularidad.\n\n# Cargar el paquete igraph\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# Crear una red con alta modularidad usando sample_islands\nset.seed(3)\ng_high_modularity &lt;- sample_islands(islands.n=4, islands.size=10, islands.pin=0.8, n.inter=3)\n\n# Detectar comunidades usando el algoritmo de Louvain\ncommunity_high &lt;- cluster_louvain(g_high_modularity)\n\n# Calcular la modularidad\nmodularity_high &lt;- modularity(community_high)\ncat(\"Modularidad de la red con alta modularidad:\", modularity_high, \"\\n\")\n\nModularidad de la red con alta modularidad: 0.6414937 \n\n# Visualizar la red y las comunidades\nV(g_high_modularity)$color &lt;- membership(community_high)\nplot(g_high_modularity, vertex.color = V(g_high_modularity)$color, main = \"Red con Alta Modularidad\")\n\n\n\n\n\n\n\n\nEn este caso, la modularidad es alta, lo cual indica que la red presenta comunidades bien definidas, con muchos enlaces dentro de cada comunidad y pocos entre ellas. Este tipo de estructura es común en redes biológicas robustas, como las de interacción proteica en células especializadas.\n\n\nEjemplo 2: Red con Baja Modularidad\nA continuación, crearemos una red con menor modularidad, utilizando sample_islands con menos comunidades y mayor conectividad entre ellas. Esto reduce la modularidad, pues los nodos están más distribuidos y menos agrupados en módulos.\n\n# Crear una red con baja modularidad usando sample_islands\nset.seed(4)\ng_low_modularity &lt;- sample_islands(islands.n=4, islands.size=10, islands.pin=0.3, n.inter=5)\n\n# Detectar comunidades usando el algoritmo de Louvain\ncommunity_low &lt;- cluster_louvain(g_low_modularity)\n\n# Calcular la modularidad\nmodularity_low &lt;- modularity(community_low)\ncat(\"Modularidad de la red con baja modularidad:\", modularity_low, \"\\n\")\n\nModularidad de la red con baja modularidad: 0.4427343 \n\n# Visualizar la red y las comunidades\nV(g_low_modularity)$color &lt;- membership(community_low)\nplot(g_low_modularity, vertex.color = V(g_low_modularity)$color, main = \"Red con Baja Modularidad\")\n\n\n\n\n\n\n\n\nEn esta red, la modularidad es más baja debido a la mayor conectividad entre las comunidades, lo cual dificulta identificar módulos bien definidos. Redes de este tipo pueden aparecer en sistemas biológicos menos especializados o en procesos donde existe una integración funcional alta entre diferentes módulos, como en algunas redes metabólicas.\n\n\n\nInterpretación en Biología\nLa modularidad alta en redes biológicas es indicativa de una especialización funcional, donde cada módulo o comunidad realiza una función específica. Por otro lado, redes con baja modularidad pueden sugerir funciones integradas y sistemas menos especializados. En biología de sistemas, analizar la modularidad ayuda a descubrir módulos funcionales y a entender la organización jerárquica de los sistemas biológicos.\n\n\nDescripción del Código\n\nDetección de Comunidades: Utilizamos cluster_louvain para detectar comunidades en la red. Este algoritmo es eficiente para maximizar la modularidad y encontrar módulos bien definidos.\nCálculo de Modularidad: Con modularity(community), calculamos la modularidad de la partición de la red en comunidades. Esto nos da una medida de la calidad de la estructura de la red en términos de módulos.\nVisualización de Comunidades: Coloreamos los nodos de acuerdo con la comunidad a la que pertenecen usando membership(community) para facilitar la visualización de las divisiones de la red.\n\n\n\n\nInterpretación de Modularidad\nUn valor alto de modularidad sugiere que la red tiene una estructura de comunidad fuerte, con nodos más densamente conectados dentro de los módulos y menos conectados con nodos de otros módulos. La modularidad es especialmente útil en biología para identificar grupos funcionales de proteínas en redes de interacción o redes de coexpresión genética, donde los módulos pueden representar rutas o complejos funcionales."
  },
  {
    "objectID": "analisis_topo_1.html#modularidad-en-redes-biológicas-y-su-aplicación-en-biología-de-sistemas",
    "href": "analisis_topo_1.html#modularidad-en-redes-biológicas-y-su-aplicación-en-biología-de-sistemas",
    "title": "Biología de Sistemas",
    "section": "Modularidad en Redes Biológicas y su Aplicación en Biología de Sistemas",
    "text": "Modularidad en Redes Biológicas y su Aplicación en Biología de Sistemas\nEn biología, la modularidad es fundamental para analizar la organización de redes complejas, como redes de interacción proteica, redes de regulación genética y redes metabólicas. En estas redes, la modularidad ayuda a identificar complejos de proteínas, rutas metabólicas, y módulos funcionales que son esenciales para procesos celulares específicos. Estos módulos reflejan funciones biológicas que están integradas y muchas veces aisladas en cuanto a su función dentro de la célula, haciendo de la modularidad una herramienta poderosa para descubrir nuevas relaciones biológicas y entender la robustez de los sistemas.\n\nEjemplo 1: Red de Interacción Proteica\nEn una red de interacción proteica, los nodos representan proteínas y las aristas representan interacciones físicas entre ellas. Las proteínas suelen agruparse en complejos que funcionan conjuntamente en procesos celulares específicos. Al analizar la modularidad de esta red, se pueden identificar módulos que representan estos complejos proteicos.\nCódigo en igraph para analizar una red de interacción proteica simulada:\n\n# Crear una red simulada con estructura modular, representando interacción proteica\nset.seed(1)\ng_protein &lt;- sample_pa(50, m = 3, directed = FALSE)\n\n# Detectar comunidades en la red de interacción proteica usando el algoritmo de Louvain\ncommunity_protein &lt;- cluster_louvain(g_protein)\n\n# Calcular la modularidad de la partición\nmodularity_protein &lt;- modularity(community_protein)\ncat(\"Modularidad de la red de interacción proteica:\", modularity_protein, \"\\n\")\n\nModularidad de la red de interacción proteica: 0.3002508 \n\n# Visualizar la red y las comunidades\nV(g_protein)$color &lt;- membership(community_protein)\nplot(g_protein, vertex.color = V(g_protein)$color, main = \"Red de Interacción Proteica con Comunidades\")\n\n\n\n\n\n\n\n\nEn este ejemplo, cada módulo (comunidad) detectado podría corresponder a un complejo proteico. La modularidad cuantifica la efectividad de esta división y sugiere una estructura comunitaria bien definida si el valor es alto, lo cual es común en redes biológicas debido a la especialización de funciones.\n\n\nEjemplo 2: Red Metabólica\nEn una red metabólica, los nodos representan metabolitos y las aristas representan reacciones bioquímicas que convierten un metabolito en otro. La modularidad en este contexto puede ayudar a identificar rutas metabólicas o subconjuntos de metabolitos y reacciones que forman un proceso metabólico completo, como la glucólisis o el ciclo del ácido cítrico.\nCódigo en igraph para analizar una red metabólica simulada:\n\n# Crear una red metabólica simulada con estructura modular\nset.seed(2)\ng_metabolic &lt;- sample_smallworld(1, 50, 4, 0.05)\n\n# Detectar comunidades en la red metabólica usando el algoritmo de Louvain\ncommunity_metabolic &lt;- cluster_louvain(g_metabolic)\n\n# Calcular la modularidad de la partición\nmodularity_metabolic &lt;- modularity(community_metabolic)\ncat(\"Modularidad de la red metabólica:\", modularity_metabolic, \"\\n\")\n\nModularidad de la red metabólica: 0.518775 \n\n# Visualizar la red y las comunidades\nV(g_metabolic)$color &lt;- membership(community_metabolic)\nplot(g_metabolic, vertex.color = V(g_metabolic)$color, main = \"Red Metabólica con Comunidades\")\n\n\n\n\n\n\n\n\nEn este ejemplo, las comunidades o módulos identificados por la modularidad pueden representar rutas metabólicas en las cuales los metabolitos y reacciones están funcionalmente conectados. Esto permite el análisis de las interacciones metabólicas y cómo se organizan en la red celular.\n\n\nInterpretación en Biología de Sistemas\nLa modularidad es particularmente relevante en biología de sistemas para modelar la organización funcional de las redes biológicas y su robustez. Las redes altamente modulares tienden a ser más robustas frente a perturbaciones, ya que los módulos actúan de manera relativamente independiente. Por ejemplo: - En redes de interacción genética, los módulos pueden representar genes que participan en rutas reguladoras específicas. - En redes de señalización celular, la modularidad permite identificar cascadas de señalización, lo que ayuda a comprender cómo las células responden a estímulos externos de manera organizada.\nLa modularidad, al permitir identificar estas estructuras funcionales dentro de la red, ayuda a los investigadores a proponer nuevas hipótesis sobre el funcionamiento de los sistemas biológicos y la evolución de su organización."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Aqui encuentrarás la material para la sección de James R. Perkins en Biología de Sistemas, Grado en Ingeniería de la Salud, Universidad de Málaga"
  },
  {
    "objectID": "coexp.html",
    "href": "coexp.html",
    "title": "Coexpression Analysis using WGCNA",
    "section": "",
    "text": "Weighted Gene Co-expression Network Analysis (WGCNA) is a powerful bioinformatics method used to describe the correlation patterns among genes across multiple samples. The method identifies gene modules, summarizes them using module eigengenes, and correlates these with external traits or phenotypes.\n\n\nGene co-expression networks are built by calculating pairwise correlations between gene expression profiles. To capture biological significance and robustness, WGCNA uses a soft-thresholding power to transform the correlation matrix into an adjacency matrix. This adjacency matrix \\(a_{ij}\\) represents the connection strength between genes \\(i\\) and \\(j\\), defined as:\n\\[\na_{ij} = |cor(x_i, x_j)|^\\beta\n\\]\nWhere: - \\(cor(x_i, x_j)\\) is the correlation between gene \\(i\\) and gene \\(j\\). - \\(\\beta\\) is the soft-thresholding power, chosen to approximate scale-free network topology.\n\n\n\nModules are groups of highly interconnected genes. They are identified using hierarchical clustering of the Topological Overlap Matrix (TOM), which measures the similarity of gene neighborhoods. The TOM is calculated as:\n\\[\nTOM_{ij} = \\frac{\\sum_k (a_{ik} \\cdot a_{jk}) + a_{ij}}{\\min(k_i, k_j) + 1 - a_{ij}}\n\\]\nWhere:\n\\(k_i, k_j\\) = The degree (sum of edge weights) of nodes \\(i\\) and \\(j\\), respectively.\nIntuitively, the numerator combines the shared neighbors and the direct connections between \\(i\\) and \\(j\\). The denominator normalizes this value based on the smaller degree of the two nodes (\\(min(k_ik_j)\\)), ensuring comparability across the network.\nTOM thus accounts for Shared Neighbors - Nodes that are not directly connected but share many neighbors will have a high TOM value. This captures indirect relationships, making TOM more robust to noise than simple pairwise correlations. It is also a weighted measure: TOM is based on weighted adjacency values, allowing it to reflect the strength of relationships rather than just their presence or absence.\n\n\n\nBy identifying gene modules and their relationships with traits, WGCNA facilitates the discovery of key drivers and functional insights in systems biology. This tutorial applies WGCNA to liver expression data from female mice, focusing on identifying gene modules related to body weight."
  },
  {
    "objectID": "coexp.html#the-basics-of-wgcna",
    "href": "coexp.html#the-basics-of-wgcna",
    "title": "Coexpression Analysis using WGCNA",
    "section": "",
    "text": "Gene co-expression networks are built by calculating pairwise correlations between gene expression profiles. To capture biological significance and robustness, WGCNA uses a soft-thresholding power to transform the correlation matrix into an adjacency matrix. This adjacency matrix \\(a_{ij}\\) represents the connection strength between genes \\(i\\) and \\(j\\), defined as:\n\\[\na_{ij} = |cor(x_i, x_j)|^\\beta\n\\]\nWhere: - \\(cor(x_i, x_j)\\) is the correlation between gene \\(i\\) and gene \\(j\\). - \\(\\beta\\) is the soft-thresholding power, chosen to approximate scale-free network topology."
  },
  {
    "objectID": "coexp.html#module-identification",
    "href": "coexp.html#module-identification",
    "title": "Coexpression Analysis using WGCNA",
    "section": "",
    "text": "Modules are groups of highly interconnected genes. They are identified using hierarchical clustering of the Topological Overlap Matrix (TOM), which measures the similarity of gene neighborhoods. The TOM is calculated as:\n\\[\nTOM_{ij} = \\frac{\\sum_k (a_{ik} \\cdot a_{jk}) + a_{ij}}{\\min(k_i, k_j) + 1 - a_{ij}}\n\\]\nWhere:\n\\(k_i, k_j\\) = The degree (sum of edge weights) of nodes \\(i\\) and \\(j\\), respectively.\nIntuitively, the numerator combines the shared neighbors and the direct connections between \\(i\\) and \\(j\\). The denominator normalizes this value based on the smaller degree of the two nodes (\\(min(k_ik_j)\\)), ensuring comparability across the network.\nTOM thus accounts for Shared Neighbors - Nodes that are not directly connected but share many neighbors will have a high TOM value. This captures indirect relationships, making TOM more robust to noise than simple pairwise correlations. It is also a weighted measure: TOM is based on weighted adjacency values, allowing it to reflect the strength of relationships rather than just their presence or absence."
  },
  {
    "objectID": "coexp.html#applications-in-systems-biology",
    "href": "coexp.html#applications-in-systems-biology",
    "title": "Coexpression Analysis using WGCNA",
    "section": "",
    "text": "By identifying gene modules and their relationships with traits, WGCNA facilitates the discovery of key drivers and functional insights in systems biology. This tutorial applies WGCNA to liver expression data from female mice, focusing on identifying gene modules related to body weight."
  },
  {
    "objectID": "coexp.html#quantifying-moduletrait-associations",
    "href": "coexp.html#quantifying-moduletrait-associations",
    "title": "Coexpression Analysis using WGCNA",
    "section": "Quantifying module–trait associations",
    "text": "Quantifying module–trait associations\nWe would like to identify modules that are significantly associated with the measured clinical traits. Since we already have a summary profile (eigengene) for each module, we simply correlate eigengenes with external traits and look for the most significant associations.\n\n# Define numbers of genes and samples\nnSamples &lt;- nrow(datExpr)\n# Calculate module eigen gene values for each module - \n# Effectively the average expression of all genes in the module accross samples\nMEs0 &lt;- moduleEigengenes(datExpr, moduleColors)$eigengenes\nMEs &lt;- orderMEs(MEs0)\n# Correlate the modules with the traits\nmoduleTraitCor &lt;- cor(MEs, datTraits, use = \"p\")\nmoduleTraitPvalue &lt;- corPvalueStudent(moduleTraitCor, nSamples)"
  },
  {
    "objectID": "coexp.html#plot-module-trait-correlations",
    "href": "coexp.html#plot-module-trait-correlations",
    "title": "Coexpression Analysis using WGCNA",
    "section": "Plot module-trait correlations",
    "text": "Plot module-trait correlations\nSince we have a moderately large number of modules and traits, a suitable graphical representation will help in reading the table. We color code each association by the correlation value:\n\n# This is to set parameters for plotting\npar(mar = c(6, 8.5, 3, 3))\n# Display the correlation values within a heatmap plot\nlabeledHeatmap(Matrix = moduleTraitCor,\n               xLabels = names(datTraits),\n               yLabels = names(MEs),\n               ySymbols = names(MEs),\n               colorLabels = FALSE,\n               colors = blueWhiteRed(50),\n               setStdMargins = FALSE,\n               cex.text = 0.5,\n               zlim = c(-1,1),\n               main = paste(\"Module-trait relationships\"))\n\n\n\n\n\n\n\n\nThe analysis identifies the several interesting module–trait associations. We will now focus on weight as the trait of interest. Note that for example the brown module represents a group of genes that is correlated with weight, abdominal and other fat levels."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "analisis_topo_2.html",
    "href": "analisis_topo_2.html",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "",
    "text": "Este tutorial es la segunda parte de un análisis detallado de redes aplicado a la biología. En el primer tutorial, exploramos propiedades básicas como el grado (degree), el coeficiente de clustering y algunas métricas de intermediación (betweenness). Estas propiedades nos brindan una comprensión inicial de cómo los nodos y las conexiones en una red contribuyen a su estructura y funcionalidad general.\nEn esta segunda parte, profundizaremos en métricas avanzadas que describen aspectos estructurales y dinámicos de redes biológicas complejas, como la modularidad, densidad de aristas (edge density), dispersión (sparsity), homofilia (homophily), asortatividad (assortativity), diámetro de la red (network diameter) y longitud promedio de los caminos (average path length). Con ejemplos prácticos en biología y fragmentos de código en R, este tutorial facilita la comprensión de cómo estas propiedades se pueden aplicar para analizar sistemas biológicos, como redes de proteínas y metabolitos, y su resiliencia ante cambios como mutaciones o intervenciones farmacológicas."
  },
  {
    "objectID": "analisis_topo_2.html#cómo-se-calcula-la-modularidad",
    "href": "analisis_topo_2.html#cómo-se-calcula-la-modularidad",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "¿Cómo se calcula la modularidad?",
    "text": "¿Cómo se calcula la modularidad?\nLa modularidad \\(Q\\) se calcula para evaluar si una red tiene una estructura modular significativa. La ecuación básica para la modularidad de una red es:\n\\[\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n\\]\nDonde:\n\n\\(Q\\) es el valor de modularidad.\n\\(m\\) es el número total de aristas en la red.\n\\(A\\_{ij}\\) representa la entrada en la posición \\((i, j)\\) de la matriz de adyacencia de la red, donde \\(A_{ij} = 1\\) si hay una arista entre los nodos \\(i\\) y \\(j\\), y \\(A_{ij} = 0\\) si no la hay.\n\\(k_i\\) es el grado del nodo \\(i\\) (es decir, el número de conexiones que tiene el nodo \\(i\\)).\n\\(\\delta(c_i, c_j)\\) es una función indicadora que es igual a 1 si los nodos \\(i\\) y \\(j\\) pertenecen a la misma comunidad y 0 en caso contrario.\n\nEsta ecuación compara la densidad de enlaces dentro de las comunidades con la densidad esperada de enlaces si las conexiones fueran aleatorias, es decir, si la red se hubiera generado de forma aleatoria manteniendo el mismo grado de cada nodo.\n\nPasos detallados para calcular la modularidad\n\nIdentificar la estructura de la comunidad: La red se divide en comunidades o módulos (grupos de nodos densamente conectados entre sí). Esto puede hacerse con algoritmos específicos como el algoritmo de Louvain o el algoritmo de agrupamiento fast-greedy, que buscan maximizar la modularidad \\(Q\\) dividiendo la red en comunidades. Veremos mas algoritmos de clusterizacion en la siguiente parte teorica.\nCalcular la matriz de adyacencia y el grado: A partir de la estructura de la red, construimos la matriz de adyacencia \\(A\\) y calculamos el grado de cada nodo \\(k_i\\).\nSumar las diferencias entre enlaces observados y esperados: Para cada par de nodos \\(i\\) y \\(j\\), se calcula \\(A_{ij} - \\frac{k_i k_j}{2m}\\). Este término controla por el grado de los nods \\(i\\) y \\(j\\).\nSumar los valores para los pares dentro de la misma comunidad: Los valores obtenidos en el paso anterior se suman únicamente para los pares de nodos \\((i, j)\\) que están dentro de la misma comunidad (esto lo controla la función \\(\\delta(c_i, c_j)\\)).\nNormalizar por el número total de enlaces: Finalmente, el resultado se multiplica por \\(\\frac{1}{2m}\\) para obtener el valor final de modularidad \\(Q\\).\n\nUn valor de \\(Q\\) alto indica una fuerte estructura modular, lo que significa que los nodos están agrupados en comunidades bien definidas. En cambio, un valor bajo o cercano a cero sugiere que los enlaces dentro y entre comunidades no difieren mucho de lo que se esperaría en una red aleatoria."
  },
  {
    "objectID": "analisis_topo_2.html#ejemplo-biológico-de-modularidad",
    "href": "analisis_topo_2.html#ejemplo-biológico-de-modularidad",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Ejemplo Biológico de Modularidad",
    "text": "Ejemplo Biológico de Modularidad\nEn redes de interacción proteína-proteína, la modularidad puede identificar comunidades que corresponden a complejos proteicos funcionales o a proteínas que participan en la misma ruta metabólica. Por ejemplo, en una red de proteínas involucradas en la respuesta inmune, los módulos de alta modularidad pueden corresponder a diferentes mecanismos inmunitarios, como la respuesta inflamatoria o la activación de células T."
  },
  {
    "objectID": "analisis_topo_2.html#código-en-r-para-calcular-modularidad",
    "href": "analisis_topo_2.html#código-en-r-para-calcular-modularidad",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Código en R para Calcular Modularidad",
    "text": "Código en R para Calcular Modularidad\nEl siguiente código en R utiliza igraph para calcular la modularidad en dos redes con diferentes estructuras:\nAquí tienes un ejemplo en R que crea dos redes: una con alta modularidad y otra con baja modularidad. Este código ilustra la diferencia de modularidad usando comunidades claramente definidas para la red modular, mientras que la red no modular tendrá conexiones distribuidas de manera más uniforme sin comunidades definidas.\n\n# Cargamos el paquete igraph\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# Creamos una red con alta modularidad utilizando la función sample_islands\n# Esta red tendrá 4 comunidades internas con enlaces densos entre nodos dentro de cada comunidad\nset.seed(42)\nhigh_modularity_network &lt;- sample_islands(4, 10, 0.8, 3)\n\n# Visualizamos la red de alta modularidad\nplot(high_modularity_network, main = \"Red con Alta Modularidad\", vertex.color = membership(cluster_louvain(high_modularity_network)), vertex.size = 8, edge.arrow.size = 0.5)\n\n\n\n\n\n\n\n# Calculamos y mostramos la modularidad de la red de alta modularidad\nhigh_modularity_value &lt;- modularity(cluster_louvain(high_modularity_network))\ncat(\"Modularidad de la red con alta modularidad:\", high_modularity_value, \"\\n\")\n\nModularidad de la red con alta modularidad: 0.6358356 \n\n# Creamos una red con baja modularidad usando una red aleatoria sin comunidades definidas\n# Usamos la función erdos.renyi.game para crear una red aleatoria\nlow_modularity_network &lt;- sample_gnp(40, p = 0.1, directed = FALSE)\n\n# Visualizamos la red de baja modularidad\nplot(low_modularity_network, main = \"Red con Baja Modularidad\", vertex.color = membership(cluster_louvain(low_modularity_network)), vertex.size = 8, edge.arrow.size = 0.5)\n\n\n\n\n\n\n\n# Calculamos y mostramos la modularidad de la red de baja modularidad\nlow_modularity_value &lt;- modularity(cluster_louvain(low_modularity_network))\ncat(\"Modularidad de la red con baja modularidad:\", low_modularity_value, \"\\n\")\n\nModularidad de la red con baja modularidad: 0.3727328 \n\n\n\nExplicación del código\n\nRed con alta modularidad:\n\nCreamos una red usando sample_islands que genera “islas” o grupos de nodos con conexiones internas densas y pocas conexiones entre grupos.\nEsto produce comunidades internas bien definidas, lo que incrementa el valor de la modularidad.\nLa función modularity mide este valor, y deberías obtener un valor de modularidad relativamente alto (cerca de 1, dependiendo de los parámetros de entrada).\n\nRed con baja modularidad:\n\nCreamos una red aleatoria con la función sample_gnp, en la cual los enlaces se distribuyen de manera uniforme y no hay comunidades claras.\nLa modularidad para esta red debería ser baja porque no hay agrupamiento natural en comunidades.\nVisualizamos y calculamos la modularidad, la cual debería ser un valor bajo (cercano a cero), indicando una red con baja modularidad.\n\n\n\n\nInterpretación de los Resultados\n\nLa red con alta modularidad tendrá nodos dentro de cada comunidad (en este caso, cuatro) con conexiones internas fuertes y escasas conexiones con nodos de otras comunidades. Esto resulta en una modularidad alta, ya que \\(A_{ij}\\) dentro de las comunidades es significativamente mayor al esperado.\nLa red con baja modularidad no tendrá comunidades bien definidas. Las conexiones están distribuidas aleatoriamente, por lo que la diferencia entre el número de enlaces reales y el número esperado será baja, dando como resultado una modularidad baja.\n\nEste ejemplo permite ver gráficamente y numéricamente cómo las diferentes configuraciones de enlaces afectan el valor de la modularidad."
  },
  {
    "objectID": "analisis_topo_2.html#densidad-de-aristas-edge-density",
    "href": "analisis_topo_2.html#densidad-de-aristas-edge-density",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Densidad de Aristas (Edge Density)",
    "text": "Densidad de Aristas (Edge Density)\nLa densidad en una red de señalización indica cuántas interacciones existen en relación con el total de interacciones posibles. En redes biológicas, particularmente en sistemas de señalización celular, la densidad puede influir en cómo se propagan las señales, en la redundancia de la información y en la posibilidad de regulaciones complejas.\n\nEjemplo en Redes de Señalización: Vía MAPK (Red Densa): La vía de señalización Mitogen-Activated Protein Kinase (MAPK) es un buen ejemplo de una red densa en el contexto de señalización celular. Esta vía está implicada en la respuesta celular a estímulos como factores de crecimiento, citoquinas y estrés, y se caracteriza por varias capas de interacciones en cascada de proteínas quinasa que activan múltiples proteínas aguas abajo. MAPK tiene una alta redundancia y una conectividad extensa, lo cual significa que si una conexión falla, hay rutas alternativas que permiten la continuidad de la señal. Esto permite una señalización robusta y adaptativa, con la capacidad de responder a múltiples estímulos simultáneamente.\n\nAlta Densidad: La red MAPK tiende a ser densa porque las proteínas dentro de esta vía pueden interactuar con múltiples blancos, y existen circuitos de retroalimentación que amplifican o modulan la señal. Esta interconectividad genera una red con muchas aristas en relación al número de nodos, lo que se refleja en un alto valor de densidad. Esta densidad permite a la vía responder de manera efectiva y rápida, esencial en procesos como la división celular, la diferenciación y la respuesta al estrés.\nLa densidad (\\(D\\)) se calcula de la siguiente manera:\n\\[\nD = \\frac{2m}{n(n-1)}\n\\]\nDonde: - \\(D\\) es la densidad, - \\(m\\) es el número de aristas presentes en la red, - \\(n\\) es el número de nodos."
  },
  {
    "objectID": "analisis_topo_2.html#dispersión-sparsity",
    "href": "analisis_topo_2.html#dispersión-sparsity",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Dispersión (Sparsity)",
    "text": "Dispersión (Sparsity)\nLa dispersión complementa a la densidad y ayuda a entender la organización de redes dispersas, comunes en sistemas de señalización que requieren alta especificidad. La dispersión se calcula como:\n\\[\n\\text{Dispersión} = 1 - D\n\\]\ndonde \\(D\\) es la densidad de aristas. Una red con alta dispersión indica una arquitectura que favorece interacciones específicas y minimiza la redundancia, lo cual es común en redes de señalización de cascadas enzimáticas donde la señal sigue una ruta secuencial, evitando activaciones erróneas.\n\nEjemplo en Rutas de Señalización:\n\nVía TGF-beta (Red Dispersa): En contraste al MAPK, la vía de Transforming Growth Factor-beta (TGF-beta) representa una red de señalización más lineal y específica. TGF-beta inicia la señalización mediante la activación de complejos de receptores y la fosforilación de proteínas SMAD, las cuales se translocan al núcleo para regular la transcripción génica. Debido a que esta señalización se desarrolla en un camino relativamente directo, la vía TGF-beta suele tener menos conexiones redundantes entre sus componentes en comparación con MAPK, lo cual resulta en una red con menor densidad.\nBaja Densidad (Alta Dispersión): La menor cantidad de interacciones entre nodos en la vía TGF-beta se traduce en una baja densidad de aristas y mayor dispersión. Esto es adecuado para su función de iniciar cambios genéticos específicos sin desencadenar múltiples respuestas o activar rutas cruzadas extensas, permitiendo un control más preciso y limitado. Aunque TGF-beta también puede interactuar con otras vías de señalización, su arquitectura básica suele mostrar menos interconexión y redundancia que MAPK."
  },
  {
    "objectID": "analisis_topo_2.html#cálculo-de-densidad-y-dispersión-en-r",
    "href": "analisis_topo_2.html#cálculo-de-densidad-y-dispersión-en-r",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Cálculo de Densidad y Dispersión en R",
    "text": "Cálculo de Densidad y Dispersión en R\nUsaremos código en R para ilustrar cómo estas métricas se aplican a redes con diferentes densidades.\n\n# Cargamos la librería igraph\nlibrary(igraph)\n\n# Creamos una red dispersa para representar una señalización específica y especializada\nsparse_network &lt;- sample_gnp(30, p = 0.1, directed = FALSE)\n\n# Creamos una red densa para representar un sistema de señalización redundante\ndense_network &lt;- sample_gnp(30, p = 0.5, directed = FALSE)\n\n# Calculamos la densidad de cada red\nsparse_density &lt;- edge_density(sparse_network)\ndense_density &lt;- edge_density(dense_network)\n\n# Calculamos la dispersión\nsparse_sparsity &lt;- 1 - sparse_density\ndense_sparsity &lt;- 1 - dense_density\n\n# Imprimimos los resultados\ncat(\"Densidad de la red dispersa (especialización):\", sparse_density, \"\\n\")\n\nDensidad de la red dispersa (especialización): 0.09885057 \n\ncat(\"Densidad de la red densa (redundancia):\", dense_density, \"\\n\")\n\nDensidad de la red densa (redundancia): 0.4735632 \n\ncat(\"Dispersión de la red dispersa:\", sparse_sparsity, \"\\n\")\n\nDispersión de la red dispersa: 0.9011494 \n\ncat(\"Dispersión de la red densa:\", dense_sparsity, \"\\n\")\n\nDispersión de la red densa: 0.5264368 \n\n# Visualizamos las redes\nplot(sparse_network, main = \"Red Dispersa (Señalización Especializada)\", vertex.size = 8, vertex.label = NA)\n\n\n\n\n\n\n\nplot(dense_network, main = \"Red Densa (Señalización Redundante)\", vertex.size = 8, vertex.label = NA)\n\n\n\n\n\n\n\n\n\nInterpretación del Código\n\nRed Dispersa: Representa un sistema de señalización específico, como la señalización de TGF-beta, donde cada proteína interactúa con un número limitado de proteínas. Esto es ideal para asegurar que la señalización siga una ruta secuencial y específica.\nRed Densa: Modela un sistema de señalización con redundancia, como la vía MAPK. En este sistema, existen múltiples rutas alternativas para la propagación de la señal, aumentando la robustez del sistema y asegurando que la célula pueda responder adecuadamente a estímulos críticos."
  },
  {
    "objectID": "analisis_topo_2.html#aplicaciones-de-densidad-y-dispersión",
    "href": "analisis_topo_2.html#aplicaciones-de-densidad-y-dispersión",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Aplicaciones de Densidad y Dispersión",
    "text": "Aplicaciones de Densidad y Dispersión\n\nRedes de Señalización Celular Complejas: En sistemas como la señalización en células inmunitarias, la densidad puede variar significativamente. Una densidad alta puede ser ventajosa para asegurar respuestas rápidas y fuertes, como en la activación de linfocitos T en respuesta a una infección. Sin embargo, la dispersión alta también puede ser útil para redes que necesitan especificidad y precisión, como en la regulación de citocinas, donde una señalización muy dispersa evita que células no implicadas respondan erróneamente.\nOptimización de Fármacos Basada en la Estructura de la Red: Las redes densas pueden ofrecer múltiples puntos de intervención farmacológica debido a su redundancia, pero también presentan el desafío de efectos secundarios no deseados. En contraste, redes dispersas ofrecen objetivos específicos, aunque los efectos de los fármacos pueden depender de la precisión con la que se interrumpe una señal en particular."
  },
  {
    "objectID": "analisis_topo_2.html#entendiendo-la-longitud-promedio-de-camino",
    "href": "analisis_topo_2.html#entendiendo-la-longitud-promedio-de-camino",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Entendiendo la Longitud Promedio de Camino",
    "text": "Entendiendo la Longitud Promedio de Camino\nLa longitud promedio de camino en una red se define como el número promedio de pasos a lo largo de los caminos más cortos para todos los pares de nodos en la red. Es una medida importante de la propiedad de “pequeño mundo” de una red. En redes biológicas, las longitudes promedio de camino cortas suelen indicar una red altamente conectada y eficiente, mientras que las longitudes largas pueden sugerir redes más modulares o segregadas.\nMatemáticamente, la longitud promedio de camino \\(L_{avg}\\) para un grafo no dirigido se calcula como:\n\\[\nL_{avg} = \\frac{1}{N(N-1)} \\sum_{i \\neq j} d(i,j)\n\\]\ndonde \\(d(i,j)\\) es el camino más corto entre los nodos \\(i\\) y \\(j\\), y \\(N\\) es el número total de nodos en la red."
  },
  {
    "objectID": "analisis_topo_2.html#redes-con-longitudes-promedio-de-camino-cortas-redes-de-pequeño-mundo",
    "href": "analisis_topo_2.html#redes-con-longitudes-promedio-de-camino-cortas-redes-de-pequeño-mundo",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Redes con Longitudes Promedio de Camino Cortas (Redes de Pequeño Mundo)",
    "text": "Redes con Longitudes Promedio de Camino Cortas (Redes de Pequeño Mundo)\nLas redes de pequeño mundo tienen la característica de una longitud promedio de camino corta, lo que significa que, a pesar del tamaño de la red, cualquier par de nodos puede ser alcanzado en solo unos pocos pasos. Estas redes son comunes en sistemas biológicos y redes sociales, donde los nodos están altamente interconectados.\n\nEjemplo: Redes de Interacción Proteína-Proteína (PPI)\nEn las redes de interacción proteína-proteína (PPI), las proteínas son los nodos y las interacciones entre ellas son los bordes. La longitud promedio de camino en una red PPI bien conectada puede ser bastante corta, lo que refleja el alto grado de interconexión entre proteínas en procesos biológicos clave.\nEjemplo de Código en R: Aquí tienes un fragmento de código en R que genera una red de pequeño mundo y calcula la longitud promedio de camino.\n\n# Cargar las bibliotecas necesarias\nlibrary(igraph)\n\n# Crear una red de pequeño mundo\nsmall_world_net &lt;- sample_pa(100, m=2)  # Adquisición preferencial, genera propiedades de pequeño mundo\nplot(small_world_net)\n\n\n\n\n\n\n\n# Calcular la longitud promedio de camino\naverage_path_length &lt;- mean_distance(small_world_net)\naverage_path_length\n\n[1] 1.842884\n\n\n\n\nEjemplo: Redes de Regulación Génica\nEn las redes de regulación génica, donde los genes son los nodos y las interacciones regulatorias entre ellos son los bordes, una longitud promedio de camino corta puede indicar que los genes se están regulando de manera eficiente entre sí, a menudo debido a factores de transcripción compartidos o mecanismos co-regulatorios.\n\n\nEjemplo Fuera de la Biología: Redes Sociales\nEn las redes sociales, donde las personas son los nodos y las interacciones sociales son los bordes, las longitudes promedio de camino son a menudo cortas. Por ejemplo, en el famoso experimento de “seis grados de separación”, se descubrió que las personas están generalmente conectadas por un promedio de solo 6 grados de separación."
  },
  {
    "objectID": "analisis_topo_2.html#redes-con-longitudes-promedio-de-camino-largas-redes-modulares",
    "href": "analisis_topo_2.html#redes-con-longitudes-promedio-de-camino-largas-redes-modulares",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Redes con Longitudes Promedio de Camino Largas (Redes Modulares)",
    "text": "Redes con Longitudes Promedio de Camino Largas (Redes Modulares)\nPor otro lado, las redes con longitudes promedio de camino largas suelen exhibir una estructura modular o jerárquica, donde los clústeres de nodos altamente conectados (módulos) solo están débilmente conectados entre sí. Estas redes suelen ser menos eficientes en cuanto a la transferencia de información.\n\nEjemplo Biológico 1: Redes Cerebrales\nEn las redes cerebrales, donde las regiones del cerebro son los nodos y las conexiones funcionales o anatómicas entre ellas son los bordes, la red podria hipotéticamente tener una longitud promedio de camino más larga. La estructura modular del cerebro, con regiones distintas para funciones cognitivas diferentes, contribuye a una mayor longitud de camino entre regiones distantes.\nEjemplo de Código en R: Aquí tienes un ejemplo de cómo generar una red modular y calcular su longitud promedio de camino.\n\n# Generar una red modular (utilizando el modelo de Watts-Strogatz para redes de pequeño mundo)\nmodular_net &lt;- sample_smallworld(1, 100, 4, 0.07)  # Probabilidad de reconfiguración baja\nplot(modular_net)\n\n\n\n\n\n\n\n# Calcular la longitud promedio de camino\naverage_path_length_modular &lt;- mean_distance(modular_net)\naverage_path_length_modular\n\n[1] 2.863232\n\n\n\n\nEjemplo Biológico 2: Redes Ecológicas\nEn las redes ecológicas (como las redes tróficas), donde las especies son los nodos y las relaciones de alimentación son los bordes, la red suele tener una longitud promedio de camino más larga. Las especies a menudo se agrupan en grupos funcionales, y las interacciones dentro de estos grupos son mucho más frecuentes que las interacciones entre grupos.\n\n\nEjemplo Fuera de la Biología: Red de Internet\nEn la topología física de Internet, donde los routers y servidores son los nodos, la red puede exhibir una longitud promedio de camino más larga. A pesar de la vasta cantidad de conexiones, la red suele estar organizada de manera modular, donde diferentes regiones o subredes están más conectadas entre sí, lo que lleva a caminos más largos entre nodos distantes.\nLa longitud promedio de camino es una característica fundamental de las redes que puede revelar propiedades estructurales importantes. Las longitudes promedio de camino cortas sugieren un sistema eficiente y conectado, mientras que las largas indican una estructura más modular o jerárquica. Comprender cómo funciona la longitud promedio de camino en redes biológicas y no biológicas puede proporcionar valiosos conocimientos sobre su dinámica, conectividad y robustez."
  },
  {
    "objectID": "analisis_topo_2.html#diámetro-diameter",
    "href": "analisis_topo_2.html#diámetro-diameter",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Diámetro (Diameter)",
    "text": "Diámetro (Diameter)\nEl diámetro de una red es la longitud del camino más corto entre nodos mas largo entre cualquier par de nodos en la red. Es decir, el diámetro es el valor máximo de las distancias más cortas \\(d(i,j)\\) entre nodos \\(i\\) y \\(j\\). Esta medida es importante porque da una idea de cuán “extendida” o “compacta” es la red en términos de conectividad.\nEl diámetro \\(D\\) de una red se calcula como:\n\\[\nD = \\max_{i \\neq j} d(i,j)\n\\]\ndonde \\(d(i,j)\\) es la distancia más corta entre los nodos \\(i\\) y \\(j\\).\n\nRelación entre Longitud Promedio de Camino y Diámetro\n\nRedes con Longitud Promedio de Camino Corta (Pequeño Mundo): En redes de pequeño mundo, el diámetro suele ser relativamente pequeño debido a la alta conectividad, lo que permite que cualquier par de nodos esté cerca el uno del otro.\nRedes con Longitud Promedio de Camino Larga (Modulares): En redes modulares, el diámetro suele ser más largo, ya que los nodos dentro de un módulo están bien conectados, pero los módulos en sí mismos tienen una menor conectividad, lo que aumenta la distancia entre nodos de diferentes módulos.\n\n\n\nCálculo del Diámetro en Redes de R\nAquí te muestro cómo calcular el diámetro de la red utilizando R, tanto para redes de pequeño mundo como para redes modulares.\n\nlibrary(igraph)\n\n# Generar una red de pequeño mundo (preferential attachment) con 100 nodos y 2 conexiones por nodo\nsmall_world_net &lt;- sample_pa(100, m = 2)\n\n# Calcular el diámetro de la red de pequeño mundo\ndiameter_small_world &lt;- diameter(small_world_net)\ncat(\"Diámetro de la red de pequeño mundo: \", diameter_small_world, \"\\n\")\n\nDiámetro de la red de pequeño mundo:  5 \n\n# Generar una red modular (modelo de Watts-Strogatz) con 100 nodos, 4 vecinos por nodo, y probabilidad de reconexión baja (0.01)\nmodular_net &lt;- sample_smallworld(1, 100, 4, 0.01)\n\n# Calcular el diámetro de la red modular\ndiameter_modular &lt;- diameter(modular_net)\ncat(\"Diámetro de la red modular: \", diameter_modular, \"\\n\")\n\nDiámetro de la red modular:  8 \n\n# Graficar ambas redes\nplot(small_world_net, main = paste(\"Red de Pequeño Mundo\\nDiámetro: \", diameter_small_world), vertex.size = 5, vertex.label = NA)\n\n\n\n\n\n\n\nplot(modular_net, main = paste(\"Red Modular\\nDiámetro: \", diameter_modular), vertex.size = 5, vertex.label = NA)\n\n\n\n\n\n\n\n\n\n\nRelación entre Diámetro y Propiedades de Red\n\nRedes de Pequeño Mundo: Las redes de pequeño mundo tienen un diámetro bajo, lo que significa que las distancias más largas entre los nodos son pequeñas, lo que las hace más eficientes en términos de conectividad.\nRedes Modulares: Las redes modulares tienen un diámetro mayor porque los módulos son menos interdependientes, lo que genera distancias más largas entre nodos de diferentes módulos."
  },
  {
    "objectID": "analisis_topo_2.html#ejemplos-de-redes-con-asortatividad-positiva-y-negativa",
    "href": "analisis_topo_2.html#ejemplos-de-redes-con-asortatividad-positiva-y-negativa",
    "title": "Análisis de Grafos y Topología de Redes (II): Modularidad, Densidad, Longitudes Promedio de Camino, Assortividad",
    "section": "Ejemplos de Redes con Asortatividad Positiva y Negativa",
    "text": "Ejemplos de Redes con Asortatividad Positiva y Negativa\n\nAsortatividad Positiva\nEn redes con asortatividad positiva, los nodos con grados similares tienden a conectarse entre sí. Este patrón fomenta la formación de comunidades o módulos, lo que refuerza la resiliencia y la cohesión de la red.\n\nRedes de Interacción Proteína-Proteína (PPI):\nLas proteínas de alto grado (hubs) tienden a interactuar con otras proteínas igualmente conectadas, formando complejos funcionales específicos. Por ejemplo, en la maquinaria ribosomal, las proteínas ribosómicas suelen agruparse para garantizar una síntesis proteica eficiente.\nRedes Sociales:\nEn redes como LinkedIn, las personas con muchas conexiones suelen estar vinculadas a otros usuarios con un número similar de contactos, lo que genera grupos profesionales densamente interconectados.\n\n\n\nAsortatividad Negativa\nEn redes con asortatividad negativa, los nodos de alto grado tienden a conectarse con nodos de bajo grado. Este patrón es típico de sistemas diseñados para maximizar la eficiencia y la transferencia de recursos o información.\n\nRedes Metabólicas:\nLos metabolitos universales, como el ATP, actúan como hubs al conectar múltiples metabolitos específicos con roles clave en diversas rutas metabólicas. Este diseño asegura que el ATP pueda participar rápidamente en numerosas reacciones bioquímicas.\nRedes de Transporte:\nEn redes aéreas, los aeropuertos internacionales (hubs) están conectados con aeropuertos regionales más pequeños. Esto optimiza el flujo de pasajeros y carga en el sistema global.\n\n\n\nComparación en Biología\n\nLa asortatividad positiva refuerza la estabilidad dentro de módulos funcionales, como complejos proteicos específicos.\n\nLa asortatividad negativa mejora la flexibilidad y la integración en sistemas jerárquicos, como en la regulación metabólica o genética.\n\nAmbos patrones reflejan estrategias de diseño adaptativas que optimizan la funcionalidad en redes biológicas y tecnológicas."
  },
  {
    "objectID": "clustering.html",
    "href": "clustering.html",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "",
    "text": "El análisis de redes es una herramienta fundamental en biología de sistemas, ya que permite modelar y analizar interacciones biológicas complejas, como las redes de interacción proteína-proteína (PPI, por sus siglas en inglés), redes metabólicas, redes de regulación génica y redes de co-expresión génica. Dentro de estas redes, los módulos o comunidades representan grupos de nodos altamente interconectados que frecuentemente comparten funciones biológicas comunes o están involucrados en procesos similares.\nPor ejemplo:\n\nEn redes metabólicas, los módulos pueden corresponder a rutas metabólicas específicas.\n\n\n\n\npublic.ornl.gov\n\n\n\nEn redes de co-expresión génica, se han identificado clústeres de genes que co-regulan procesos biológicos importantes, como el ciclo celular o la respuesta al estrés.\n\n\n\n\nrna-seqblog.com\n\n\n\nEn redes PPI, los módulos pueden representar complejos proteicos funcionales o vías de señalización crítica.\n\n\n\n\nLabusek et al., 2023\n\n\nDada la naturaleza jerárquica y modular de los sistemas biológicos, los métodos de clustering en redes permiten no solo identificar estas unidades funcionales, sino también generar hipótesis sobre la organización y evolución de los sistemas biológicos.\n\n\n\n\nLa modularidad es un principio clave en biología de sistemas, pues permite que los componentes de una red biológica interactúen de manera eficiente en subunidades funcionales. Estas subunidades (o módulos) están involucradas en procesos específicos, como la síntesis de proteínas, las rutas metabólicas y la señalización celular.\n\nEn rutas metabólicas:\n\nLos módulos en redes metabólicas representan rutas bioquímicas específicas, donde cada módulo agrupa metabolitos y enzimas que trabajan de manera coordinada.\n\nEjemplo: Estudios han utilizado análisis de modularidad para optimizar la ingeniería metabólica en bacterias como E. coli, dividiendo su red metabólica en módulos para maximizar la producción de biocombustibles (Nielsen & Keasling, 2016).\n\nEn redes de interacción proteína-proteína (PPI):\n\nLas redes PPI son altamente modulares, con módulos que representan complejos proteicos funcionales o grupos de proteínas involucradas en procesos biológicos comunes.\n\nEjemplo: En un análisis de redes de proteínas relacionadas con el cáncer, se identificaron módulos asociados a procesos específicos como la apoptosis y la reparación del ADN. Este enfoque permite priorizar biomarcadores terapéuticos dentro de módulos funcionales.\n\nAdemás, la identificación de módulos en redes virales (como las interacciones entre proteínas del SARS-CoV-2 y del huésped humano) ha revelado objetivos terapéuticos potenciales (Gordon et al., 2020).\n\nEn redes de regulación génica:\n\nLos módulos en redes génicas reflejan conjuntos de genes co-regulados que participan en procesos celulares específicos.\n\nEjemplo: El uso de herramientas como ATAC-seq para analizar redes reguladoras ha permitido identificar módulos específicos activados durante la diferenciación celular (Buenrostro et al., 2018).\n\n\n\n\n\nLa jerarquía en la organización celular es un principio fundamental en la biología que refleja cómo los sistemas biológicos están estructurados en niveles organizativos, desde moléculas hasta células, tejidos, órganos y organismos. Este concepto es crucial para entender redes biológicas y para desarrollar métodos efectivos de clustering, ya que estas redes suelen mostrar propiedades jerárquicas y modulares que reflejan esta organización.\n\n\n\nDefinición: La jerarquía en la biología describe cómo las entidades en un nivel más bajo de organización (p. ej., moléculas) se ensamblan para formar estructuras más complejas (p. ej., organelos, células).\nRelación con redes biológicas: Las redes biológicas, como las de interacción proteína-proteína (PPI, Protein-Protein Interaction), regulan esta organización jerárquica al conectar moléculas que trabajan juntas para realizar funciones específicas.\n\n\n\n\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nLas proteínas que forman parte de un complejo proteico específico suelen estar más conectadas entre sí que con otras proteínas en la red. Por ejemplo, las proteínas ribosomales interactúan predominantemente dentro del ribosoma, formando un módulo altamente cohesivo.\nA nivel jerárquico, los módulos del ribosoma pueden estar conectados con otros módulos relacionados con la síntesis de proteínas.\n\nRedes Metabólicas:\n\nLos metabolitos dentro de una vía metabólica específica (p. ej., glucólisis) están más interconectados entre sí que con metabolitos en otras vías.\nA mayor escala, estas vías metabólicas se agrupan en categorías funcionales más amplias, como el metabolismo energético.\n\nRedes de Señalización:\n\nLas moléculas señalizadoras (como kinases y fosfatasas) tienden a formar módulos relacionados con procesos específicos (p. ej., reparación del ADN o respuesta inmune).\nEstos módulos pueden interactuar en un nivel superior, integrando señales entre distintas rutas de señalización.\n\n\n\n\n\n\nLos algoritmos de clustering jerárquicos (como Edge Betweenness y Fast Greedy) reflejan directamente esta organización jerárquica, ya que identifican subconjuntos dentro de la red a diferentes niveles de resolución.\nPor ejemplo, se pueden identificar módulos más pequeños que representan complejos proteicos individuales y módulos más grandes que conectan complejos relacionados funcionalmente.\n\nDiferenciación entre Escalas: - La jerarquía permite estudiar redes biológicas en múltiples escalas, desde interacciones moleculares específicas hasta sistemas multicelulares completos.\n\nRedes de regulación genética:\n\nLos genes regulados por un mismo factor de transcripción forman módulos cohesivos. A su vez, estos factores se agrupan en niveles superiores de regulación, reflejando una jerarquía en el control de la expresión génica.\n\n\n\n\n\n\n\nEficiencia en la maquinaria celular:\n\nLos módulos permiten realizar tareas específicas de manera eficiente y sin interferencias.\n\nRobustez frente a fallos:\n\nLa jerarquía y modularidad permiten que la red siga funcionando incluso si ciertos nodos fallan.\n\nAdaptabilidad evolutiva:\n\nLos módulos pueden evolucionar independientemente, permitiendo la especialización.\n\n\nEl clustering de redes ha sido utilizado para:\n\nFunción génica y predicción de enfermedades: Los genes asociados a un mismo módulo suelen estar implicados en funciones similares, lo que facilita la anotación funcional de genes no caracterizados.\nDescubrimiento de biomarcadores: En estudios de transcriptómica y proteómica, los módulos identificados pueden revelar biomarcadores asociados a enfermedades o estados fisiológicos específicos .\nModelado de la robustez y vulnerabilidad del sistema: La estructura modular ayuda a entender cómo los sistemas biológicos mantienen su funcionalidad frente a perturbaciones, ya sea mediante redundancia o interacción entre módulos.\nEvolución de las redes biológicas: El análisis de los módulos permite estudiar cómo han evolucionado las interacciones entre genes y proteínas en diferentes especies.\n\n\n\n\n\nA lo largo de este tutorial, se abordarán cinco métodos principales de clustering, cada uno con características únicas:\n\nEdge Betweenness (Intermediación de Aristas):\n\nIdentifica comunidades al eliminar iterativamente las aristas con mayor intermediación.\n\nEs particularmente útil para redes pequeñas y permite una visualización clara del proceso de partición. Sin embargo, su complejidad lo hace ineficiente para redes grandes.\n\nWalktrap (Caminatas Aleatorias):\n\nUtiliza caminatas aleatorias para detectar comunidades, basándose en la idea de que nodos dentro de una misma comunidad están más “cercanos” en términos probabilísticos.\n\nIdeal para redes medianas con módulos densos y conexos.\n\nFast Greedy (Greedy Maximization of Modularity):\n\nUn método jerárquico que agrupa nodos de manera iterativa para maximizar la modularidad global.\n\nEs eficiente y adecuado para redes grandes, aunque su resolución puede ser limitada en algunos casos.\n\nInfomap:\n\nSe basa en la teoría de la codificación de información para dividir la red en módulos, minimizando la descripción de un caminante aleatorio.\n\nEs particularmente efectivo en redes con muchas comunidades pequeñas.\n\nLabel Propagation:\n\nUn método rápido y escalable que utiliza la propagación iterativa de etiquetas para asignar nodos a comunidades.\n\nSu simplicidad lo hace adecuado para redes extremadamente grandes, aunque puede generar resultados variables.\n\n\nCada método será descrito en detalle, con explicaciones teóricas, ventajas, desventajas, y ejemplos ilustrativos. Además, se destacarán las mejores prácticas para aplicar estos métodos en el contexto de biología de sistemas y otras áreas.\n\n\nLabusek N, Mouloud Y, Köster C, Diesterbeck E, Tertel T, Wiek C, Hanenberg H, Horn PA, Felderhoff-Müser U, Bendix I, Giebel B, Herz J. Extracellular vesicles from immortalized mesenchymal stromal cells protect against neonatal hypoxic-ischemic brain injury. Inflamm Regen. 2023 Apr 17;43(1):24. doi: 10.1186/s41232-023-00274-6. PMID: 37069694; PMCID: PMC10108458.\nNielsen J, Keasling JD. Engineering Cellular Metabolism. Cell. 2016 Mar 10;164(6):1185-1197. doi: 10.1016/j.cell.2016.02.004. PMID: 26967285.\nGordon DE, Jang GM, Bouhaddou M, Xu J, Obernier K, White KM, O’Meara MJ, Rezelj VV, Guo JZ, Swaney DL, Tummino TA, Hüttenhain R, Kaake RM, Richards AL, Tutuncuoglu B, Foussard H, Batra J, Haas K, Modak M, Kim M, Haas P, Polacco BJ, Braberg H, Fabius JM, Eckhardt M, Soucheray M, Bennett MJ, Cakir M, McGregor MJ, Li Q, Meyer B, Roesch F, Vallet T, Mac Kain A, Miorin L, Moreno E, Naing ZZC, Zhou Y, Peng S, Shi Y, Zhang Z, Shen W, Kirby IT, Melnyk JE, Chorba JS, Lou K, Dai SA, Barrio-Hernandez I, Memon D, Hernandez-Armenta C, Lyu J, Mathy CJP, Perica T, Pilla KB, Ganesan SJ, Saltzberg DJ, Rakesh R, Liu X, Rosenthal SB, Calviello L, Venkataramanan S, Liboy-Lugo J, Lin Y, Huang XP, Liu Y, Wankowicz SA, Bohn M, Safari M, Ugur FS, Koh C, Savar NS, Tran QD, Shengjuler D, Fletcher SJ, O’Neal MC, Cai Y, Chang JCJ, Broadhurst DJ, Klippsten S, Sharp PP, Wenzell NA, Kuzuoglu-Ozturk D, Wang HY, Trenker R, Young JM, Cavero DA, Hiatt J, Roth TL, Rathore U, Subramanian A, Noack J, Hubert M, Stroud RM, Frankel AD, Rosenberg OS, Verba KA, Agard DA, Ott M, Emerman M, Jura N, von Zastrow M, Verdin E, Ashworth A, Schwartz O, d’Enfert C, Mukherjee S, Jacobson M, Malik HS, Fujimori DG, Ideker T, Craik CS, Floor SN, Fraser JS, Gross JD, Sali A, Roth BL, Ruggero D, Taunton J, Kortemme T, Beltrao P, Vignuzzi M, García-Sastre A, Shokat KM, Shoichet BK, Krogan NJ. A SARS-CoV-2 protein interaction map reveals targets for drug repurposing. Nature. 2020 Jul;583(7816):459-468. doi: 10.1038/s41586-020-2286-9. Epub 2020 Apr 30. PMID: 32353859; PMCID: PMC7431030.\nBuenrostro JD, Corces MR, Lareau CA, Wu B, Schep AN, Aryee MJ, Majeti R, Chang HY, Greenleaf WJ. Integrated Single-Cell Analysis Maps the Continuous Regulatory Landscape of Human Hematopoietic Differentiation. Cell. 2018 May 31;173(6):1535-1548.e16. doi: 10.1016/j.cell.2018.03.074. Epub 2018 Apr 26. PMID: 29706549; PMCID: PMC5989727.\nSaxton RA, Sabatini DM. mTOR Signaling in Growth, Metabolism, and Disease. Cell. 2017 Mar 9;168(6):960-976. doi: 10.1016/j.cell.2017.02.004. Erratum in: Cell. 2017 Apr 6;169(2):361-371. doi: 10.1016/j.cell.2017.03.035. PMID: 28283069; PMCID: PMC5394987."
  },
  {
    "objectID": "clustering.html#naturaleza-jerárquica-y-modular-de-los-sistemas-biológicos",
    "href": "clustering.html#naturaleza-jerárquica-y-modular-de-los-sistemas-biológicos",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "",
    "text": "La modularidad es un principio clave en biología de sistemas, pues permite que los componentes de una red biológica interactúen de manera eficiente en subunidades funcionales. Estas subunidades (o módulos) están involucradas en procesos específicos, como la síntesis de proteínas, las rutas metabólicas y la señalización celular.\n\nEn rutas metabólicas:\n\nLos módulos en redes metabólicas representan rutas bioquímicas específicas, donde cada módulo agrupa metabolitos y enzimas que trabajan de manera coordinada.\n\nEjemplo: Estudios han utilizado análisis de modularidad para optimizar la ingeniería metabólica en bacterias como E. coli, dividiendo su red metabólica en módulos para maximizar la producción de biocombustibles (Nielsen & Keasling, 2016).\n\nEn redes de interacción proteína-proteína (PPI):\n\nLas redes PPI son altamente modulares, con módulos que representan complejos proteicos funcionales o grupos de proteínas involucradas en procesos biológicos comunes.\n\nEjemplo: En un análisis de redes de proteínas relacionadas con el cáncer, se identificaron módulos asociados a procesos específicos como la apoptosis y la reparación del ADN. Este enfoque permite priorizar biomarcadores terapéuticos dentro de módulos funcionales.\n\nAdemás, la identificación de módulos en redes virales (como las interacciones entre proteínas del SARS-CoV-2 y del huésped humano) ha revelado objetivos terapéuticos potenciales (Gordon et al., 2020).\n\nEn redes de regulación génica:\n\nLos módulos en redes génicas reflejan conjuntos de genes co-regulados que participan en procesos celulares específicos.\n\nEjemplo: El uso de herramientas como ATAC-seq para analizar redes reguladoras ha permitido identificar módulos específicos activados durante la diferenciación celular (Buenrostro et al., 2018).\n\n\n\n\n\nLa jerarquía en la organización celular es un principio fundamental en la biología que refleja cómo los sistemas biológicos están estructurados en niveles organizativos, desde moléculas hasta células, tejidos, órganos y organismos. Este concepto es crucial para entender redes biológicas y para desarrollar métodos efectivos de clustering, ya que estas redes suelen mostrar propiedades jerárquicas y modulares que reflejan esta organización.\n\n\n\nDefinición: La jerarquía en la biología describe cómo las entidades en un nivel más bajo de organización (p. ej., moléculas) se ensamblan para formar estructuras más complejas (p. ej., organelos, células).\nRelación con redes biológicas: Las redes biológicas, como las de interacción proteína-proteína (PPI, Protein-Protein Interaction), regulan esta organización jerárquica al conectar moléculas que trabajan juntas para realizar funciones específicas.\n\n\n\n\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nLas proteínas que forman parte de un complejo proteico específico suelen estar más conectadas entre sí que con otras proteínas en la red. Por ejemplo, las proteínas ribosomales interactúan predominantemente dentro del ribosoma, formando un módulo altamente cohesivo.\nA nivel jerárquico, los módulos del ribosoma pueden estar conectados con otros módulos relacionados con la síntesis de proteínas.\n\nRedes Metabólicas:\n\nLos metabolitos dentro de una vía metabólica específica (p. ej., glucólisis) están más interconectados entre sí que con metabolitos en otras vías.\nA mayor escala, estas vías metabólicas se agrupan en categorías funcionales más amplias, como el metabolismo energético.\n\nRedes de Señalización:\n\nLas moléculas señalizadoras (como kinases y fosfatasas) tienden a formar módulos relacionados con procesos específicos (p. ej., reparación del ADN o respuesta inmune).\nEstos módulos pueden interactuar en un nivel superior, integrando señales entre distintas rutas de señalización.\n\n\n\n\n\n\nLos algoritmos de clustering jerárquicos (como Edge Betweenness y Fast Greedy) reflejan directamente esta organización jerárquica, ya que identifican subconjuntos dentro de la red a diferentes niveles de resolución.\nPor ejemplo, se pueden identificar módulos más pequeños que representan complejos proteicos individuales y módulos más grandes que conectan complejos relacionados funcionalmente.\n\nDiferenciación entre Escalas: - La jerarquía permite estudiar redes biológicas en múltiples escalas, desde interacciones moleculares específicas hasta sistemas multicelulares completos.\n\nRedes de regulación genética:\n\nLos genes regulados por un mismo factor de transcripción forman módulos cohesivos. A su vez, estos factores se agrupan en niveles superiores de regulación, reflejando una jerarquía en el control de la expresión génica.\n\n\n\n\n\n\n\nEficiencia en la maquinaria celular:\n\nLos módulos permiten realizar tareas específicas de manera eficiente y sin interferencias.\n\nRobustez frente a fallos:\n\nLa jerarquía y modularidad permiten que la red siga funcionando incluso si ciertos nodos fallan.\n\nAdaptabilidad evolutiva:\n\nLos módulos pueden evolucionar independientemente, permitiendo la especialización.\n\n\nEl clustering de redes ha sido utilizado para:\n\nFunción génica y predicción de enfermedades: Los genes asociados a un mismo módulo suelen estar implicados en funciones similares, lo que facilita la anotación funcional de genes no caracterizados.\nDescubrimiento de biomarcadores: En estudios de transcriptómica y proteómica, los módulos identificados pueden revelar biomarcadores asociados a enfermedades o estados fisiológicos específicos .\nModelado de la robustez y vulnerabilidad del sistema: La estructura modular ayuda a entender cómo los sistemas biológicos mantienen su funcionalidad frente a perturbaciones, ya sea mediante redundancia o interacción entre módulos.\nEvolución de las redes biológicas: El análisis de los módulos permite estudiar cómo han evolucionado las interacciones entre genes y proteínas en diferentes especies."
  },
  {
    "objectID": "clustering.html#métodos-de-clustering-cubiertos",
    "href": "clustering.html#métodos-de-clustering-cubiertos",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "",
    "text": "A lo largo de este tutorial, se abordarán cinco métodos principales de clustering, cada uno con características únicas:\n\nEdge Betweenness (Intermediación de Aristas):\n\nIdentifica comunidades al eliminar iterativamente las aristas con mayor intermediación.\n\nEs particularmente útil para redes pequeñas y permite una visualización clara del proceso de partición. Sin embargo, su complejidad lo hace ineficiente para redes grandes.\n\nWalktrap (Caminatas Aleatorias):\n\nUtiliza caminatas aleatorias para detectar comunidades, basándose en la idea de que nodos dentro de una misma comunidad están más “cercanos” en términos probabilísticos.\n\nIdeal para redes medianas con módulos densos y conexos.\n\nFast Greedy (Greedy Maximization of Modularity):\n\nUn método jerárquico que agrupa nodos de manera iterativa para maximizar la modularidad global.\n\nEs eficiente y adecuado para redes grandes, aunque su resolución puede ser limitada en algunos casos.\n\nInfomap:\n\nSe basa en la teoría de la codificación de información para dividir la red en módulos, minimizando la descripción de un caminante aleatorio.\n\nEs particularmente efectivo en redes con muchas comunidades pequeñas.\n\nLabel Propagation:\n\nUn método rápido y escalable que utiliza la propagación iterativa de etiquetas para asignar nodos a comunidades.\n\nSu simplicidad lo hace adecuado para redes extremadamente grandes, aunque puede generar resultados variables.\n\n\nCada método será descrito en detalle, con explicaciones teóricas, ventajas, desventajas, y ejemplos ilustrativos. Además, se destacarán las mejores prácticas para aplicar estos métodos en el contexto de biología de sistemas y otras áreas.\n\n\nLabusek N, Mouloud Y, Köster C, Diesterbeck E, Tertel T, Wiek C, Hanenberg H, Horn PA, Felderhoff-Müser U, Bendix I, Giebel B, Herz J. Extracellular vesicles from immortalized mesenchymal stromal cells protect against neonatal hypoxic-ischemic brain injury. Inflamm Regen. 2023 Apr 17;43(1):24. doi: 10.1186/s41232-023-00274-6. PMID: 37069694; PMCID: PMC10108458.\nNielsen J, Keasling JD. Engineering Cellular Metabolism. Cell. 2016 Mar 10;164(6):1185-1197. doi: 10.1016/j.cell.2016.02.004. PMID: 26967285.\nGordon DE, Jang GM, Bouhaddou M, Xu J, Obernier K, White KM, O’Meara MJ, Rezelj VV, Guo JZ, Swaney DL, Tummino TA, Hüttenhain R, Kaake RM, Richards AL, Tutuncuoglu B, Foussard H, Batra J, Haas K, Modak M, Kim M, Haas P, Polacco BJ, Braberg H, Fabius JM, Eckhardt M, Soucheray M, Bennett MJ, Cakir M, McGregor MJ, Li Q, Meyer B, Roesch F, Vallet T, Mac Kain A, Miorin L, Moreno E, Naing ZZC, Zhou Y, Peng S, Shi Y, Zhang Z, Shen W, Kirby IT, Melnyk JE, Chorba JS, Lou K, Dai SA, Barrio-Hernandez I, Memon D, Hernandez-Armenta C, Lyu J, Mathy CJP, Perica T, Pilla KB, Ganesan SJ, Saltzberg DJ, Rakesh R, Liu X, Rosenthal SB, Calviello L, Venkataramanan S, Liboy-Lugo J, Lin Y, Huang XP, Liu Y, Wankowicz SA, Bohn M, Safari M, Ugur FS, Koh C, Savar NS, Tran QD, Shengjuler D, Fletcher SJ, O’Neal MC, Cai Y, Chang JCJ, Broadhurst DJ, Klippsten S, Sharp PP, Wenzell NA, Kuzuoglu-Ozturk D, Wang HY, Trenker R, Young JM, Cavero DA, Hiatt J, Roth TL, Rathore U, Subramanian A, Noack J, Hubert M, Stroud RM, Frankel AD, Rosenberg OS, Verba KA, Agard DA, Ott M, Emerman M, Jura N, von Zastrow M, Verdin E, Ashworth A, Schwartz O, d’Enfert C, Mukherjee S, Jacobson M, Malik HS, Fujimori DG, Ideker T, Craik CS, Floor SN, Fraser JS, Gross JD, Sali A, Roth BL, Ruggero D, Taunton J, Kortemme T, Beltrao P, Vignuzzi M, García-Sastre A, Shokat KM, Shoichet BK, Krogan NJ. A SARS-CoV-2 protein interaction map reveals targets for drug repurposing. Nature. 2020 Jul;583(7816):459-468. doi: 10.1038/s41586-020-2286-9. Epub 2020 Apr 30. PMID: 32353859; PMCID: PMC7431030.\nBuenrostro JD, Corces MR, Lareau CA, Wu B, Schep AN, Aryee MJ, Majeti R, Chang HY, Greenleaf WJ. Integrated Single-Cell Analysis Maps the Continuous Regulatory Landscape of Human Hematopoietic Differentiation. Cell. 2018 May 31;173(6):1535-1548.e16. doi: 10.1016/j.cell.2018.03.074. Epub 2018 Apr 26. PMID: 29706549; PMCID: PMC5989727.\nSaxton RA, Sabatini DM. mTOR Signaling in Growth, Metabolism, and Disease. Cell. 2017 Mar 9;168(6):960-976. doi: 10.1016/j.cell.2017.02.004. Erratum in: Cell. 2017 Apr 6;169(2):361-371. doi: 10.1016/j.cell.2017.03.035. PMID: 28283069; PMCID: PMC5394987."
  },
  {
    "objectID": "clustering.html#conceptos-básicos-de-edge-betweenness",
    "href": "clustering.html#conceptos-básicos-de-edge-betweenness",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "Conceptos Básicos de Edge Betweenness",
    "text": "Conceptos Básicos de Edge Betweenness\nLa betweenness de una arista es casi el mismo que el centralidad de intermediación que vimos en la primera practica. Pero aqui lo aplicamos a los enlaces, entonces en este caso es una medida que evalúa cuántos caminos más cortos entre pares de nodos pasan por un enlace específica. Enlaces con alta betweenness suelen actuar como “puentes” entre diferentes comunidades dentro de una red.\nMatemáticamente, la betweenness de una arista \\(e\\) se define como:\n\\[\nB(e) = \\sum_{s \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}\n\\]\nDonde:\n- \\(\\sigma_{st}\\) es el número total de caminos más cortos entre los nodos \\(s\\) y \\(t\\).\n- \\(\\sigma_{st}(e)\\) es el número de esos caminos que pasan por la arista \\(e\\).\nLa idea central del método es que al eliminar las aristas con mayor betweenness, se separan progresivamente las comunidades que están conectadas de manera más débil.\n\nCómo Funciona el Algoritmo\n\nCálculo de Betweenness Inicial:\nSe calcula la betweenness de todas las aristas en la red. Este paso inicial es computacionalmente costoso, ya que implica evaluar caminos más cortos para todos los pares de nodos.\nEliminación de Aristas:\nSe identifica la arista con el valor más alto de betweenness y se elimina de la red. Esta eliminación puede desconectar nodos o subconjuntos de nodos, formando comunidades más pequeñas.\nReevaluación de Betweenness:\nDespués de eliminar una arista, se recalcula la betweenness de las aristas restantes, ya que la estructura de la red ha cambiado.\nRepetición:\nLos pasos anteriores se repiten iterativamente hasta que todas las aristas hayan sido eliminadas, dejando la red completamente desconectada.\nOptimización:\nDurante el proceso, se evalúan métricas como la modularidad (\\(Q\\)) para determinar el número óptimo de comunidades. La modularidad lo hemos visto antes; mide la calidad de una partición y se define como:\n\\[\nQ = \\frac{1}{2m} \\sum_{i,j} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j)\n\\]\nDonde:\n\n\\(A_{ij}\\): Matriz de adyacencia.\n\n\\(k_i, k_j\\): Grados de los nodos \\(i\\) y \\(j\\).\n\n\\(m\\): Número total de aristas en la red.\n\n\\(\\delta(c_i, c_j)\\): Indicador de si \\(i\\) y \\(j\\) están en la misma comunidad.\n\n\n\n\nVisualización del Proceso de Clustering\nPara comprender cómo funciona el clustering basado en betweenness, podemos visualizar el proceso paso a paso. Comenzamos con el grafo completo y eliminamos iterativamente las aristas con mayor betweenness.\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(netUtils)  # For LFR network generation\n\n# Generate a LFR benchmark network with clear communities\nn &lt;- 100  # Number of nodes\ntau1 &lt;- 3  # Degree distribution exponent for nodes\ntau2 &lt;- 1.5  # Degree distribution exponent for communities\nmu &lt;- 0.1  # Mixing parameter (controls inter-community edges)\naverage_degree &lt;- 4  # Desired average degree of nodes\nmax_degree &lt;- 5  # Maximum degree of nodes\n\n# Generate the LFR network using the correct arguments\ng &lt;- sample_lfr(n = n, tau1 = tau1, tau2 = tau2, mu = mu, \n                average_degree = average_degree, max_degree = max_degree)\n\n-----------------------------------------------------------\ncommunity size range automatically set equal to [4 , 5]\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 5 5 5 4 5 5 4 4 5 4 4 4 4 5 4 4 5 6 4 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 5 5 4 5 5 4 4 5 4 4 4 4 5 4 4 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 5 4 5 5 4 4 5 4 4 4 4 5 4 9 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 4 5 5 4 4 5 4 4 4 4 5 9 9 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n4 5 5 4 4 5 4 4 4 9 5 9 9 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 5 4 4 5 4 4 8 9 5 9 9 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n5 4 4 5 4 9 8 9 5 9 9 5 6 9 9 \n\nit took too long to decide the memberships; I will try to change the community sizes\nnew community sizes\n4 4 5 9 9 8 9 5 9 9 5 6 9 9 \n\n# Calculate edge betweenness\nedge_btw &lt;- edge_betweenness(g)\ntop_edges &lt;- order(edge_btw, decreasing = TRUE)\n\n# Plot settings for consistent layout\nlayout &lt;- layout_with_fr(g)  # Use Fruchterman-Reingold layout for fixed positions\n\n# Plot the original graph with the highest betweenness edges highlighted\nplot(g, layout = layout, main = \"Original LFR Network with High Betweenness Edges\",\n     edge.width = ifelse(rank(-edge_btw) &lt;= 1, 4, 1),  # Highlight top 3 edges\n     edge.color = ifelse(rank(-edge_btw) &lt;= 1, \"red\", \"gray\"),\n     vertex.color = \"skyblue\", vertex.size = 10, vertex.label = NA)\n\n\n\n\n\n\n\n# Stepwise removal of high-betweenness edges\n# Remove top betweenness edges iteratively and plot the result each time\nedge_to_remove &lt;- which.max(edge_btw)\nfor (i in 1:20) {\n  cat(\"Quitando enlace con el \", i, \" mas alta conectividad\\n\")\n  # Identify the edge with the highest betweenness remaining\n\n  g &lt;- delete_edges(g, E(g)[edge_to_remove])\n  \n  # Recalculate connected components\n  components &lt;- clusters(g)\n  \n  # Calculate and print modularity\n  mod &lt;- modularity(g, components$membership)\n\n  \n  # Assign a color to each component\n  component_colors &lt;- rainbow(components$no)[components$membership]\n  \n  # Edge to remove in next iteration:\n  edge_btw &lt;- edge_betweenness(g)\n  edge_to_remove &lt;- which.max(edge_btw)\n  # Plot the graph after each removal\n  plot(g, layout = layout, main = paste(\"After Removing Top\", i, \"High-Betweenness Edges\\n Modularity =\", mod, \"\\n Number of clusters:\", components$no),\n       vertex.color = component_colors, vertex.size = 10, vertex.label = NA,\n            edge.width = ifelse(rank(-edge_btw) &lt;= 1, 4, 1),  # Highlight top 3 edges\n     edge.color = ifelse(rank(-edge_btw) &lt;= 1, \"red\", \"gray\"), edge.width = 1)\n}\n\nQuitando enlace con el  1  mas alta conectividad\n\n\nWarning: `clusters()` was deprecated in igraph 2.0.0.\nℹ Please use `components()` instead.\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  2  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  3  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  4  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  5  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  6  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  7  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  8  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  9  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  10  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  11  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  12  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  13  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  14  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  15  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  16  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  17  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  18  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  19  mas alta conectividad\n\n\n\n\n\n\n\n\n\nQuitando enlace con el  20  mas alta conectividad\n\n\n\n\n\n\n\n\n\n\n\nVentajas y Desventajas\nVentajas:\n- Es un método intuitivo y visual que identifica comunidades de manera progresiva. - Identifica estructuras comunitarias significativas, especialmente en redes con cuellos de botella claros. - Permite una evaluación dinámica de la estructura de la red durante el proceso de partición.\n- Es útil para redes de tamaño moderado con alta conectividad.\nDesventajas:\n- Es computacionalmente intensivo, especialmente para redes grandes, debido a la necesidad de recalcular betweenness iterativamente.\n- Puede ser sensible a pequeñas variaciones en la estructura de la red, lo que afecta la estabilidad de los resultados."
  },
  {
    "objectID": "clustering.html#conceptos-básicos-del-método-walktrap",
    "href": "clustering.html#conceptos-básicos-del-método-walktrap",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "Conceptos Básicos del Método Walktrap",
    "text": "Conceptos Básicos del Método Walktrap\nLa idea principal detrás de Walktrap es que los nodos dentro de la misma comunidad tienden a ser más cercanos en términos de caminos aleatorios que aquellos en comunidades diferentes. Para medir esta cercanía, Walktrap utiliza la distancia de caminos aleatorios entre los nodos, que captura la similitud estructural basada en las trayectorias aleatorias.\nEl algoritmo se basa en los siguientes pasos:\n\nSimulación de Caminos Aleatorios:\nSe simulan caminos aleatorios en la red comenzando desde cada nodo, siguiendo las conexiones existentes.\nCálculo de la Distancia entre Nodos:\nLa distancia entre nodos \\(i\\) y \\(j\\) se mide considerando la probabilidad de que un camino aleatorio que empieza en \\(i\\) llegue a \\(j\\).\nMatemáticamente, la distancia entre comunidades se define como:\n\\[\nd(C_1, C_2) = ||\\mathbf{p}_{C_1} - \\mathbf{p}_{C_2}||^2\n\\]\n\n\n\n\n\n\n\nExplicacion de la formula e intuicion de la distancia\n\n\n\n\n\n\\(\\mathbf{p}_{C_k}\\):\nEste es el vector de probabilidades asociado a la comunidad \\(C_k\\). Cada elemento del vector indica la probabilidad de que un paseo aleatorio en la red se encuentre en un nodo específico de esa comunidad después de un número suficiente de pasos.\n\\(||\\mathbf{p}_{C_1} - \\mathbf{p}_{C_2}||^2\\):\nLa norma cuadrada (distancia euclidiana al cuadrado) mide qué tan diferentes son los vectores de probabilidad de las comunidades \\(C_1\\) y \\(C_2\\). Si esta distancia es pequeña, significa que las probabilidades de navegación en ambas comunidades son similares, lo que sugiere que los nodos están estrechamente conectados entre las comunidades.\nIntuición detrás de la distancia El algoritmo Walktrap utiliza esta métrica para medir la “cercanía” entre comunidades basándose en cómo los paseos aleatorios se distribuyen entre ellas. Dos comunidades serán consideradas “próximas” si: - Los nodos de una comunidad tienen una alta probabilidad de acceder a los nodos de la otra durante un paseo aleatorio.\n- Los vectores de probabilidad \\(\\mathbf{p}_{C_1}\\) y \\(\\mathbf{p}_{C_2}\\) son similares, lo que implica que los nodos están bien conectados a través de enlaces.\nPor el contrario, si la distancia entre comunidades es grande, significa que hay pocos caminos que conectan los nodos entre esas comunidades.\nRelevancia para la Identificación de Comunidades Al fusionar comunidades basándose en esta métrica de distancia, el algoritmo Walktrap asegura que las comunidades agrupadas comparten conexiones significativas, manteniendo un alto grado de coherencia interna. Este proceso gradual de fusión permite identificar estructuras jerárquicas en la red, revelando módulos funcionales.\nEjemplo Biológico En una red de interacción proteína-proteína (PPI), esta métrica podría agrupar proteínas que participan en un mismo complejo funcional o ruta metabólica. Por ejemplo: - Si las proteínas en \\(C_1\\) y \\(C_2\\) tienen roles interdependientes en un proceso celular, los vectores \\(\\mathbf{p}_{C_1}\\) y \\(\\mathbf{p}_{C_2}\\) serán similares. Esto podría corresponder a módulos funcionales como un complejo ribosomal o proteínas de señalización en cascada.\n\n\n\n\nFusión Jerárquica:\nWalktrap utiliza un esquema de clustering aglomerativo jerárquico. Comienza considerando cada nodo como una comunidad separada y fusiona iterativamente las comunidades más cercanas.\nOptimización:\nSe evalúan métricas como la modularidad (\\(Q\\)) para determinar la partición óptima."
  },
  {
    "objectID": "clustering.html#ventajas-y-desventajas-1",
    "href": "clustering.html#ventajas-y-desventajas-1",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "Ventajas y Desventajas",
    "text": "Ventajas y Desventajas\nVentajas:\n- Captura de manera efectiva la estructura modular de redes complejas.\n- Computacionalmente eficiente para redes grandes.\n- Basado en un enfoque probabilístico que refleja mejor la conectividad local.\nDesventajas:\n- Puede no ser tan preciso en redes muy dispersas o con bajo número de conexiones.\n- La elección de la longitud de los caminos aleatorios puede influir en los resultados.\n\nEjemplo en R\nEl siguiente código demuestra cómo aplicar el algoritmo Walktrap a una red simulada y visualizar los resultados:\n\nlibrary(igraph)\n\n# Crear una red de interacción proteína-proteína simulada\nset.seed(42)\ng &lt;- sample_pa(n = 100, m = 2, directed = FALSE)\n\n# Aplicar Walktrap clustering\nwc &lt;- cluster_walktrap(g)\n\n# Visualizar comunidades detectadas\nplot(\n  g,\n  vertex.color = membership(wc),\n  vertex.size = 5,\n  layout = layout_with_fr(g),\n  edge.arrow.size = 0.5,\n  main = \"Clustering basado en Walktrap\"\n)\n\n\n\n\n\n\n\n# Evaluar modularidad\nmodularity(wc)\n\n[1] 0.4314978\n\n\n\n\nVisualización del Funcionamiento del Algoritmo\nEl siguiente ejemplo ilustra cómo Walktrap funciona al fusionar comunidades jerárquicamente, destacando las comunidades formadas en cada paso:\n\n# Create a toy network with modular structure\nset.seed(42)\ng &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_ring(5)  # Three clusters\ng &lt;- add_edges(g, c(1, 6, 6, 11))  # Add inter-cluster connections\n\n# Plot the original network\nplot(g, vertex.label = NA, main = \"Original Network\", layout = layout_with_fr)\n\n\n\n\n\n\n\n# Perform Walktrap clustering\nwalktrap &lt;- cluster_walktrap(g)\n\n# Extract the number of clusters at each step\nnum_clusters &lt;- rev(seq_along(walktrap$merges))\n\n# Plot function for intermediate clustering steps\nplot_walktrap_progression &lt;- function(graph, walktrap, step) {\n  memberships &lt;- cut_at(walktrap, no = step)  # Cluster memberships at this step\n  node_colors &lt;- rainbow(max(memberships))[memberships]  # Color nodes by cluster\n  \n  plot(graph, \n       vertex.color = node_colors, \n       vertex.label = NA, \n       main = paste(\"Step\", length(walktrap$merges) - step + 1, \n                    \"-\", step, \"Clusters\"),\n       layout = layout_with_fr)\n}\n\n# Visualize clustering steps\nfor (step in c(12, 8, 4, 3)) {  # Select key steps to illustrate progression\n  plot_walktrap_progression(g, walktrap, step)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Plot dendrogram\npar(mfrow = c(1, 1))\nplot_dendrogram(walktrap, main = \"Walktrap Dendrogram\")"
  },
  {
    "objectID": "clustering.html#cómo-funciona-el-algoritmo-fast-greedy",
    "href": "clustering.html#cómo-funciona-el-algoritmo-fast-greedy",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "¿Cómo Funciona el Algoritmo Fast Greedy?",
    "text": "¿Cómo Funciona el Algoritmo Fast Greedy?\n\nModularidad como Métrica Clave\nLa modularidad (\\(Q\\)) mide la calidad de una partición de la red en comunidades, comparando la densidad de aristas dentro de comunidades frente a una red aleatoria con la misma distribución de grados. Matemáticamente (se que ya lo hemos visto antes 2 veces pero es especialmente importante aqui):\n\\[\nQ = \\frac{1}{2m} \\sum_{ij} \\left[A_{ij} - \\frac{k_i k_j}{2m}\\right] \\delta(c_i, c_j)\n\\]\n\n\\(A_{ij}\\): Existencia de una arista entre los nodos \\(i\\) y \\(j\\).\n\n\\(k_i, k_j\\): Grados de los nodos \\(i\\) y \\(j\\).\n\n\\(m\\): Número total de aristas en la red.\n\n\\(\\delta(c_i, c_j)\\): Es 1 si \\(i\\) y \\(j\\) están en la misma comunidad, y 0 en caso contrario.\n\nEstrategia Greedy (Voraz)\nEl algoritmo Fast Greedy sigue una estrategia greedy o voraz, lo que significa que toma decisiones locales en cada paso para mejorar la modularidad. El algoritmo funciona de la siguiente manera:\n\nPaso inicial: Comienza considerando que cada nodo es su propia comunidad.\nFusión de comunidades: En cada paso, fusiona las dos comunidades que más incrementan la modularidad.\nTerminación: El algoritmo continúa fusionando comunidades hasta que no se pueda incrementar más la modularidad.\n\n\nLa eficiencia del algoritmo se debe a que no tiene que evaluar todas las posibles particiones, sino que se concentra en el máximo incremento de modularidad en cada paso. Esto lo hace rápido y adecuado para redes grandes.\n\nResultados Jerárquicos\nSimilar a otros métodos jerárquicos como Walktrap, el algoritmo Fast Greedy genera un dendrograma, que muestra cómo se van fusionando las comunidades a medida que la modularidad se maximiza. Este dendrograma se puede cortar en diferentes niveles de granularidad para obtener particiones de la red con distintas cantidades de comunidades.\n\n\n\n\n\n\n\nModularidad es global o local?\n\n\n\n\n\nLa modularidad es una propiedad global de una red, aunque puede ser calculada localmente cuando se considera una partición específica de la red en comunidades.\nPropiedad Global:\nLa modularidad mide la calidad de toda la partición de una red, es decir, evalúa qué tan bien están agrupados los nodos en comunidades dentro de la red. Compara la densidad real de aristas dentro de las comunidades con lo que se esperaría en una red aleatoria con la misma distribución de grados (el número de aristas conectadas a cada nodo). Esta medida requiere evaluar la estructura completa de la red en relación con la partición propuesta de los nodos.\nCálculo Local:\nAunque la modularidad es una propiedad global de la red, se calcula localmente para cada comunidad durante el proceso de optimización. Cuando se utilizan algoritmos como Fast Greedy o Louvain para detectar comunidades, la modularidad se optimiza mediante la fusión de comunidades basadas en los cambios locales en la puntuación de modularidad. En cada paso, se observa el efecto de fusionar dos comunidades en la modularidad, pero la puntuación total de modularidad considera la estructura de toda la red.\nEn resumen, la modularidad en sí es una propiedad global que depende de toda la estructura de la red y de la partición de los nodos, pero la optimización (o el cálculo) se realiza a través de decisiones locales iterativas sobre cómo fusionar o dividir las comunidades.\n\n\n\n\nVentajas y Desventajas\nVentajas:\n\nEscalabilidad: El algoritmo es rápido y adecuado para redes grandes con miles de nodos.\nOptimización directa de modularidad: La modularidad proporciona una métrica intuitiva para evaluar la calidad del clustering, lo que facilita la interpretación de los resultados.\nIdentificación clara de comunidades: Dado que se enfoca en maximizar la modularidad, es particularmente efectivo en redes densas donde las comunidades están bien definidas.\n\nDesventajas:\n\nRedes con estructuras pequeñas o solapadas: El algoritmo puede no funcionar bien cuando las comunidades son pequeñas o se solapan mucho, ya que la estrategia greedy no siempre puede detectar estos patrones sutiles.\nRedes dispersas: En redes con muy pocas conexiones internas entre nodos dentro de cada comunidad, el algoritmo puede tener dificultades para identificar bien las comunidades.\n\n\n\nEjemplo en R\nEl siguiente código muestra cómo aplicar el algoritmo Fast Greedy a una red simulada. En este caso, se utiliza una red aleatoria generada mediante el modelo de Preferential Attachment (sample_pa), que tiene una estructura modular natural.\n\nlibrary(igraph)\n\n# Crear una red simulada\nset.seed(42)\ng &lt;- sample_pa(n = 100, m = 2, directed = FALSE)  # Red generada con el modelo Preferential Attachment\n\n# Aplicar el algoritmo Fast Greedy\nfc &lt;- cluster_fast_greedy(g)\n\n# Visualizar las comunidades\nplot(\n  g,\n  vertex.color = membership(fc),  # Colorear nodos según las comunidades\n  layout = layout_with_fr(g),  # Layout Fruchterman-Reingold para visualizar la red\n  vertex.size = 5,  # Tamaño de los nodos\n  main = \"Clustering Basado en Fast Greedy\"\n)\n\n\n\n\n\n\n\n# Mostrar la modularidad de la partición\ncat(\"Modularidad:\", modularity(fc), \"\\n\")\n\nModularidad: 0.4494963 \n\n\n\n\nExplicación del Código:\n\nGeneración de la red: Usamos el modelo de Preferential Attachment (sample_pa) para crear una red con 100 nodos y una probabilidad de 2 conexiones por nodo. Este modelo genera una red con una estructura de “preferencia” donde los nodos más conectados tienen más probabilidades de atraer nuevas conexiones, lo que lleva a una red con estructuras jerárquicas y comunidades naturales.\nAplicación del algoritmo: Utilizamos la función cluster_fast_greedy() de igraph para aplicar el algoritmo Fast Greedy a la red generada. El algoritmo detecta las comunidades optimizando la modularidad.\nVisualización: En el gráfico generado, los nodos se colorean según las comunidades detectadas por el algoritmo, y se utiliza el layout de Fruchterman-Reingold para visualizar la red de manera que las comunidades estén lo más separadas posible.\nModularidad: Finalmente, se imprime el valor de la modularidad (\\(Q\\)) de la partición obtenida. Este valor indica la calidad de la partición, siendo un valor alto una señal de que las comunidades están bien definidas."
  },
  {
    "objectID": "clustering.html#cómo-funciona-el-algoritmo-de-label-propagation",
    "href": "clustering.html#cómo-funciona-el-algoritmo-de-label-propagation",
    "title": "Partición de grafos (I). Módulos en redes biológicas",
    "section": "¿Cómo Funciona el Algoritmo de Label Propagation?",
    "text": "¿Cómo Funciona el Algoritmo de Label Propagation?\nEl algoritmo de Label Propagation sigue un proceso iterativo en el que cada nodo de la red tiene una “etiqueta” inicial (generalmente, su propio identificador o una etiqueta aleatoria). La idea principal es que los nodos en la misma comunidad tienden a compartir las mismas etiquetas, por lo que a través de la propagación de etiquetas, los nodos de una misma comunidad convergerán hacia la misma etiqueta.\nAquí está el proceso paso a paso:\n\n\n\nlabel propagation\n\n\n\nInicialización: Cada nodo recibe una etiqueta inicial. Por lo general, cada nodo comienza con una etiqueta única o aleatoria. En este caso, asumimos que cada nodo está en su propia comunidad.\nPropagación: En cada paso, cada nodo actualiza su etiqueta en función de las etiquetas de sus vecinos. La etiqueta que un nodo adoptará es la etiqueta más frecuente entre sus vecinos. Si varios vecinos tienen etiquetas diferentes, el nodo elige aleatoriamente entre las etiquetas más frecuentes.\nRepetición: Este proceso de actualización de etiquetas se repite varias veces (hasta que no haya cambios) o durante un número de iteraciones predefinido. A medida que se repiten las iteraciones, los nodos que están más cerca entre sí en la red empiezan a compartir la misma etiqueta, formando comunidades.\nFinalización: El algoritmo finaliza cuando las etiquetas de todos los nodos dejan de cambiar. En ese momento, las comunidades están definidas por los nodos que comparten la misma etiqueta.\n\n\nVentajas y Desventajas\nVentajas: - Escalabilidad: El algoritmo es muy eficiente, especialmente en redes grandes, ya que no requiere el cálculo de métricas complejas, como la modularidad. - Simplicidad: Es un algoritmo simple de entender e implementar. No requiere ninguna información de la estructura global de la red, solo las conexiones locales entre los nodos.\nDesventajas: - Estabilidad: Puede ser sensible al orden de los nodos en las iteraciones. En redes con estructuras complejas o de gran tamaño, la convergencia puede ser lenta o inestable. - Dependencia de la inicialización: Los resultados pueden depender de cómo se asignan las etiquetas iniciales. En algunos casos, el algoritmo puede dar lugar a particiones inadecuadas si no se tiene en cuenta la conectividad entre los nodos. - Comunidad solapada: No es adecuado para detectar comunidades solapadas, donde un nodo pertenece a varias comunidades al mismo tiempo."
  },
  {
    "objectID": "func_enric_2.html",
    "href": "func_enric_2.html",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "",
    "text": "Este tutorial amplía nuestra discusión previa sobre el Análisis de Sobre-representación (ORA, por sus siglas en inglés) y el Análisis de Enriquecimiento de Conjuntos de Genes (GSEA, por sus siglas en inglés). Nos enfocaremos en técnicas avanzadas para interpretar los resultados de enriquecimiento funcional mediante visualizaciones, enfoques basados en redes y métodos basados en la topología de rutas metabólicas. Finalmente, exploraremos técnicas de enriquecimiento que consideran ontologías, enfatizando las dependencias jerárquicas en los sistemas de clasificación funcional."
  },
  {
    "objectID": "func_enric_2.html#visualización-del-análisis-de-sobre-representación-ora-con-clusterprofiler",
    "href": "func_enric_2.html#visualización-del-análisis-de-sobre-representación-ora-con-clusterprofiler",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Visualización del Análisis de Sobre-representación (ORA) con clusterProfiler",
    "text": "Visualización del Análisis de Sobre-representación (ORA) con clusterProfiler\n\nTeoría: ¿Qué es el ORA?\nEl ORA evalúa si conjuntos de genes predefinidos, como términos de la Ontología Genética (GO, por sus siglas en inglés) o rutas metabólicas, están sobre-representados en un conjunto de genes de consulta en comparación con un conjunto de referencia. La significancia se evalúa utilizando pruebas estadísticas como la prueba exacta de Fisher o la prueba hipergeométrica.\n\n\nPor qué la visualización es crucial\nLa visualización de los resultados de ORA facilita la interpretación del significado biológico de las categorías enriquecidas al revelar patrones, relaciones y solapamientos. Esto puede guiar hipótesis y contextualizar hallazgos.\n\n\nTipos clave de visualización\n\nGráfico de puntos (Dot Plot): Muestra la significancia (valor p) y la magnitud del enriquecimiento (por ejemplo, número de genes o puntaje de enriquecimiento).\nGráfico de barras (Bar Plot): Destaca los términos más enriquecidos según su significancia o magnitud.\ncnetplot: Muestra las relaciones entre los genes de consulta y las categorías enriquecidas, ayudando a visualizar solapamientos.\n\n\n\nCódigo de ejemplo: Realización de ORA y visualización de resultados\n\n# Cargar clusterProfiler y un conjunto de datos de ejemplo\nlibrary(clusterProfiler)\n\n\n\n\nclusterProfiler v4.14.3 Learn more at https://yulab-smu.top/contribution-knowledge-mining/\n\nPlease cite:\n\nG Yu. Thirteen years of clusterProfiler. The Innovation. 2024,\n5(6):100722\n\n\n\nAttaching package: 'clusterProfiler'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nlibrary(org.Hs.eg.db)\n\nLoading required package: AnnotationDbi\n\n\nLoading required package: stats4\n\n\nLoading required package: BiocGenerics\n\n\n\nAttaching package: 'BiocGenerics'\n\n\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n\n\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, saveRDS, setdiff,\n    table, tapply, union, unique, unsplit, which.max, which.min\n\n\nLoading required package: Biobase\n\n\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n\n\nLoading required package: IRanges\n\n\nLoading required package: S4Vectors\n\n\n\nAttaching package: 'S4Vectors'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    rename\n\n\nThe following object is masked from 'package:utils':\n\n    findMatches\n\n\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n\n\n\nAttaching package: 'IRanges'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    slice\n\n\n\nAttaching package: 'AnnotationDbi'\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    select\n\n\n\n\n# Lista de genes de ejemplo (genes diferencialmente expresados)\ngenes &lt;- c(\"HK1\", \"HK2\", \"GCK\", \"PFKM\", \"PFKP\", \"ALDOA\", \"ALDOC\", \"TPI1\", \n                      \"GAPDH\", \"PGK1\", \"ENO1\", \"PKM\", \"LDHA\", \"LDHB\")\n\n# Realizar ORA para términos de GO\nego &lt;- enrichGO(gene         = genes,\n                keyType      = \"SYMBOL\",\n                OrgDb        = org.Hs.eg.db,\n                ont          = \"BP\", # Proceso biológico\n                pAdjustMethod = \"BH\",\n                qvalueCutoff  = 0.05)\n\n# Gráfico de puntos\ndotplot(ego, showCategory = 10)\n\n\n\n\n\n\n\n# Gráfico de barras\nbarplot(ego, showCategory = 10)\n\n\n\n\n\n\n\n# cnetplot\ncnetplot(ego, showCategory = 5, circular = TRUE, colorEdge = TRUE)\n\n\n\n\n\n\n\n\n\n\nExplicación\n\nenrichGO(): Realiza ORA para procesos biológicos en la Ontología Genética.\ndotplot(): Visualiza términos según su valor p y la proporción de genes.\ncnetplot(): Explora las relaciones entre genes y términos."
  },
  {
    "objectID": "func_enric_2.html#visualización-del-análisis-de-enriquecimiento-de-conjuntos-de-genes-gsea-con-clusterprofiler",
    "href": "func_enric_2.html#visualización-del-análisis-de-enriquecimiento-de-conjuntos-de-genes-gsea-con-clusterprofiler",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Visualización del Análisis de Enriquecimiento de Conjuntos de Genes (GSEA) con clusterProfiler",
    "text": "Visualización del Análisis de Enriquecimiento de Conjuntos de Genes (GSEA) con clusterProfiler\n\nTeoría: ¿Qué es el GSEA?\nEl GSEA clasifica todos los genes según una métrica (por ejemplo, cambio de expresión) y calcula puntajes de enriquecimiento (ES, por sus siglas en inglés) para conjuntos de genes predefinidos. Identifica si los genes en los extremos de una lista clasificada están enriquecidos para términos o rutas específicas.\n\n\nTipos clave de visualización\n\nGráfico de puntaje de enriquecimiento (Enrichment Score Plot): Visualiza el ES en la lista clasificada para un único conjunto de genes.\nGráfico de resultados de GSEA: Resume múltiples conjuntos de genes, sus ES y el margen de enriquecimiento.\ncnetplot para GSEA: Muestra relaciones y solapamientos entre conjuntos de genes.\n\n\n\nCódigo de ejemplo: Realización de GSEA y visualización de resultados\n\n# Lista de genes clasificada de ejemplo\nlibrary(org.Hs.eg.db)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:AnnotationDbi':\n\n    select\n\n\nThe following objects are masked from 'package:IRanges':\n\n    collapse, desc, intersect, setdiff, slice, union\n\n\nThe following objects are masked from 'package:S4Vectors':\n\n    first, intersect, rename, setdiff, setequal, union\n\n\nThe following object is masked from 'package:Biobase':\n\n    combine\n\n\nThe following objects are masked from 'package:BiocGenerics':\n\n    combine, intersect, setdiff, union\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# List of glycolysis-related genes (expand this list as necessary)\nglycolysis_genes &lt;- c(\"HK1\", \"HK2\", \"GCK\", \"PFKM\", \"PFKP\", \"ALDOA\", \"ALDOC\", \"TPI1\", \n                      \"GAPDH\", \"PGK1\", \"ENO1\", \"PKM\", \"LDHA\", \"LDHB\")\n\n# Retrieve all human gene symbols from org.Hs.eg.db\nall_genes &lt;- keys(org.Hs.eg.db, keytype = \"SYMBOL\")\n# Randomly sample 485 genes from the full list (excluding glycolysis genes)\nset.seed(123)  # Set seed for reproducibility\nrandom_genes &lt;- sample(all_genes[!all_genes %in% glycolysis_genes], 485)\n\n# Combine glycolysis-related genes at the start of the list\ncombined_genes &lt;- c(glycolysis_genes, random_genes)\n\n# Assign higher FC values for glycolysis genes (1 to 3) and lower for others (-3 to 1)\nfc_values &lt;- c(runif(length(glycolysis_genes), min = 1, max = 3),  # Higher FC for glycolysis genes\n               runif(length(random_genes), min = -3, max = 1.5))    # Lower FC for others\n\n# Create the gene list with fold changes and sort so decreasing\ngene_list &lt;- setNames(fc_values, combined_genes)\ngene_list &lt;- sort(gene_list, decreasing = TRUE)\n\n# Realizar GSEA\ngsea &lt;- gseGO(geneList     = gene_list,\n              OrgDb        = org.Hs.eg.db,\n              keyType      = \"SYMBOL\",\n              ont          = \"BP\",\n              pvalueCutoff = 0.05)\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nWarning in fgseaMultilevel(pathways = pathways, stats = stats, minSize =\nminSize, : For some of the pathways the P-values were likely overestimated. For\nsuch pathways log2err is set to NA.\n\n\nWarning in fgseaMultilevel(pathways = pathways, stats = stats, minSize =\nminSize, : For some pathways, in reality P-values are less than 1e-10. You can\nset the `eps` argument to zero for better estimation.\n\n\nleading edge analysis...\n\n\ndone...\n\n# Gráfico de puntaje de enriquecimiento\ngseaplot(gsea, geneSetID = 1, title = gsea$Description[1])\n\n\n\n\n\n\n\n# cnetplot para GSEA\ncnetplot(gsea, showCategory = 5)\n\n\n\n\n\n\n\n\n\n\nExplicación\n\ngseGO(): Realiza GSEA para términos de la Ontología Genética.\ngseaplot(): Resalta los picos de ES, mostrando dónde ocurre el enriquecimiento.\ncnetplot(): Visualiza solapamientos entre términos."
  },
  {
    "objectID": "func_enric_2.html#análisis-de-vecindad",
    "href": "func_enric_2.html#análisis-de-vecindad",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Análisis de Vecindad**",
    "text": "Análisis de Vecindad**\n\nTeoría\nEl análisis de vecindad se centra en el entorno local de la red que rodea a un gen o conjunto de genes de consulta. La idea es identificar funciones enriquecidas dentro de la “vecindad” de un conjunto de nodos en una red.\n\nVecindad Local: Los nodos directamente conectados al conjunto de consulta (vecinos de primer grado).\nVecindad Extendida: Nodos dentro de un radio definido (por ejemplo, vecinos de segundo o tercer grado).\nImplicaciones Funcionales: Los genes con funciones biológicas similares suelen estar estrechamente conectados, como lo respalda el principio de “culpabilidad por asociación” en las redes biológicas.\n\n\n\nPasos en el Enriquecimiento Basado en Vecindad\n\nDefinir el Conjunto de Consulta:\n\nLista de genes de entrada (por ejemplo, genes diferencialmente expresados).\nDefinir el radio o profundidad de la vecindad.\n\nConstruir la Red:\n\nFuente: Bases de datos públicas como STRING, BioGRID, o datos experimentales personalizados.\nNodos: Proteínas o genes.\nAristas: Interacciones como unión física o co-expresión.\n\nExtraer la Vecindad:\n\nIdentificar los vecinos de primer grado o expandir más allá.\nConstruir una subred.\n\nAnotación Funcional:\n\nRealizar análisis de enriquecimiento utilizando pruebas estadísticas.\n\nVisualizar los Resultados:\n\nResaltar el conjunto de consulta y los términos enriquecidos en la red.\n\n\n\n\n\nCódigo de Ejemplo: Análisis de Vecindad con igraph\nAquí se muestra cómo realizar un análisis de vecindad utilizando una red de ejemplo y datos funcionales simulados:\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:dplyr':\n\n    as_data_frame, groups, union\n\n\nThe following object is masked from 'package:IRanges':\n\n    union\n\n\nThe following object is masked from 'package:S4Vectors':\n\n    union\n\n\nThe following objects are masked from 'package:BiocGenerics':\n\n    normalize, path, union\n\n\nThe following object is masked from 'package:clusterProfiler':\n\n    simplify\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(igraph)\n\n# Step 1: Create a sparser network using Erdos-Renyi model\nset.seed(123)  # Set seed for reproducibility\nn &lt;- 20  # Number of nodes\ng &lt;- erdos.renyi.game(n = n, p = 0.2, directed = FALSE)  # 20 nodes, 20% chance of edge between any two nodes\n\nWarning: `erdos.renyi.game()` was deprecated in igraph 0.8.0.\nℹ Please use `sample_gnp()` instead.\n\n# Step 2: Assign character names to the nodes\nV(g)$name &lt;- paste(\"G\", 1:n, sep = \"\")  # Assign names G1, G2, ..., G20\n\n# Step 3: Visualize the complete network\nplot(g, vertex.label.color = \"black\", vertex.size = 30, \n     vertex.color = \"skyblue\", main = \"Sparse Gene Network (Erdos-Renyi)\",\n     vertex.label = V(g)$name)  # Use character labels for the nodes\n\n\n\n\n\n\n\n# Step 4: Select two or three query genes (nodes) by their names\nquery_genes &lt;- c(\"G1\", \"G5\", \"G10\")  # Use character labels for simplicity\n\n# Step 5: Extract the neighborhoods for each query gene (first-degree neighbors)\nneighborhoods &lt;- lapply(query_genes, function(gene) {\n  neighbors(g, gene)  # Extract first-degree neighbors\n})\n\n# Step 6: Create an induced subgraph for each query gene and it's neighbours\n\n# Command: induced_subgraph\n\n# Step 7: combine subgraphs if possible\n\n# Step 8: Visualize the graph with the subgraph genes highlighted\n\n# Hint - need to override the following:\nV(g)$color \n\nNULL\n\n\n\n\nAplicación en el Mundo Real\nEl análisis de vecindad puede identificar vías o procesos biológicos enriquecidos en la vecindad de un gen asociado a enfermedades. Ejemplos incluyen: - Investigación sobre el cáncer: Descubrir vías enriquecidas en la vecindad de oncogenes. - Neurobiología: Analizar redes alrededor de genes clave en enfermedades neurodegenerativas.\n\n\n\n\n2.2 Detección de Módulos\n\nTeoría\nLos módulos (o clústeres) son subestructuras dentro de una red que están estrechamente conectadas, a menudo representando unidades funcionales como complejos proteicos o vías de señalización. Al identificar módulos y probar su enriquecimiento, podemos descubrir patrones funcionales ocultos.\n\nDefinición: Un módulo es un grupo de nodos con una mayor densidad de aristas dentro del grupo en comparación con el exterior.\nRelevancia Biológica: Los módulos frecuentemente corresponden a vías biológicas o complejos.\n\n\n\nAlgoritmos de Clustering para Detección de Módulos\n\nMétodo Louvain:\n\nMaximiza la modularidad (una medida de la estructura comunitaria).\nAdecuado para redes de gran escala.\n\nAlgoritmo Walktrap:\n\nIdentifica comunidades basándose en caminatas aleatorias cortas.\nEficaz para redes más pequeñas.\n\nOtros Métodos:\n\nInfomap, Propagación de Etiquetas o Clustering Espectral.\n\n\n\n\n\nPasos en el Enriquecimiento Basado en Módulos\n\nIdentificar los módulos en la red.\nExtraer los nodos dentro de cada módulo.\nRealizar análisis de enriquecimiento para los términos funcionales de cada módulo.\n\n\n\n\nCódigo de Ejemplo: Detección de Módulos con igraph\n\n# Detect modules using Louvain\nlouvain_modules &lt;- cluster_louvain(g)\n\n# Assign colors to modules\nV(g)$color &lt;- louvain_modules$membership\n\n# Visualize the network with modules\nplot(g, vertex.label.color = \"black\", vertex.size = 30, \n     vertex.color = V(g)$color, main = \"Louvain Modules\")\n\n\n\n\n\n\n\n# Extract nodes from a module\n\n# Your turn! How can we get the genes for each of the modules, and use them to look for functional enrichment?\n\n\n\n\n\n2.3 Enriquecimiento Basado en Difusión\n\nTeoría\nLos métodos de difusión propagan la información desde los nodos de consulta hacia sus vecinos en la red, simulando la propagación de señales biológicas. Este enfoque resalta los nodos conectados indirectamente que pueden contribuir a vías funcionales.\n\nAplicaciones:\n\nPriorizar genes candidatos a enfermedades.\nEncontrar miembros novedosos de vías.\n\nMétodos: Caminatas aleatorias o técnicas de difusión de calor.\n\n\n\n\nCódigo de Ejemplo: Difusión por Caminata Aleatoria\n\n# Load igraph library\nlibrary(igraph)\n\n# Create a simple graph (you can modify this for your graph)\nset.seed(1)\ng &lt;- erdos.renyi.game(10, p = 0.3, directed = FALSE)\n\n# Set the starting node for the random walk (e.g., node 1)\nstart_node &lt;- 1\n\n# Function to perform random walk with restart\nrandom_walk_with_restart &lt;- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {\n  node_count &lt;- vcount(graph)\n  visited &lt;- rep(0, node_count)  # Vector to keep track of visits to each node\n  \n  for (walk in 1:walks) {\n    current_node &lt;- start_node\n    for (i in 1:steps) {\n      visited[current_node] &lt;- visited[current_node] + 1  # Mark the node as visited\n      \n      # Decide whether to restart or continue the random walk\n      if (runif(1) &lt; restart_prob) {\n        current_node &lt;- start_node  # Restart from the starting node\n      } else {\n        neighbors &lt;- neighbors(graph, current_node)  # Get neighbors of current node\n        if (length(neighbors) == 0) break  # Stop if no neighbors are left\n        current_node &lt;- sample(neighbors, 1)  # Choose a random neighbor to move to\n      }\n    }\n  }\n  \n  # Calculate probabilities\n  prob &lt;- visited / sum(visited)  # Normalize the visits to get probabilities\n  return(prob)\n}\n\n# Run the random walk with restart simulation\nset.seed(321)\nprobabilities &lt;- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)\n\n# Normalize the probabilities to create more distinct color contrasts\nprobabilities &lt;- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))\n\n# Set node colors: use a reversed color palette (red for high probability, blue for low probability)\nV(g)$color &lt;- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]\n\n# Highlight the start node with a different color (e.g., green)\nV(g)$color[start_node] &lt;- \"green\"\n\n# Increase the size of the start node for emphasis\nV(g)$size &lt;- ifelse(1:vcount(g) == start_node, 30, 20)\n\n# Plot the graph with improved color contrast\nplot(g, vertex.label = NA, main = \"Random Walk with Restart Diffusion on Graph\", \n     vertex.size = V(g)$size, vertex.color = V(g)$color)\n\n\n\n\n\n\n\n\n\n\n\nAplicación en el Mundo Real\n\nDescubrimiento de medicamentos: Identificación de dianas indirectos para fármacos mediante la propagación de genes de enfermedades a través de una red de interacción proteína-proteína.\nAnotación funcional: Asignación de funciones a genes no caracterizados basándose en sus perfiles de difusión."
  },
  {
    "objectID": "func_enric_2.html#concepto",
    "href": "func_enric_2.html#concepto",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Concepto",
    "text": "Concepto\nEl análisis basado en la topología de vías explora la estructura y la conectividad de las vías biológicas para identificar vías enriquecidas o alteradas en un conjunto de genes. Incorpora la conectividad de los genes y las proteínas dentro de las vías para mejorar la comprensión de los procesos biológicos.\nIdea clave: En lugar de centrarse solo en genes individuales, este enfoque evalúa cómo los genes están posicionados e interactúan dentro de las vías biológicas, considerando las relaciones entre los nodos (genes) y los bordes (interacciones)."
  },
  {
    "objectID": "func_enric_2.html#aplicaciones",
    "href": "func_enric_2.html#aplicaciones",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Aplicaciones",
    "text": "Aplicaciones\n\nIdentificación de vías alteradas en enfermedades: Este enfoque se puede usar para descubrir vías biológicas alteradas asociadas a enfermedades, analizando cambios en las interacciones y expresión génica.\nPriorización de vías para el desarrollo de fármacos: El análisis de la topología de vías puede guiar la identificación de posibles objetivos para fármacos, evaluando los nodos clave y las regiones regulatorias de las vías."
  },
  {
    "objectID": "func_enric_2.html#pathview-visualización-del-mapeo-de-conjuntos-de-genes-en-el-contexto-de-las-vías",
    "href": "func_enric_2.html#pathview-visualización-del-mapeo-de-conjuntos-de-genes-en-el-contexto-de-las-vías",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Pathview: Visualización del mapeo de conjuntos de genes en el contexto de las vías",
    "text": "Pathview: Visualización del mapeo de conjuntos de genes en el contexto de las vías\nPathview es un paquete de R que permite la visualización basada en vías y el análisis de conjuntos de genes. Mapea los datos de expresión u otros tipos de datos a los mapas de vías (por ejemplo, KEGG) y permite a los usuarios visualizar dónde están ubicados los genes dentro de la vía. Esto ayuda a entender si los cambios en la expresión génica están concentrados en partes clave de la vía o si están más dispersos.\n\nCómo mejora Pathview el análisis\n\nMapas de Vías: Pathview superpone los datos de expresión génica a los mapas de vías y resalta los genes según su posición en la vía. Esto permite visualizar si los genes de consulta están en regiones importantes de la vía (como puntos de control metabólicos o nodos regulatorios).\nPosicionamiento de Genes: Pathview ayuda a evaluar si los genes topológicamente importantes (aquellos en nodos centrales o hubs regulatorios) son afectados por el conjunto de genes de consulta.\nExpresión Diferencial: Pathview también se integra con los datos de expresión diferencial para resaltar genes sobreexpresados y subexpresados a lo largo de la red de la vía.\n\n\n\nCódigo de Ejemplo: Usando Pathview\nA continuación se muestra un ejemplo de cómo usar el paquete Pathview en R para visualizar datos de expresión génica en un mapa de vías:\n\n# Instalar y cargar el paquete pathview\nBiocManager::install(\"pathview\")\n\n'getOption(\"repos\")' replaces Bioconductor standard repositories, see\n'help(\"repositories\", package = \"BiocManager\")' for details.\nReplacement repositories:\n    CRAN: https://cloud.r-project.org\n\n\nBioconductor version 3.20 (BiocManager 1.30.25), R 4.4.2 (2024-10-31)\n\n\nInstallation paths not writeable, unable to update packages\n  path: /usr/lib/R/library\n  packages:\n    boot, class, cluster, codetools, foreign, KernSmooth, lattice, MASS,\n    Matrix, mgcv, nlme, nnet, rpart, spatial, survival\n  path: /usr/local/lib/R/site-library\n  packages:\n    optparse\n\n\nOld packages: 'bit', 'clusterProfiler', 'cpp11', 'curl', 'data.table',\n  'enrichplot', 'GenomeInfoDb', 'ggfun', 'ggtangle', 'igraph', 'IRanges',\n  'RcppArmadillo', 'RSQLite'\n\nlibrary(pathview)\n\n##############################################################################\nPathview is an open source software package distributed under GNU General\nPublic License version 3 (GPLv3). Details of GPLv3 is available at\nhttp://www.gnu.org/licenses/gpl-3.0.html. Particullary, users are required to\nformally cite the original Pathview paper (not just mention it) in publications\nor products. For details, do citation(\"pathview\") within R.\n\nThe pathview downloads and uses KEGG data. Non-academic uses may require a KEGG\nlicense agreement (details at http://www.kegg.jp/kegg/legal.html).\n##############################################################################\n\ndata(gse16873.d)\npv.out &lt;- pathview(gene.data = gse16873.d[, 1], pathway.id = \"04110\",\n                      species = \"hsa\", out.suffix = \"gse16873\")\n\n'select()' returned 1:1 mapping between keys and columns\n\n\nInfo: Working in directory /home/jim/BS\n\n\nInfo: Writing image file hsa04110.gse16873.png\n\n\n\n\nSalida: Visualización de Pathview\nPathview genera un mapa visual de la vía, con los genes resaltados según su nivel de expresión y su posición en la vía. Esto permite ver claramente las regiones de la vía que están más afectadas por el conjunto de genes. Escribe la salida a disco"
  },
  {
    "objectID": "func_enric_2.html#análisis-de-impacto-de-vías-de-señalización-spia",
    "href": "func_enric_2.html#análisis-de-impacto-de-vías-de-señalización-spia",
    "title": "Análisis de Enriquecimiento Funcional: Visualización y Métodos Avanzados",
    "section": "Análisis de Impacto de Vías de Señalización (SPIA)",
    "text": "Análisis de Impacto de Vías de Señalización (SPIA)\nAnálisis de Impacto de Vías de Señalización (SPIA) evalúa el impacto de los genes diferencialmente expresados (DEGs) sobre las vías biológicas. Combina la topología de la vía con la expresión génica para determinar el impacto general de un conjunto de genes en las vías, considerando tanto los efectos directos como los indirectos.\n\nObjetivo: Identificar las vías de señalización afectadas\nEl objetivo del SPIA es identificar qué vías de señalización están más afectadas por los cambios en la expresión génica. Este método es útil para comprender el contexto biológico más amplio de los cambios en la expresión génica, especialmente en estados patológicos.\n\n\nConcepto clave\nSPIA integra la estructura de la vía (topología) con los datos de expresión génica para calcular un puntaje de impacto para cada vía. La topología de la vía y la expresión diferencial de los genes determinan qué tan significativos son los cambios en la vía.\n\n\nEnfoque SPIA\n\nCambios en la Expresión Génica: La expresión diferencial (por ejemplo, el cambio de log fold) representa cómo los genes se ven afectados en el conjunto de genes de consulta. Estos cambios pueden ser positivos (sobrerregulados) o negativos (subregulados).\nTopología de la Vía: La topología de la vía representa las interacciones moleculares (nodos: genes, bordes: interacciones) dentro de la vía. Esta estructura dicta cómo los cambios en la expresión génica se propagan a través de la vía.\nPropagación de la Expresión: Los cambios en la expresión génica se propagan a través de la red, afectando a los genes y vías descendentes. Un gen que se encuentra centralmente en la vía tiene un mayor impacto en la actividad global de la vía que un gen ubicado en la periferia.\n\n\n\nCómo funciona SPIA\n\nPaso 1: Identificar los Genes Diferencialmente Expresados (DEGs)\nEl primer paso es identificar los genes de consulta que muestran cambios significativos en la expresión. Por lo general, estos genes provienen de un análisis de expresión diferencial, donde los cambios en el log fold indican genes sobreexpresados o subexpresados.\n\n\nPaso 2: Cálculo de la Topología y el Impacto\n\nTopología de la Vía: Los mapas de la vía (por ejemplo, KEGG o Reactome) proporcionan la estructura de las interacciones génicas.\nPropagación de la Expresión: Los cambios de expresión se propagan a lo largo de la red. Si un gen en la vía se ve afectado, los genes descendentes también se impactan según su posición en la red.\n\n\n\nPaso 3: Puntaje de Impacto de la Vía\nCada vía recibe un Puntaje de Impacto basado en la expresión diferencial y la estructura de la vía. El puntaje de impacto tiene en cuenta tanto:\n\nImpacto Directo: El impacto de los DEGs que afectan directamente a los nodos de la vía.\nImpacto Indirecto: Las conexiones de la vía (bordes) que influyen en la actividad general de la vía.\n\nEl análisis basado en la topología de vías es un enfoque poderoso para comprender cómo los genes están posicionados e interactúan dentro de las vías biológicas. Al usar herramientas como Pathview y SPIA, los investigadores pueden descubrir vías alteradas en enfermedades, priorizar vías para el desarrollo de fármacos y obtener información sobre el contexto biológico más amplio de los cambios en la expresión génica."
  },
  {
    "objectID": "clustering_2.html",
    "href": "clustering_2.html",
    "title": "Partición de grafos (II). Clustering basado en enlaces",
    "section": "",
    "text": "El análisis de comunidades en redes es una herramienta poderosa para entender la estructura de redes complejas. En redes biológicas como las redes de interacción proteína-proteína (PPI), redes de co-expresión génica o redes metabólicas, identificar comunidades revela grupos de nodos que interactúan fuertemente entre sí, lo cual es crucial para comprender funciones biológicas y patológicas. LinkComm es un algoritmo de clustering basado en enlaces, que se enfoca en la agrupación de enlaces en lugar de nodos, útil especialmente en redes biológicas complejas.\nDestaca la abilidad de encontrar un nodo en multiples comunidades, cosa que puede ocurrir en la naturaleza mucho.\n\n\n\nlinkcomm\n\n\n\n\nEl algoritmo LinkComm consta de dos pasos clave: 1. Cálculo de la Similitud de Enlaces: Calcula la similitud entre los enlaces de la red, basada en los nodos comunes que comparten. 2. Agrupación de Enlaces mediante Clustering Jerárquico: Utilizando el cálculo de similitudes, LinkComm agrupa los enlaces mediante clustering jerárquico, visualizándolos en un dendrograma. Posteriormente, se corta el dendrograma donde la densidad de partición es máxima para obtener las comunidades definitivas.\n\n\n\nLa similitud entre los enlaces \\((A, B)\\) y \\((A, C)\\) se basa en el número de nodos adyacentes que comparten \\(B\\) y \\(C\\), normalizado por el total de nodos adyacentes a \\(B\\) y \\(C\\). Para ello, se usa la siguiente fórmula basada en el trabajo de Ahn et al. (2010):\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{|N(B) \\cap N(C)|}{|N(B) \\cup N(C)|}\n\\]\nDonde: - \\(N(X)\\) representa el conjunto de nodos adyacentes a \\(X\\). - El numerador \\(|N(B) \\cap N(C)|\\) cuenta cuántos nodos comparten \\(B\\) y \\(C\\). - El denominador \\(|N(B) \\cup N(C)|\\) cuenta el total de nodos únicos asociados a \\(B\\) y \\(C\\).\n\n\nPara crear los ejemplos, nos hace falta una funcion para dibujar las redes:\n\n# Load igraph package\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# Function to generate and plot the network\ngenerate_network &lt;- function(edges, highlight_edges) {\n  # Create the graph\n  g &lt;- make_graph(edges, directed = FALSE)\n  \n  # Assign edge colors\n  edge_colors &lt;- rep(\"gray\", ecount(g))\n  \n  # Get edge names for comparison\n  edge_names &lt;- apply(as_edgelist(g), 1, function(x) paste(sort(x), collapse = \"-\"))\n  \n  # Highlight specified edges\n  for (i in seq_along(highlight_edges)) {\n    edge_to_highlight &lt;- paste(sort(highlight_edges[[i]]), collapse = \"-\")\n    edge_colors[which(edge_names == edge_to_highlight)] &lt;- c(\"blue\", \"red\")[i]\n  }\n  \n  # Plot the graph\n  plot(g, edge.color = edge_colors, vertex.size = 25, vertex.label.color = \"black\",\n       vertex.color = \"lightblue\", main = \"Network Visualization\")\n}\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 1: Baja Similitud\nedges_1 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_1 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_1, highlight_edges_1)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = 0\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{0}{3} = 0\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 2: Similitud Media\nedges_2 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_2 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_2, highlight_edges_2)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{E\\}| = 1\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{1}{3} \\approx 0.33\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E, F\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 3: Alta Similitud\nedges_3 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"B\", \"F\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_3 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_3, highlight_edges_3)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{E, F\\}| = 2\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{2}{3} \\approx 0.67\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E, F\\}\\)\n\\(N(C) = \\{D, E, F\\}\\)\n\n\n\n# Example 4: Similitud Máxima\nedges_4 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"B\", \"F\", \"A\", \"C\", \"C\", \"D\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_4 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_4, highlight_edges_4)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{D, E, F\\}| = 3\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{3}{3} = 1\n\\]\n\n\n\n\n\nUna vez que se han calculado las similitudes para todos los pares de enlaces, estas se almacenan en una matriz de distancias que se utiliza para realizar el clustering jerárquico. Es importante tener en cuenta que, al tratarse de pares contra pares en lugar de nodos contra nodos, esta matriz de distancias puede volverse bastante grande.\n\n\n\n\n\n\nComo de grande puede ser esta matriz?\n\n\n\n\n\n\nCuando pasamos de analizar combinaciones de nodos a combinaciones de enlaces, los requisitos de memoria aumentan significativamente. Esto se debe a que ahora trabajamos con una matriz donde cada fila y columna corresponde a un enlace, en lugar de un nodo. El número de enlaces en una red suele crecer mucho más rápido que el número de nodos, lo que genera una matriz más grande para almacenar.\nA continuación, comparamos el tamaño de la matriz de adyacencia de nodos con la matriz de similitud de enlaces. Para simplificar, asumimos que la red es no dirigida y que los enlaces son únicos (sin autoenlaces ni enlaces repetidos).\n\n\n\nPara un grafo con \\(n\\) nodos: - La matriz de adyacencia es de tamaño \\(n \\times n\\), lo que significa que tiene \\(n^2\\) elementos. - Memoria requerida en R: Cada elemento ocupa típicamente 8 bytes (tipo de dato numérico).\n\n\n\n\nPara un grafo con \\(n\\) nodos: - El número máximo de enlaces es \\(\\binom{n}{2} = \\frac{n(n-1)}{2}\\). - La matriz de similitud de enlaces es de tamaño \\(e \\times e\\), donde \\(e\\) es el número de enlaces. - Memoria requerida: Nuevamente, cada elemento ocupa 8 bytes.\n\nVeamos cálculos para redes con 1,000, 10,000 y 100,000 nodos, suponiendo que cada nodo tiene, en promedio, 10 enlaces (un supuesto razonable para muchas redes biológicas).\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 10,000 / 2 = 5,000\\).\nMatriz de adyacencia de nodos: \\(1,000 \\times 1,000 = 1,000,000\\) elementos (\\(1,000,000 \\times 8\\) bytes = 8 MB).\nMatriz de similitud de enlaces: \\(5,000 \\times 5,000 = 25,000,000\\) elementos (\\(25,000,000 \\times 8\\) bytes = 200 MB).\n\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 100,000 / 2 = 50,000\\).\nMatriz de adyacencia de nodos: \\(10,000 \\times 10,000 = 100,000,000\\) elementos (\\(100,000,000 \\times 8\\) bytes = 800 MB).\nMatriz de similitud de enlaces: \\(50,000 \\times 50,000 = 2,500,000,000\\) elementos (\\(2,500,000,000 \\times 8\\) bytes = 20 GB).\n\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 1,000,000 / 2 = 500,000\\).\nMatriz de adyacencia de nodos: \\(100,000 \\times 100,000 = 10,000,000,000\\) elementos (\\(10,000,000,000 \\times 8\\) bytes = 80 GB).\nMatriz de similitud de enlaces: \\(500,000 \\times 500,000 = 250,000,000,000\\) elementos (\\(250,000,000,000 \\times 8\\) bytes = 2,000 GB o ~2 TB).\n\n\n\n\n\n\nLa matriz de similitud de enlaces crece cuadráticamente con el número de enlaces, lo que genera enormes requisitos de memoria incluso para redes de tamaño moderado.\nEn contraste, la matriz de adyacencia de nodos crece cuadráticamente con el número de nodos, lo cual suele ser más manejable para grafos dispersos.\n\n\n\n\n\nEstos cálculos subrayan la necesidad de gestionar cuidadosamente los recursos de memoria y cómputo al trabajar con similitudes entre enlaces en redes grandes. Técnicas como el uso de almacenamiento disperso (sparse matrix) o el enfoque en un subconjunto de enlaces pueden ayudar a mitigar estos desafíos.\n\n\n\n\nA partir de este matriz, se construye un dendrograma, que organiza los enlaces según su similitud.\nSin embargo, para identificar las comunidades en la red, es necesario cortar el dendrograma a una altura específica, conocida como el punto de corte. Todas las ramas que se encuentran por debajo del punto de corte, es decir, los enlaces, se agrupan para formar comunidades.\nUn aspecto clave de este enfoque es que los enlaces, y no los nodos, son los objetos que se agrupan. Esto tiene una implicación importante: un mismo nodo puede estar presente en múltiples enlaces, lo que significa que puede pertenecer a más de una comunidad al mismo tiempo. Este comportamiento es diferente de otros métodos de partición de grafos, donde cada nodo pertenece exclusivamente a una única comunidad. Aquí, la pertenencia múltiple refleja la naturaleza compleja y sobrepuesta de las interacciones en redes reales, como las redes biológicas o sociales.\nPor ejemplo:\n- Si un nodo está conectado a diferentes grupos de nodos mediante enlaces que se asignan a comunidades distintas, ese nodo compartirá funciones o roles en múltiples contextos dentro de la red.\n\n\nEl siguiente ejemplo ilustra este punto mostrando cómo cortar el dendrograma genera comunidades de enlaces, y cómo un nodo puede pertenecer a varias comunidades:\n\n# Load necessary libraries\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(dendextend)\n\n\n---------------------\nWelcome to dendextend version 1.19.0\nType citation('dendextend') for how to cite the package.\n\nType browseVignettes(package = 'dendextend') for the package vignette.\nThe github page is: https://github.com/talgalili/dendextend/\n\nSuggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues\nYou may ask questions at stackoverflow, use the r and dendextend tags: \n     https://stackoverflow.com/questions/tagged/dendextend\n\n    To suppress this message use:  suppressPackageStartupMessages(library(dendextend))\n---------------------\n\n\n\nAttaching package: 'dendextend'\n\n\nThe following object is masked from 'package:stats':\n\n    cutree\n\n# Create a sample network\nedges &lt;- matrix(c(\"A\", \"B\", \"A\", \"C\", \"B\", \"C\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\", \"E\", \"F\"), ncol = 2, byrow = TRUE)\ng &lt;- graph_from_edgelist(edges, directed = FALSE)\n\n# Generate all edge pairs\nedge_list &lt;- as_edgelist(g)\nedge_pairs &lt;- combn(1:ecount(g), 2)\n\n# Calculate similarities between all pairs of edges\nsimilarities &lt;- apply(edge_pairs, 2, function(pair) {\n  e1 &lt;- edge_list[pair[1], ]  # First edge\n  e2 &lt;- edge_list[pair[2], ]  # Second edge\n  \n  # Neighbors of nodes in both edges\n  nodes_e1 &lt;- unique(unlist(neighborhood(g, order = 1, nodes = e1)))\n  nodes_e2 &lt;- unique(unlist(neighborhood(g, order = 1, nodes = e2)))\n  \n  # Calculate similarity\n  length(intersect(nodes_e1, nodes_e2)) / length(union(nodes_e1, nodes_e2))\n})\n\n# Build a symmetric similarity matrix\nsim_matrix &lt;- matrix(0, nrow = ecount(g), ncol = ecount(g))\nfor (i in seq_len(ncol(edge_pairs))) {\n  sim_matrix[edge_pairs[1, i], edge_pairs[2, i]] &lt;- similarities[i]\n  sim_matrix[edge_pairs[2, i], edge_pairs[1, i]] &lt;- similarities[i]  # Symmetric\n}\ndiag(sim_matrix) &lt;- 1  # Self-similarity is 1\n\n# Convert similarity to distance\ndist_matrix &lt;- as.dist(1 - sim_matrix)\n\n# Perform hierarchical clustering\nhc &lt;- hclust(dist_matrix, method = \"complete\")\n\n# Plot the dendrogram\ndd &lt;- as.dendrogram(hc)\nlabels(dd) &lt;- apply(edges, 1, function(x) paste(x[1], x[2], sep=\"_\"))[c(6,7,1,5,4,2,3)]\nplot(dd, main = \"Dendrograma de Enlaces\", xlab = \"Enlaces\", ylab = \"Altura\", sub = \"\")\n\n# Cut the tree at a specific height\ncut_height &lt;- 0.5\n# rect.hclust(hc, h = cut_height, border = \"red\")  # Highlight cut branches\nabline(h = cut_height, col = \"blue\", lty = 2)\n\n\n\n\n\n\n\n# Get clusters and Assign clusters to edges\nclusters &lt;- cutree(hc, h = cut_height)\nE(g)$community &lt;- clusters\nedge_colors &lt;- rainbow(length(unique(clusters)))[clusters]\n# Plot the network with edge communities\nplot(g, edge.color = edge_colors, vertex.color = \"gray\", vertex.label.color = \"black\",\n  main = \"Comunidades de Enlaces y Pertenencia Múltiple\")\n\n\n\n\n\n\n\n# Check node memberships\nnode_comms &lt;- list()\nfor (e in 1:ecount(g)) {\n  edge &lt;- ends(g, e)\n  for (node in edge) {\n    node_comms[[node]] &lt;- c(node_comms[[node]], clusters[e])\n  }\n}\nnode_comms &lt;- lapply(node_comms, unique) # Ensure unique memberships per node\nprint(node_comms)\n\n$A\n[1] 1\n\n$B\n[1] 1\n\n$C\n[1] 1\n\n$D\n[1] 1 2\n\n$E\n[1] 1 2\n\n$F\n[1] 2\n\n\n\n\n\n\nClustering jerárquico de enlaces: Se agrupan los enlaces según su similitud.\nCorte del dendrograma: El corte del árbol asigna cada enlace a una comunidad.\nAsignación múltiple de nodos: Los nodos se asocian a todas las comunidades de los enlaces en los que participan. Esto genera una estructura de pertenencia múltiple.\nVisualización: Los colores de los enlaces representan las comunidades, mientras que los nodos muestran cómo pueden participar en múltiples comunidades.\n\nEsta técnica es especialmente útil para analizar redes biológicas, donde las proteínas o genes a menudo participan en múltiples funciones o procesos interrelacionados.\n\n\n\n\nHay que cortar el árbol en un punto específico, determinado por donde se maximiza la densidad de partición.\n\n\nLa densidad de partición es una medida que evalúa qué tan densamente están conectados los conjuntos de enlaces (aristas) dentro de una red. A diferencia de las métricas centradas en los nodos, la densidad de partición se enfoca en la densidad interna de los subconjuntos de enlaces (es decir, comunidades de aristas) y permite cuantificar la cohesión de estas comunidades. Su definición, basada en la sección de métodos de Ahn et al. (2010), es la siguiente:\n\n\n\nPartición de la Red:\n\nPara una red con \\(M\\) enlaces (aristas), una partición \\(\\{P_1, \\dots, P_C\\}\\) divide los enlaces en \\(C\\) subconjuntos, donde cada subconjunto \\(P_c\\) tiene \\(m_c = |P_c|\\) enlaces y \\(n_c\\) nodos.\n\nDensidad Interna de Cada Subconjunto \\(P_c\\):\n\nLa densidad de partición \\(D_c\\) de un subconjunto \\(P_c\\) se define como: \\[\nD_c = \\frac{m_c - (n_c - 1)}{\\frac{1}{2}n_c(n_c - 1) - (n_c - 1)}\n\\]\nNumerador:\n\n\\(m_c\\): Número actual de enlaces en \\(P_c\\).\n\\(n_c - 1\\): Número mínimo de enlaces necesarios para conectar \\(n_c\\) nodos.\n\\(m_c - (n_c - 1)\\): Exceso de enlaces por encima del mínimo necesario, representando “densidad” dentro de la comunidad.\n\nDenominador:\n\n\\(\\frac{1}{2}n_c(n_c - 1)\\): Número máximo de enlaces posibles para \\(n_c\\) nodos (un subgrafo completamente conectado).\n\\(n_c - 1\\): Número mínimo de enlaces.\nEsto normaliza \\(m_c\\), asegurando que \\(D_c\\) esté entre 0 y 1:\n\n\\(D_c = 0\\): Cuando \\(P_c\\) está mínimamente conectado.\n\\(D_c = 1\\): Cuando \\(P_c\\) está completamente conectado.\n\n\n\nCasos Especiales:\n\n\\(D_c = 0\\) si \\(n_c = 2\\), ya que no es posible ninguna estructura interna más allá de un solo enlace.\n\nDensidad de Partición Total de la Red:\n\nLa densidad de partición \\(D\\) para toda la red es el promedio ponderado de \\(D_c\\) para todos los subconjuntos \\(\\{P_1, \\dots, P_C\\}\\), donde el peso depende de la fracción de enlaces en cada subconjunto: \\[\nD = \\frac{1}{M} \\sum_{c=1}^C m_c D_c\n\\]\n\\(m_c/M\\): Fracción de los enlaces totales presentes en el subconjunto \\(P_c\\).\nEsto asegura que \\(D\\) capture la tendencia general de la red hacia subconjuntos densamente conectados.\n\n\n\n\n\n\n\nLa densidad de partición evalúa qué tan bien los enlaces están agrupados en comunidades cohesivas y densamente conectadas, en comparación con el rango de conectividad posible para cada grupo.\nA diferencia de la modularidad, la densidad de partición no depende de un modelo nulo y mide directamente la conectividad interna de las comunidades.\n\n\n\n\nAmbas redes tendrán los mismos nodos, pero diferentes configuraciones de enlaces para ilustrar cómo cambia la densidad de partición.\n\n\n\nNodos: A, B, C, D, E.\nEnlaces: A-B, B-C, C-D, D-E (configuración tipo cadena lineal).\n\n\n\n\n\nNodos: A, B, C, D, E.\nEnlaces: A-B, A-C, A-D, A-E, B-C, B-D, C-D, C-E, D-E (subgrafo casi completo).\n\n\n\n\n\nlibrary(igraph)\n\n# Crear red de baja densidad\nnodes &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nedges_low &lt;- c(\"A\", \"B\", \"B\", \"C\", \"D\", \"E\")\nlow_density_net &lt;- make_graph(edges = edges_low, directed = FALSE)\n\n# Crear red de alta densidad\nedges_high &lt;- c(\"A\", \"B\", \"A\", \"C\", \"A\", \"D\", \"A\", \"E\",\n                \"B\", \"C\", \"B\", \"D\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\")\nhigh_density_net &lt;- make_graph(edges = edges_high, directed = FALSE)\n\n# Visualizar redes\nplot(low_density_net, main = \"Red de Baja Densidad\")\n\n\n\n\n\n\n\nplot(high_density_net, main = \"Red de Alta Densidad\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nRed de Baja Densidad: La densidad de partición será baja porque los enlaces forman una estructura lineal con muy pocos enlaces redundantes.\nRed de Alta Densidad: La densidad de partición será alta porque los enlaces forman un subgrafo casi completo con muchas conexiones internas.\n\n\n\n\n\n\nAhn, Y. Y., et al. (2010). Link communities reveal multiscale complexity in networks. Nature, 466(7307), 761–764. https://doi.org/10.1038/nature09182\nKalinka, A. T., et al. (2010). The LinkComm R package for community detection. Bioinformatics, 26(19), 2456–2457. https://doi.org/10.1093/bioinformatics/btq449"
  },
  {
    "objectID": "clustering_2.html#cómo-funciona-linkcomm",
    "href": "clustering_2.html#cómo-funciona-linkcomm",
    "title": "Partición de grafos (II). Clustering basado en enlaces",
    "section": "",
    "text": "El algoritmo LinkComm consta de dos pasos clave: 1. Cálculo de la Similitud de Enlaces: Calcula la similitud entre los enlaces de la red, basada en los nodos comunes que comparten. 2. Agrupación de Enlaces mediante Clustering Jerárquico: Utilizando el cálculo de similitudes, LinkComm agrupa los enlaces mediante clustering jerárquico, visualizándolos en un dendrograma. Posteriormente, se corta el dendrograma donde la densidad de partición es máxima para obtener las comunidades definitivas."
  },
  {
    "objectID": "clustering_2.html#cálculo-de-la-similitud-de-enlaces",
    "href": "clustering_2.html#cálculo-de-la-similitud-de-enlaces",
    "title": "Partición de grafos (II). Clustering basado en enlaces",
    "section": "",
    "text": "La similitud entre los enlaces \\((A, B)\\) y \\((A, C)\\) se basa en el número de nodos adyacentes que comparten \\(B\\) y \\(C\\), normalizado por el total de nodos adyacentes a \\(B\\) y \\(C\\). Para ello, se usa la siguiente fórmula basada en el trabajo de Ahn et al. (2010):\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{|N(B) \\cap N(C)|}{|N(B) \\cup N(C)|}\n\\]\nDonde: - \\(N(X)\\) representa el conjunto de nodos adyacentes a \\(X\\). - El numerador \\(|N(B) \\cap N(C)|\\) cuenta cuántos nodos comparten \\(B\\) y \\(C\\). - El denominador \\(|N(B) \\cup N(C)|\\) cuenta el total de nodos únicos asociados a \\(B\\) y \\(C\\).\n\n\nPara crear los ejemplos, nos hace falta una funcion para dibujar las redes:\n\n# Load igraph package\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# Function to generate and plot the network\ngenerate_network &lt;- function(edges, highlight_edges) {\n  # Create the graph\n  g &lt;- make_graph(edges, directed = FALSE)\n  \n  # Assign edge colors\n  edge_colors &lt;- rep(\"gray\", ecount(g))\n  \n  # Get edge names for comparison\n  edge_names &lt;- apply(as_edgelist(g), 1, function(x) paste(sort(x), collapse = \"-\"))\n  \n  # Highlight specified edges\n  for (i in seq_along(highlight_edges)) {\n    edge_to_highlight &lt;- paste(sort(highlight_edges[[i]]), collapse = \"-\")\n    edge_colors[which(edge_names == edge_to_highlight)] &lt;- c(\"blue\", \"red\")[i]\n  }\n  \n  # Plot the graph\n  plot(g, edge.color = edge_colors, vertex.size = 25, vertex.label.color = \"black\",\n       vertex.color = \"lightblue\", main = \"Network Visualization\")\n}\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 1: Baja Similitud\nedges_1 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_1 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_1, highlight_edges_1)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = 0\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{0}{3} = 0\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 2: Similitud Media\nedges_2 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_2 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_2, highlight_edges_2)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{E\\}| = 1\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{1}{3} \\approx 0.33\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E, F\\}\\)\n\\(N(C) = \\{E, F\\}\\)\n\n\n\n# Example 3: Alta Similitud\nedges_3 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"B\", \"F\", \"A\", \"C\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_3 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_3, highlight_edges_3)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{E, F\\}| = 2\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{2}{3} \\approx 0.67\n\\]\n\n\n\n\nEnlaces: \\(A-B\\) y \\(A-C\\)\nConjuntos de vecinos:\n\n\\(N(B) = \\{D, E, F\\}\\)\n\\(N(C) = \\{D, E, F\\}\\)\n\n\n\n# Example 4: Similitud Máxima\nedges_4 &lt;- c(\"A\", \"B\", \"B\", \"D\", \"B\", \"E\", \"B\", \"F\", \"A\", \"C\", \"C\", \"D\", \"C\", \"E\", \"C\", \"F\")\nhighlight_edges_4 &lt;- list(c(\"A\", \"B\"), c(\"A\", \"C\"))\ngenerate_network(edges_4, highlight_edges_4)\n\n\n\n\n\n\n\n\nCálculo: - Intersección: \\(|N(B) \\cap N(C)| = |\\{D, E, F\\}| = 3\\) - Unión: \\(|N(B) \\cup N(C)| = |\\{D, E, F\\}| = 3\\)\n\\[\n\\text{Similitud}(A-B, A-C) = \\frac{3}{3} = 1\n\\]"
  },
  {
    "objectID": "clustering_2.html#agrupación-de-enlaces-mediante-clustering-jerárquico",
    "href": "clustering_2.html#agrupación-de-enlaces-mediante-clustering-jerárquico",
    "title": "Partición de grafos (II). Clustering basado en enlaces",
    "section": "",
    "text": "Una vez que se han calculado las similitudes para todos los pares de enlaces, estas se almacenan en una matriz de distancias que se utiliza para realizar el clustering jerárquico. Es importante tener en cuenta que, al tratarse de pares contra pares en lugar de nodos contra nodos, esta matriz de distancias puede volverse bastante grande.\n\n\n\n\n\n\nComo de grande puede ser esta matriz?\n\n\n\n\n\n\nCuando pasamos de analizar combinaciones de nodos a combinaciones de enlaces, los requisitos de memoria aumentan significativamente. Esto se debe a que ahora trabajamos con una matriz donde cada fila y columna corresponde a un enlace, en lugar de un nodo. El número de enlaces en una red suele crecer mucho más rápido que el número de nodos, lo que genera una matriz más grande para almacenar.\nA continuación, comparamos el tamaño de la matriz de adyacencia de nodos con la matriz de similitud de enlaces. Para simplificar, asumimos que la red es no dirigida y que los enlaces son únicos (sin autoenlaces ni enlaces repetidos).\n\n\n\nPara un grafo con \\(n\\) nodos: - La matriz de adyacencia es de tamaño \\(n \\times n\\), lo que significa que tiene \\(n^2\\) elementos. - Memoria requerida en R: Cada elemento ocupa típicamente 8 bytes (tipo de dato numérico).\n\n\n\n\nPara un grafo con \\(n\\) nodos: - El número máximo de enlaces es \\(\\binom{n}{2} = \\frac{n(n-1)}{2}\\). - La matriz de similitud de enlaces es de tamaño \\(e \\times e\\), donde \\(e\\) es el número de enlaces. - Memoria requerida: Nuevamente, cada elemento ocupa 8 bytes.\n\nVeamos cálculos para redes con 1,000, 10,000 y 100,000 nodos, suponiendo que cada nodo tiene, en promedio, 10 enlaces (un supuesto razonable para muchas redes biológicas).\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 10,000 / 2 = 5,000\\).\nMatriz de adyacencia de nodos: \\(1,000 \\times 1,000 = 1,000,000\\) elementos (\\(1,000,000 \\times 8\\) bytes = 8 MB).\nMatriz de similitud de enlaces: \\(5,000 \\times 5,000 = 25,000,000\\) elementos (\\(25,000,000 \\times 8\\) bytes = 200 MB).\n\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 100,000 / 2 = 50,000\\).\nMatriz de adyacencia de nodos: \\(10,000 \\times 10,000 = 100,000,000\\) elementos (\\(100,000,000 \\times 8\\) bytes = 800 MB).\nMatriz de similitud de enlaces: \\(50,000 \\times 50,000 = 2,500,000,000\\) elementos (\\(2,500,000,000 \\times 8\\) bytes = 20 GB).\n\n\n\n\n\n\nNúmero de enlaces: \\(e = 10 \\cdot n / 2 = 1,000,000 / 2 = 500,000\\).\nMatriz de adyacencia de nodos: \\(100,000 \\times 100,000 = 10,000,000,000\\) elementos (\\(10,000,000,000 \\times 8\\) bytes = 80 GB).\nMatriz de similitud de enlaces: \\(500,000 \\times 500,000 = 250,000,000,000\\) elementos (\\(250,000,000,000 \\times 8\\) bytes = 2,000 GB o ~2 TB).\n\n\n\n\n\n\nLa matriz de similitud de enlaces crece cuadráticamente con el número de enlaces, lo que genera enormes requisitos de memoria incluso para redes de tamaño moderado.\nEn contraste, la matriz de adyacencia de nodos crece cuadráticamente con el número de nodos, lo cual suele ser más manejable para grafos dispersos.\n\n\n\n\n\nEstos cálculos subrayan la necesidad de gestionar cuidadosamente los recursos de memoria y cómputo al trabajar con similitudes entre enlaces en redes grandes. Técnicas como el uso de almacenamiento disperso (sparse matrix) o el enfoque en un subconjunto de enlaces pueden ayudar a mitigar estos desafíos.\n\n\n\n\nA partir de este matriz, se construye un dendrograma, que organiza los enlaces según su similitud.\nSin embargo, para identificar las comunidades en la red, es necesario cortar el dendrograma a una altura específica, conocida como el punto de corte. Todas las ramas que se encuentran por debajo del punto de corte, es decir, los enlaces, se agrupan para formar comunidades.\nUn aspecto clave de este enfoque es que los enlaces, y no los nodos, son los objetos que se agrupan. Esto tiene una implicación importante: un mismo nodo puede estar presente en múltiples enlaces, lo que significa que puede pertenecer a más de una comunidad al mismo tiempo. Este comportamiento es diferente de otros métodos de partición de grafos, donde cada nodo pertenece exclusivamente a una única comunidad. Aquí, la pertenencia múltiple refleja la naturaleza compleja y sobrepuesta de las interacciones en redes reales, como las redes biológicas o sociales.\nPor ejemplo:\n- Si un nodo está conectado a diferentes grupos de nodos mediante enlaces que se asignan a comunidades distintas, ese nodo compartirá funciones o roles en múltiples contextos dentro de la red.\n\n\nEl siguiente ejemplo ilustra este punto mostrando cómo cortar el dendrograma genera comunidades de enlaces, y cómo un nodo puede pertenecer a varias comunidades:\n\n# Load necessary libraries\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(dendextend)\n\n\n---------------------\nWelcome to dendextend version 1.19.0\nType citation('dendextend') for how to cite the package.\n\nType browseVignettes(package = 'dendextend') for the package vignette.\nThe github page is: https://github.com/talgalili/dendextend/\n\nSuggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues\nYou may ask questions at stackoverflow, use the r and dendextend tags: \n     https://stackoverflow.com/questions/tagged/dendextend\n\n    To suppress this message use:  suppressPackageStartupMessages(library(dendextend))\n---------------------\n\n\n\nAttaching package: 'dendextend'\n\n\nThe following object is masked from 'package:stats':\n\n    cutree\n\n# Create a sample network\nedges &lt;- matrix(c(\"A\", \"B\", \"A\", \"C\", \"B\", \"C\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\", \"E\", \"F\"), ncol = 2, byrow = TRUE)\ng &lt;- graph_from_edgelist(edges, directed = FALSE)\n\n# Generate all edge pairs\nedge_list &lt;- as_edgelist(g)\nedge_pairs &lt;- combn(1:ecount(g), 2)\n\n# Calculate similarities between all pairs of edges\nsimilarities &lt;- apply(edge_pairs, 2, function(pair) {\n  e1 &lt;- edge_list[pair[1], ]  # First edge\n  e2 &lt;- edge_list[pair[2], ]  # Second edge\n  \n  # Neighbors of nodes in both edges\n  nodes_e1 &lt;- unique(unlist(neighborhood(g, order = 1, nodes = e1)))\n  nodes_e2 &lt;- unique(unlist(neighborhood(g, order = 1, nodes = e2)))\n  \n  # Calculate similarity\n  length(intersect(nodes_e1, nodes_e2)) / length(union(nodes_e1, nodes_e2))\n})\n\n# Build a symmetric similarity matrix\nsim_matrix &lt;- matrix(0, nrow = ecount(g), ncol = ecount(g))\nfor (i in seq_len(ncol(edge_pairs))) {\n  sim_matrix[edge_pairs[1, i], edge_pairs[2, i]] &lt;- similarities[i]\n  sim_matrix[edge_pairs[2, i], edge_pairs[1, i]] &lt;- similarities[i]  # Symmetric\n}\ndiag(sim_matrix) &lt;- 1  # Self-similarity is 1\n\n# Convert similarity to distance\ndist_matrix &lt;- as.dist(1 - sim_matrix)\n\n# Perform hierarchical clustering\nhc &lt;- hclust(dist_matrix, method = \"complete\")\n\n# Plot the dendrogram\ndd &lt;- as.dendrogram(hc)\nlabels(dd) &lt;- apply(edges, 1, function(x) paste(x[1], x[2], sep=\"_\"))[c(6,7,1,5,4,2,3)]\nplot(dd, main = \"Dendrograma de Enlaces\", xlab = \"Enlaces\", ylab = \"Altura\", sub = \"\")\n\n# Cut the tree at a specific height\ncut_height &lt;- 0.5\n# rect.hclust(hc, h = cut_height, border = \"red\")  # Highlight cut branches\nabline(h = cut_height, col = \"blue\", lty = 2)\n\n\n\n\n\n\n\n# Get clusters and Assign clusters to edges\nclusters &lt;- cutree(hc, h = cut_height)\nE(g)$community &lt;- clusters\nedge_colors &lt;- rainbow(length(unique(clusters)))[clusters]\n# Plot the network with edge communities\nplot(g, edge.color = edge_colors, vertex.color = \"gray\", vertex.label.color = \"black\",\n  main = \"Comunidades de Enlaces y Pertenencia Múltiple\")\n\n\n\n\n\n\n\n# Check node memberships\nnode_comms &lt;- list()\nfor (e in 1:ecount(g)) {\n  edge &lt;- ends(g, e)\n  for (node in edge) {\n    node_comms[[node]] &lt;- c(node_comms[[node]], clusters[e])\n  }\n}\nnode_comms &lt;- lapply(node_comms, unique) # Ensure unique memberships per node\nprint(node_comms)\n\n$A\n[1] 1\n\n$B\n[1] 1\n\n$C\n[1] 1\n\n$D\n[1] 1 2\n\n$E\n[1] 1 2\n\n$F\n[1] 2\n\n\n\n\n\n\nClustering jerárquico de enlaces: Se agrupan los enlaces según su similitud.\nCorte del dendrograma: El corte del árbol asigna cada enlace a una comunidad.\nAsignación múltiple de nodos: Los nodos se asocian a todas las comunidades de los enlaces en los que participan. Esto genera una estructura de pertenencia múltiple.\nVisualización: Los colores de los enlaces representan las comunidades, mientras que los nodos muestran cómo pueden participar en múltiples comunidades.\n\nEsta técnica es especialmente útil para analizar redes biológicas, donde las proteínas o genes a menudo participan en múltiples funciones o procesos interrelacionados."
  },
  {
    "objectID": "clustering_2.html#densidad-de-partición-y-corte-del-dendrograma",
    "href": "clustering_2.html#densidad-de-partición-y-corte-del-dendrograma",
    "title": "Partición de grafos (II). Clustering basado en enlaces",
    "section": "",
    "text": "Hay que cortar el árbol en un punto específico, determinado por donde se maximiza la densidad de partición.\n\n\nLa densidad de partición es una medida que evalúa qué tan densamente están conectados los conjuntos de enlaces (aristas) dentro de una red. A diferencia de las métricas centradas en los nodos, la densidad de partición se enfoca en la densidad interna de los subconjuntos de enlaces (es decir, comunidades de aristas) y permite cuantificar la cohesión de estas comunidades. Su definición, basada en la sección de métodos de Ahn et al. (2010), es la siguiente:\n\n\n\nPartición de la Red:\n\nPara una red con \\(M\\) enlaces (aristas), una partición \\(\\{P_1, \\dots, P_C\\}\\) divide los enlaces en \\(C\\) subconjuntos, donde cada subconjunto \\(P_c\\) tiene \\(m_c = |P_c|\\) enlaces y \\(n_c\\) nodos.\n\nDensidad Interna de Cada Subconjunto \\(P_c\\):\n\nLa densidad de partición \\(D_c\\) de un subconjunto \\(P_c\\) se define como: \\[\nD_c = \\frac{m_c - (n_c - 1)}{\\frac{1}{2}n_c(n_c - 1) - (n_c - 1)}\n\\]\nNumerador:\n\n\\(m_c\\): Número actual de enlaces en \\(P_c\\).\n\\(n_c - 1\\): Número mínimo de enlaces necesarios para conectar \\(n_c\\) nodos.\n\\(m_c - (n_c - 1)\\): Exceso de enlaces por encima del mínimo necesario, representando “densidad” dentro de la comunidad.\n\nDenominador:\n\n\\(\\frac{1}{2}n_c(n_c - 1)\\): Número máximo de enlaces posibles para \\(n_c\\) nodos (un subgrafo completamente conectado).\n\\(n_c - 1\\): Número mínimo de enlaces.\nEsto normaliza \\(m_c\\), asegurando que \\(D_c\\) esté entre 0 y 1:\n\n\\(D_c = 0\\): Cuando \\(P_c\\) está mínimamente conectado.\n\\(D_c = 1\\): Cuando \\(P_c\\) está completamente conectado.\n\n\n\nCasos Especiales:\n\n\\(D_c = 0\\) si \\(n_c = 2\\), ya que no es posible ninguna estructura interna más allá de un solo enlace.\n\nDensidad de Partición Total de la Red:\n\nLa densidad de partición \\(D\\) para toda la red es el promedio ponderado de \\(D_c\\) para todos los subconjuntos \\(\\{P_1, \\dots, P_C\\}\\), donde el peso depende de la fracción de enlaces en cada subconjunto: \\[\nD = \\frac{1}{M} \\sum_{c=1}^C m_c D_c\n\\]\n\\(m_c/M\\): Fracción de los enlaces totales presentes en el subconjunto \\(P_c\\).\nEsto asegura que \\(D\\) capture la tendencia general de la red hacia subconjuntos densamente conectados.\n\n\n\n\n\n\n\nLa densidad de partición evalúa qué tan bien los enlaces están agrupados en comunidades cohesivas y densamente conectadas, en comparación con el rango de conectividad posible para cada grupo.\nA diferencia de la modularidad, la densidad de partición no depende de un modelo nulo y mide directamente la conectividad interna de las comunidades.\n\n\n\n\nAmbas redes tendrán los mismos nodos, pero diferentes configuraciones de enlaces para ilustrar cómo cambia la densidad de partición.\n\n\n\nNodos: A, B, C, D, E.\nEnlaces: A-B, B-C, C-D, D-E (configuración tipo cadena lineal).\n\n\n\n\n\nNodos: A, B, C, D, E.\nEnlaces: A-B, A-C, A-D, A-E, B-C, B-D, C-D, C-E, D-E (subgrafo casi completo).\n\n\n\n\n\nlibrary(igraph)\n\n# Crear red de baja densidad\nnodes &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nedges_low &lt;- c(\"A\", \"B\", \"B\", \"C\", \"D\", \"E\")\nlow_density_net &lt;- make_graph(edges = edges_low, directed = FALSE)\n\n# Crear red de alta densidad\nedges_high &lt;- c(\"A\", \"B\", \"A\", \"C\", \"A\", \"D\", \"A\", \"E\",\n                \"B\", \"C\", \"B\", \"D\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\")\nhigh_density_net &lt;- make_graph(edges = edges_high, directed = FALSE)\n\n# Visualizar redes\nplot(low_density_net, main = \"Red de Baja Densidad\")\n\n\n\n\n\n\n\nplot(high_density_net, main = \"Red de Alta Densidad\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nRed de Baja Densidad: La densidad de partición será baja porque los enlaces forman una estructura lineal con muy pocos enlaces redundantes.\nRed de Alta Densidad: La densidad de partición será alta porque los enlaces forman un subgrafo casi completo con muchas conexiones internas.\n\n\n\n\n\n\nAhn, Y. Y., et al. (2010). Link communities reveal multiscale complexity in networks. Nature, 466(7307), 761–764. https://doi.org/10.1038/nature09182\nKalinka, A. T., et al. (2010). The LinkComm R package for community detection. Bioinformatics, 26(19), 2456–2457. https://doi.org/10.1093/bioinformatics/btq449"
  }
]