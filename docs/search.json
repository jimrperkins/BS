[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Aqui encuentrarás la material para la sección de James R. Perkins en Biología de Sistemas, Grado en Ingeniería de la Salud, Universidad de Málaga"
  },
  {
    "objectID": "analisis_topo.html",
    "href": "analisis_topo.html",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "",
    "text": "La biología de sistemas se basa en el uso de redes para entender las interacciones complejas en sistemas biológicos. En este tutorial, exploraremos los conceptos fundamentales de grafos y redes utilizando el paquete igraph en R.\nPrimero, aseguramos de tener instalado el paquete igraph:\n\n\nUn grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos. Aquí, una arista se representa como un conjunto de nodos: \\(e = \\{u, v\\}\\).\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = k_4 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\n\nWarning: `graph()` was deprecated in igraph 2.1.0.\ni Please use `make_graph()` instead.\n\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(L\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 2) = 2.25\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo.html#qué-es-un-grafo",
    "href": "analisis_topo.html#qué-es-un-grafo",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "",
    "text": "Un grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos. Aquí, una arista se representa como un conjunto de nodos: \\(e = \\{u, v\\}\\).\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = k_4 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\n\nWarning: `graph()` was deprecated in igraph 2.1.0.\ni Please use `make_graph()` instead.\n\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(L\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 2) = 2.25\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo.html#tipos-de-modelos-random-de-grafos",
    "href": "analisis_topo.html#tipos-de-modelos-random-de-grafos",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Tipos de modelos “random” de grafos",
    "text": "Tipos de modelos “random” de grafos\n\nGrafo de isla\nCreamos un grafo simple para ilustrar la funcionalidad básica.\n\n# Crear un grafo de isla\nset.seed(42)\ng &lt;- sample_islands(3, 10, 5/10, 1)\nplot(g, vertex.label=V(g)$name, main=\"Grafo de Isla\")\n\n\n\n\n\n\n\n\nLa función sample_islands genera un grafo que representa un conjunto de islas. En este modelo, cada “isla” es un conjunto de nodos altamente conectados, y hay pocas conexiones entre las islas. Este tipo de red se utiliza a menudo para modelar sistemas donde existen grupos interconectados, pero con poca interacción entre esos grupos.\nCaracterísticas:\nNodos dentro de una isla están densamente conectados. Pocas o ninguna conexión entre islas. Se observa un alto coeficiente de clustering dentro de las islas (More on this later :).\n\n**Que son los argumentos de la funcion? Como afectan las propiedades del grafo producido?\n\n\n\nEjemplos de modelos de grafos aleatorios\n\nModelo de Erdős-Rényi\n\n\n# Grafo Erdős-Rényi\ng_er &lt;- erdos.renyi.game(100, p = 0.05)\n\nWarning: `erdos.renyi.game()` was deprecated in igraph 0.8.0.\ni Please use `sample_gnp()` instead.\n\nplot(g_er, vertex.size=5, main=\"Grafo Erdős-Rényi\")\n\n\n\n\n\n\n\n\nLa función sample_gnp genera un grafo aleatorio utilizando el modelo de Erdős-Rényi, donde se crea un grafo al agregar aristas de forma aleatoria entre un conjunto de nodos. Cada arista se incluye con una probabilidad p. Este modelo es útil para estudiar propiedades de grafos en general y es una buena representación de redes donde cada conexión es independiente.\nCaracterísticas:\nCada par de nodos tiene una probabilidad p de estar conectado. Puede generar redes densas o dispersas, dependiendo de p. Generalmente, presenta un coeficiente de clustering más bajo en comparación con redes altamente agrupadas (More on this later :).\n\nModelo de Barabási-Albert (scale-free)\n\n\n# Grafo Barabási-Albert\ng_ba &lt;- barabasi.game(100)\n\nWarning: `barabasi.game()` was deprecated in igraph 2.0.0.\ni Please use `sample_pa()` instead.\n\nplot(g_ba, vertex.size=5, main=\"Grafo Barabási-Albert\")\n\n\n\n\n\n\n\n\nLa función sample_pa genera un grafo siguiendo el modelo de Barabási-Albert, que es un modelo de red de escala libre. Este modelo simula el crecimiento de redes donde nuevos nodos se conectan a nodos existentes con una probabilidad proporcional a su grado, lo que significa que los nodos más conectados tienen más probabilidades de recibir nuevas conexiones.\nCaracterísticas:\nGenera redes de escala libre con una distribución de grado que sigue una ley de potencia (more later). Presenta nodos hubs (nodos con un grado alto). Centralidad de grado generalmente alta en nodos muy conectados (more on this later)."
  },
  {
    "objectID": "analisis_topo.html#personalización-de-redes-en-igraph",
    "href": "analisis_topo.html#personalización-de-redes-en-igraph",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Personalización de redes en igraph",
    "text": "Personalización de redes en igraph\nAun mas ejemplos de personalización de redes, combinando factores, en un solo bloque de código con comentarios explicativos.\n\n# Personalización de redes en igraph\n\n# Grafo de ejemplo\ng &lt;- erdos.renyi.game(20, p = 0.1)\n\n# Personalizar atributos de nodos\nV(g)$color &lt;- ifelse(degree(g) &gt; 2, \"red\", \"blue\")  # Color por grado\nV(g)$size &lt;- degree(g) * 3  # Tamaño de nodo proporcional al grado\nV(g)$label &lt;- paste0(\"Node:\", V(g))  # Etiquetas de nodos\n\n# Personalizar atributos de aristas\nE(g)$color &lt;- \"gray\"  # Color de aristas\nE(g)$width &lt;- 2  # Ancho de aristas\n\n# Graficar el grafo personalizado\nplot(g, vertex.label=V(g)$label, edge.arrow.size=0.5, \n     main=\"Grafo Personalizado: Atributos de Nodos y Aristas\")"
  },
  {
    "objectID": "analisis_topo.html#coeficiente-de-clustering-local",
    "href": "analisis_topo.html#coeficiente-de-clustering-local",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Coeficiente de Clustering local",
    "text": "Coeficiente de Clustering local\nEl coeficiente de clustering es una medida que indica la tendencia de los nodos en una red a agruparse en clústeres. Un alto coeficiente de clustering para un nodo (local) sugiere que un nodo es parte de una comunidad densa. En biología, esto puede ser relevante para estudiar interacciones entre proteínas, donde un alto coeficiente de clustering entre varios genes puede indicar una comunidad de proteínas que interactúan fuertemente entre sí.\nSe puede definir como:\n\\[\nC(v) = \\frac{2 \\times \\text{number of triangles through } v}{\\text{degree}(v) \\times (\\text{degree}(v) - 1)}\n\\]\nO quizas mas intuitivemente, puede definirse en términos de la proporción de triángulos presentes en el grafo en comparación con el número total de triángulos posibles que pueden formarse a partir de los vecinos de un nodo. Esta definición se centra en la noción de “triángulos” y se expresa como:\n\\[\nC(v) = \\frac{\\text{Número de triángulos en los vecinos de } v}{\\text{Número total de triángulos posibles entre los vecinos de } v}\n\\]\n\nInterpretación\n\nUn coeficiente de clustering cercano a 1 indica que los vecinos de un nodo están muy interconectados, formando un clúster denso.\nUn coeficiente de clustering cercano a 0 indica que los vecinos de un nodo están poco interconectados.\n\nEsta definición es útil para visualizar cómo las interacciones locales entre los nodos contribuyen a la estructura global de la red, y es especialmente relevante en el contexto de redes sociales y biológicas, donde se pueden observar grupos de interacciones fuertes entre ciertos nodos.\n\n\nCódigo para Calcular y Visualizar el Coeficiente de Clustering local\n\n# Crear una red aleatoria\nset.seed(42)\ng_clustering &lt;- erdos.renyi.game(n = 15, p = 0.15, directed = FALSE)\n\n# Calcular el coeficiente de clustering por nodo\nvertex_clustering &lt;- transitivity(g_clustering, type = \"local\")\nV(g_clustering)$color &lt;- ifelse(vertex_clustering &gt; 0, \"red\", \"lightblue\")\n\n# Visualizar la red con coeficiente de clustering - si los vecinos estan conectadas, se visualiza en rojo!\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = \"Coeficiente de Clustering Local\")"
  },
  {
    "objectID": "analisis_topo.html#coeficiente-de-clustering-global",
    "href": "analisis_topo.html#coeficiente-de-clustering-global",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Coeficiente de Clustering Global",
    "text": "Coeficiente de Clustering Global\n\nDefinición: El coeficiente de clustering global es una medida global que describe la tendencia general de la red de formar triángulos (conexiones entre tres nodos). Proporciona una visión general de la densidad de la red en términos de interacciones entre vecinos de los nodos.\nCálculo:\n\nUna forma común de calcular el coeficiente de clustering global es tomando el promedio de los coeficientes de clustering locales de todos los nodos en la red:\n\n\n\\[\n  C_{\\text{global}} = \\frac{1}{N} \\sum_{v \\in G} C(v)\n\\]\nDonde (N) es el número de nodos en el grafo y (C(v)) es el coeficiente de clustering local del nodo (v).\n\nAlternativamente, se puede definir como la relación entre el número de triángulos (tripletas de nodos completamente conectados) y el número de tripletas conectadas (un triplete es cualquier conjunto de 3 nodos conectados por 2 aristas):\n\n\\[ C\\_{\\text{global}} = \\frac{3 \\times \\text{Número de triángulos}}{\\text{Número de tripletas conectadas}} \\]\n\nInterpretación: Un coeficiente de clustering global cercano a 1 significa que la red está altamente agrupada (muchos nodos tienen coeficientes de clustering altos), mientras que un valor cercano a 0 sugiere que la red es más aleatoria, con menos agrupamientos locales.\n\n# Visualizar la red de antes al nivel GLOBAL\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = paste(\"Coeficiente de Clustering Global:\", round(clustering_coeff, 3)))\nEste código calcula e imprime tanto los coeficientes de clustering locales como el global de un pequeño grafo aleatorio y visualiza los nodos con tamaños ajustados según el coeficiente de clustering local, donde los nodos rojos tienen un coeficiente alto y los nodos azules tienen un coeficiente bajo.\n\nEjemplo en biología\nEn las redes de interacción de proteínas, los genes que codifican proteínas que interactúan entre sí tienden a formar grupos o módulos con un alto coeficiente de clustering. Esto es relevante para identificar vías metabólicas o complejos proteicos."
  },
  {
    "objectID": "analisis_topo.html#centralidad",
    "href": "analisis_topo.html#centralidad",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Centralidad",
    "text": "Centralidad\nLa centralidad se refiere a la importancia de un nodo dentro de una red. Existen varios tipos de centralidad, entre ellos:\n\nCentralidad de grado (degree centrality): Número de conexiones directas de un nodo.\n\n\\[\nC_g(v) = \\text{degree}(v)\n\\]\n\nCentralidad de Intermediación (Betweenness Centrality):\nLa centralidad de intermediación es una medida clave en la teoría de redes que indica cuántas veces un nodo actúa como “puente” o intermediario entre otros nodos. Es un concepto crucial para entender la estructura de la red en términos de control o flujo de información, recursos, o influencia a través de los nodos de la red.\n\nDefinición Matemática:\nLa centralidad de intermediación de un nodo \\(v\\) en una red se define como:\n\\[\nC_b(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n\\]\n\n\\(\\sigma_{st}\\) es el número total de caminos más cortos entre los nodos \\(s\\) y \\(t\\).\n\\(\\sigma_{st}(v\\) es el número de esos caminos más cortos que pasan por el nodo \\(v\\).\n\nLa centralidad de intermediación calcula, para un nodo dado, la fracción de caminos más cortos entre todos los pares de nodos \\(s\\) y \\(t\\) en la red que pasan a través de él. Cuanto mayor sea este valor, más “importante” es ese nodo en la red en términos de conectar diferentes partes de la misma.\n\n\n\nExplicación Conceptual:\nLa centralidad de intermediación mide el papel de un nodo como intermediario entre otros nodos de la red. Un nodo con una centralidad de intermediación alta es uno que está en el medio de muchos caminos más cortos entre otros nodos. Esencialmente, estos nodos tienen un poder significativo en términos de control del flujo de información o recursos a través de la red.\n\n\nRelevancia en Biología:\nEn el contexto biológico, la centralidad de intermediación tiene aplicaciones en varias áreas, como las redes de interacción proteína-proteína (PPI), las redes metabólicas, y las redes de regulación génica. Identificar los nodos con alta centralidad de intermediación puede ayudar a entender los puntos de control clave o los “puentes” que facilitan la comunicación entre diferentes partes de una red biológica.\n\nEjemplos en Biología:\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nEn una red de interacción proteína-proteína, las proteínas con alta centralidad de intermediación pueden ser aquellas que conectan diferentes “modulos” funcionales dentro de la red. Estas proteínas actúan como puntos de control para la transmisión de señales entre distintas funciones celulares. Si una proteína con alta centralidad de intermediación se ve afectada por mutaciones, podría tener un impacto significativo en varias vías biológicas o incluso en la enfermedad.\nEjemplo: En una red PPI de una célula humana, una proteína como TP53 (p53), que tiene un papel central en la regulación del ciclo celular y la respuesta al daño del ADN, podría tener una alta centralidad de intermediación. Si p53 se ve alterada o desregulada, puede afectar numerosas vías celulares relacionadas con el cáncer, como la apoptosis, la reparación del ADN y la regulación del ciclo celular.\n\nRedes Metabólicas:\n\nEn una red metabólica, un metabolito o enzima con alta centralidad de intermediación puede ser clave para conectar diversas rutas metabólicas. Estos metabolitos actúan como puentes entre diferentes procesos metabólicos, lo que permite una integración eficiente de los recursos celulares.\nEjemplo: El ATP (adenosín trifosfato), que es esencial para casi todas las reacciones bioquímicas celulares, puede actuar como un nodo con alta centralidad de intermediación en una red metabólica. La alteración de la producción o el uso de ATP afecta una multitud de rutas metabólicas y es crucial para la función celular.\n\nRedes de Regulación Génica:\n\nEn las redes de regulación génica, los factores de transcripción que conectan diferentes conjuntos de genes pueden tener una alta centralidad de intermediación. Estos factores de transcripción no solo regulan la expresión de un conjunto de genes, sino que también actúan como intermediarios para la integración de diversas señales celulares.\nEjemplo: El factor de transcripción NF-kB es un nodo con alta centralidad de intermediación en las redes de regulación génica. Controla la expresión de genes implicados en la respuesta inmune y en procesos inflamatorios. Si NF-kB está desregulado, puede contribuir a enfermedades como el cáncer, enfermedades autoinmunes y trastornos inflamatorios.\n\n\n\n\nCódigo R para Calcular y Visualizar la Centralidad de Intermediación:\n\nset.seed(123)\ng &lt;- erdos.renyi.game(10, p = 0.5)\n\n# Calculate betweenness centrality for all nodes\nbetweenness_centrality &lt;- betweenness(g)\n\n# Normalize the betweenness values for better visualization (optional)\nbetweenness_normalized &lt;- (betweenness_centrality - min(betweenness_centrality)) / \n    (max(betweenness_centrality) - min(betweenness_centrality))\n\n# Visualize the graph with nodes colored by betweenness centrality\nplot(g, \n     vertex.size = 20, \n     vertex.color = heat.colors(100, rev=TRUE)[round(betweenness_normalized * 99) + 1], # Color nodes based on centrality # Optionally remove labels\n     main = \"Graph colored by Betweenness Centrality\")"
  },
  {
    "objectID": "analisis_topo.html#propiedades-de-las-redes-de-escala-libre",
    "href": "analisis_topo.html#propiedades-de-las-redes-de-escala-libre",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Propiedades de las Redes de Escala Libre:",
    "text": "Propiedades de las Redes de Escala Libre:\n\n1. Distribución de Grado:\nLa distribución de grado en las redes de escala libre sigue una ley de potencia, lo que significa que el número de nodos con un cierto grado ( k ) (número de conexiones) disminuye rápidamente a medida que ( k ) aumenta. Matemáticamente, esto se expresa como:\n\\[\nP(k) \\sim k^{-\\gamma}\n\\]\nDonde:\n\n\\(P(k)\\) es la probabilidad de que un nodo tenga un grado \\(k\\).\n\\(k\\) es el grado de un nodo (el número de conexiones que tiene).\n\\(\\gamma\\) es el exponente de la ley de potencia, que típicamente se encuentra entre 2 y 3 en la mayoría de redes de escala libre.\n\nEste tipo de distribución es característica de redes autoorganizadas o generadas por crecimiento preferencial, donde nuevos nodos tienden a conectarse preferentemente a los nodos que ya están muy conectados. Esta propiedad genera hubs o nodos centrales, que son cruciales para la conectividad de la red.\n\nEjemplo en Biología: Redes de Interacción Proteína-Proteína (PPI)\nEn redes de interacción proteína-proteína (PPI), las proteínas más fundamentales para las funciones celulares tienden a tener un alto grado de conectividad, es decir, son hubs. Estas proteínas suelen ser las que orquestan múltiples procesos celulares, como la transcripción genética, la reparación del ADN y la señalización celular.\n\nEjemplo: BRCA1 (Breast Cancer 1) es una proteína clave en la reparación del ADN y en la regulación del ciclo celular. En las redes de interacción proteína-proteína (PPI), BRCA1 actúa como un hub, conectando muchas otras proteínas involucradas en procesos esenciales como la reparación del ADN, el control del ciclo celular, y la respuesta al daño genético. Debido a su papel central en estas vías, BRCA1 es crucial para la estabilidad genética de la célula.\n\nLa alteración o mutación de BRCA1 está asociada con un mayor riesgo de desarrollar cáncer de mama y ovario. Las mutaciones en BRCA1 afectan su capacidad para interactuar con otras proteínas de la red, lo que compromete la reparación del ADN y aumenta la probabilidad de que ocurran mutaciones genéticas que conduzcan al cáncer. En este caso, BRCA1 no solo es un hub en una red de interacciones, sino que también es un punto crítico para mantener la integridad genética celular.\n\n\n\n2. Centralidad y Robustez:\nUna de las características interesantes de las redes de escala libre es que, debido a la existencia de hubs, estas redes son robustas frente a fallos aleatorios. Esto significa que si se eliminan nodos de la red de manera aleatoria, la conectividad global de la red no se verá gravemente afectada, ya que los nodos de baja conectividad no son esenciales para la red. Sin embargo, si se atacan los hubs (nodos altamente conectados), la red puede volverse muy vulnerable, ya que la eliminación de estos nodos puede desconectar grandes partes de la red.\n\nEjemplo en Biología: Redes Neuronales\nEn las redes neuronales, los hubs son neuronas clave que conectan diferentes regiones del cerebro. La red de conectividad cerebral sigue una estructura de escala libre, donde ciertas neuronas tienen muchas conexiones con otras, permitiendo una comunicación eficiente entre regiones cerebrales distantes. Estas neuronas de alto grado son críticas para el procesamiento de información en el cerebro.\n\nEjemplo: El córtex prefrontal tiene neuronas de alta centralidad en las redes neuronales, que facilitan la integración de información de diferentes áreas cerebrales. Si se dañan estas neuronas (por ejemplo, en enfermedades neurodegenerativas), pueden ocurrir disfunciones cognitivas importantes.\n\n\n\n\n3. Vulnerabilidad a Ataques Dirigidos:\nDebido a su estructura jerárquica, las redes de escala libre son vulnerables a ataques dirigidos a los hubs. Al eliminar estos nodos clave, la conectividad de la red puede colapsar rápidamente, lo que afecta su funcionamiento global.\n\nEjemplo en biología: En las redes de interacción proteína-proteína, eliminar las proteínas clave (hubs) podría interrumpir varias vías biológicas simultáneamente, lo que llevaría a enfermedades o disfunciones celulares.\n\n\n\nEjemplo de Análisis de Redes de Escala Libre\nEn R, podemos generar y analizar una red de escala libre utilizando el modelo de Barabási-Albert (BA), que es un modelo clásico para generar redes de escala libre. A continuación se muestra un código en R que genera una red de escala libre y visualiza la distribución de grados:\n\n# Crear una red de escala libre usando el modelo de Barabási-Albert\ng_sf &lt;- barabasi.game(1000)\n\n# Obtener la distribución de grado\ndegree_distribution &lt;- degree(g_sf)\n\n# Visualizar la distribución de grado\nhist(degree_distribution, breaks=50, main=\"Distribución de Grado de una Red de Escala Libre\", \n     xlab=\"Grado\", ylab=\"Frecuencia\")"
  },
  {
    "objectID": "analisis_topo.html#modularity-en-redes",
    "href": "analisis_topo.html#modularity-en-redes",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Modularity en Redes",
    "text": "Modularity en Redes\nLa modularidad es una medida de la estructura de una red que evalúa la fortaleza de la división de la red en módulos o comunidades. Un módulo es un conjunto de nodos que están más densamente conectados entre sí en comparación con otros nodos de la red. La modularidad es útil para identificar comunidades o agrupamientos dentro de la red.\nLa modularidad se calcula comparando la densidad de conexiones dentro de los módulos con la que se esperaría en una red aleatoria con la misma distribución de grados.\n\nDefinición Matemática\nLa modularidad, ( Q ), de una partición en módulos se calcula usando la siguiente ecuación:\n\\[\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n\\]\ndonde: - \\(m\\) es el número total de aristas en la red. - \\(A_{ij}\\) es el valor en la posición \\((i, j)\\) de la matriz de adyacencia, donde \\(A_{ij} = 1\\) si hay una arista entre los nodos \\(i\\) y \\(j\\), y \\(0\\) en caso contrario. - \\(k_i\\) y \\(k_j\\) son los grados de los nodos \\(i\\) y \\(j\\), respectivamente. - \\(\\delta(c_i, c_j)\\) es la función delta de Kronecker, que es 1 si \\(c_i = c_j\\) (es decir, los nodos \\(i\\) y \\(j\\) están en el mismo módulo) y 0 en caso contrario.\nLa modularidad \\(Q\\) varía entre -1 y 1, donde valores cercanos a 1 indican una alta modularidad, es decir, una red con comunidades bien definidas. Valores cercanos a 0 o negativos indican una estructura comunitaria poco definida o inexistente.\nAquí tienes la sección revisada con dos ejemplos utilizando sample_islands, que ilustran redes con modularidad alta y baja. Esta función crea redes con distintas “islas” o comunidades y nos permite ajustar el número de nodos y el nivel de conectividad entre comunidades para observar el efecto en la modularidad."
  },
  {
    "objectID": "analisis_topo.html#modularidad-en-redes-y-su-cálculo-en-igraph",
    "href": "analisis_topo.html#modularidad-en-redes-y-su-cálculo-en-igraph",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Modularidad en Redes y su Cálculo en igraph",
    "text": "Modularidad en Redes y su Cálculo en igraph\nLa modularidad en redes se refiere a la tendencia de los nodos a agruparse en comunidades o módulos. Este concepto es fundamental en el análisis de redes complejas, ya que una modularidad alta indica que la red tiene comunidades bien definidas, donde las conexiones dentro de cada comunidad son densas y las conexiones entre comunidades son escasas. En biología, esta estructura modular es común en redes como las de interacción proteica y rutas metabólicas.\n\nEcuación de la Modularidad\nLa modularidad de una partición de la red en comunidades se calcula mediante la fórmula:\n[ Q = _{i,j} (c_i, c_j) ]\ndonde: - ( A_{ij} ) es la matriz de adyacencia de la red (1 si hay una conexión entre (i) y (j), 0 en caso contrario), - ( k_i ) y ( k_j ) son los grados de los nodos (i) y (j), - ( m ) es el número total de enlaces en la red, - ( (c_i, c_j) ) es una función que es 1 si los nodos (i) y (j) están en la misma comunidad y 0 en caso contrario.\nEsta ecuación permite calcular un valor de modularidad ( Q ) para evaluar qué tan bien definida está la estructura modular de una red.\n\n\nEjemplos de Redes con Alta y Baja Modularidad usando sample_islands\n\nEjemplo 1: Red con Alta Modularidad\nEn este ejemplo, crearemos una red con varias comunidades bien definidas, donde los nodos dentro de cada comunidad están fuertemente conectados entre sí, pero las conexiones entre comunidades son escasas. Esto genera una alta modularidad.\n\n# Cargar el paquete igraph\nlibrary(igraph)\n\n# Crear una red con alta modularidad usando sample_islands\nset.seed(3)\ng_high_modularity &lt;- sample_islands(islands.n=4, islands.size=10, islands.pin=0.8, n.inter=3)\n\n# Detectar comunidades usando el algoritmo de Louvain\ncommunity_high &lt;- cluster_louvain(g_high_modularity)\n\n# Calcular la modularidad\nmodularity_high &lt;- modularity(community_high)\ncat(\"Modularidad de la red con alta modularidad:\", modularity_high, \"\\n\")\n\nModularidad de la red con alta modularidad: 0.6414937 \n\n# Visualizar la red y las comunidades\nV(g_high_modularity)$color &lt;- membership(community_high)\nplot(g_high_modularity, vertex.color = V(g_high_modularity)$color, main = \"Red con Alta Modularidad\")\n\n\n\n\n\n\n\n\nEn este caso, la modularidad es alta, lo cual indica que la red presenta comunidades bien definidas, con muchos enlaces dentro de cada comunidad y pocos entre ellas. Este tipo de estructura es común en redes biológicas robustas, como las de interacción proteica en células especializadas.\n\n\nEjemplo 2: Red con Baja Modularidad\nA continuación, crearemos una red con menor modularidad, utilizando sample_islands con menos comunidades y mayor conectividad entre ellas. Esto reduce la modularidad, pues los nodos están más distribuidos y menos agrupados en módulos.\n\n# Crear una red con baja modularidad usando sample_islands\nset.seed(4)\ng_low_modularity &lt;- sample_islands(islands.n=4, islands.size=10, islands.pin=0.3, n.inter=5)\n\n# Detectar comunidades usando el algoritmo de Louvain\ncommunity_low &lt;- cluster_louvain(g_low_modularity)\n\n# Calcular la modularidad\nmodularity_low &lt;- modularity(community_low)\ncat(\"Modularidad de la red con baja modularidad:\", modularity_low, \"\\n\")\n\nModularidad de la red con baja modularidad: 0.4427343 \n\n# Visualizar la red y las comunidades\nV(g_low_modularity)$color &lt;- membership(community_low)\nplot(g_low_modularity, vertex.color = V(g_low_modularity)$color, main = \"Red con Baja Modularidad\")\n\n\n\n\n\n\n\n\nEn esta red, la modularidad es más baja debido a la mayor conectividad entre las comunidades, lo cual dificulta identificar módulos bien definidos. Redes de este tipo pueden aparecer en sistemas biológicos menos especializados o en procesos donde existe una integración funcional alta entre diferentes módulos, como en algunas redes metabólicas.\n\n\n\nInterpretación en Biología\nLa modularidad alta en redes biológicas es indicativa de una especialización funcional, donde cada módulo o comunidad realiza una función específica. Por otro lado, redes con baja modularidad pueden sugerir funciones integradas y sistemas menos especializados. En biología de sistemas, analizar la modularidad ayuda a descubrir módulos funcionales y a entender la organización jerárquica de los sistemas biológicos.\n\n\nDescripción del Código\n\nDetección de Comunidades: Utilizamos cluster_louvain para detectar comunidades en la red. Este algoritmo es eficiente para maximizar la modularidad y encontrar módulos bien definidos.\nCálculo de Modularidad: Con modularity(community), calculamos la modularidad de la partición de la red en comunidades. Esto nos da una medida de la calidad de la estructura de la red en términos de módulos.\nVisualización de Comunidades: Coloreamos los nodos de acuerdo con la comunidad a la que pertenecen usando membership(community) para facilitar la visualización de las divisiones de la red.\n\n\n\n\nInterpretación de Modularidad\nUn valor alto de modularidad sugiere que la red tiene una estructura de comunidad fuerte, con nodos más densamente conectados dentro de los módulos y menos conectados con nodos de otros módulos. La modularidad es especialmente útil en biología para identificar grupos funcionales de proteínas en redes de interacción o redes de coexpresión genética, donde los módulos pueden representar rutas o complejos funcionales."
  },
  {
    "objectID": "analisis_topo.html#modularidad-en-redes-biológicas-y-su-aplicación-en-biología-de-sistemas",
    "href": "analisis_topo.html#modularidad-en-redes-biológicas-y-su-aplicación-en-biología-de-sistemas",
    "title": "Análisis de grafos y topología de redes: Topología; Coef clustering; Centralidad, Modularidad. Introducción al uso de igraph y otros paquetes para crear y analizar redes",
    "section": "Modularidad en Redes Biológicas y su Aplicación en Biología de Sistemas",
    "text": "Modularidad en Redes Biológicas y su Aplicación en Biología de Sistemas\nEn biología, la modularidad es fundamental para analizar la organización de redes complejas, como redes de interacción proteica, redes de regulación genética y redes metabólicas. En estas redes, la modularidad ayuda a identificar complejos de proteínas, rutas metabólicas, y módulos funcionales que son esenciales para procesos celulares específicos. Estos módulos reflejan funciones biológicas que están integradas y muchas veces aisladas en cuanto a su función dentro de la célula, haciendo de la modularidad una herramienta poderosa para descubrir nuevas relaciones biológicas y entender la robustez de los sistemas.\n\nEjemplo 1: Red de Interacción Proteica\nEn una red de interacción proteica, los nodos representan proteínas y las aristas representan interacciones físicas entre ellas. Las proteínas suelen agruparse en complejos que funcionan conjuntamente en procesos celulares específicos. Al analizar la modularidad de esta red, se pueden identificar módulos que representan estos complejos proteicos.\nCódigo en igraph para analizar una red de interacción proteica simulada:\n\n# Crear una red simulada con estructura modular, representando interacción proteica\nset.seed(1)\ng_protein &lt;- sample_pa(50, m = 3, directed = FALSE)\n\n# Detectar comunidades en la red de interacción proteica usando el algoritmo de Louvain\ncommunity_protein &lt;- cluster_louvain(g_protein)\n\n# Calcular la modularidad de la partición\nmodularity_protein &lt;- modularity(community_protein)\ncat(\"Modularidad de la red de interacción proteica:\", modularity_protein, \"\\n\")\n\nModularidad de la red de interacci&lt;U+00F3&gt;n proteica: 0.3002508 \n\n# Visualizar la red y las comunidades\nV(g_protein)$color &lt;- membership(community_protein)\nplot(g_protein, vertex.color = V(g_protein)$color, main = \"Red de Interacción Proteica con Comunidades\")\n\n\n\n\n\n\n\n\nEn este ejemplo, cada módulo (comunidad) detectado podría corresponder a un complejo proteico. La modularidad cuantifica la efectividad de esta división y sugiere una estructura comunitaria bien definida si el valor es alto, lo cual es común en redes biológicas debido a la especialización de funciones.\n\n\nEjemplo 2: Red Metabólica\nEn una red metabólica, los nodos representan metabolitos y las aristas representan reacciones bioquímicas que convierten un metabolito en otro. La modularidad en este contexto puede ayudar a identificar rutas metabólicas o subconjuntos de metabolitos y reacciones que forman un proceso metabólico completo, como la glucólisis o el ciclo del ácido cítrico.\nCódigo en igraph para analizar una red metabólica simulada:\n\n# Crear una red metabólica simulada con estructura modular\nset.seed(2)\ng_metabolic &lt;- sample_smallworld(1, 50, 4, 0.05)\n\n# Detectar comunidades en la red metabólica usando el algoritmo de Louvain\ncommunity_metabolic &lt;- cluster_louvain(g_metabolic)\n\n# Calcular la modularidad de la partición\nmodularity_metabolic &lt;- modularity(community_metabolic)\ncat(\"Modularidad de la red metabólica:\", modularity_metabolic, \"\\n\")\n\nModularidad de la red metab&lt;U+00F3&gt;lica: 0.518775 \n\n# Visualizar la red y las comunidades\nV(g_metabolic)$color &lt;- membership(community_metabolic)\nplot(g_metabolic, vertex.color = V(g_metabolic)$color, main = \"Red Metabólica con Comunidades\")\n\n\n\n\n\n\n\n\nEn este ejemplo, las comunidades o módulos identificados por la modularidad pueden representar rutas metabólicas en las cuales los metabolitos y reacciones están funcionalmente conectados. Esto permite el análisis de las interacciones metabólicas y cómo se organizan en la red celular.\n\n\nInterpretación en Biología de Sistemas\nLa modularidad es particularmente relevante en biología de sistemas para modelar la organización funcional de las redes biológicas y su robustez. Las redes altamente modulares tienden a ser más robustas frente a perturbaciones, ya que los módulos actúan de manera relativamente independiente. Por ejemplo: - En redes de interacción genética, los módulos pueden representar genes que participan en rutas reguladoras específicas. - En redes de señalización celular, la modularidad permite identificar cascadas de señalización, lo que ayuda a comprender cómo las células responden a estímulos externos de manera organizada.\nLa modularidad, al permitir identificar estas estructuras funcionales dentro de la red, ayuda a los investigadores a proponer nuevas hipótesis sobre el funcionamiento de los sistemas biológicos y la evolución de su organización."
  },
  {
    "objectID": "minimal_analysis.html",
    "href": "minimal_analysis.html",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "",
    "text": "Este es un ejemplo mínimo del análisis de un término HPO utilizando técnicas de biología de sistemas para comprender mejor los mecanismos subyacentes, incluyendo los pasos más importantes en el flujo de trabajo del análisis. Comenzamos con un término HPO, “morfología anormal del corpúsculo renal”, y sugerimos procesos subyacentes importantes, como el sistema inmunológico y las vías del complemento; la mitocondria, la respiración aeróbica y la producción de ATP. Sin embargo, existen muchas formas en que se puede ampliar el análisis. Puedes cambiar el umbral de puntuación utilizado para obtener interacciones de STRINGdb, agregar genes adicionales basados en interacciones con genes asociados a fenotipos conocidos, investigar otros métodos de agrupación, explorar otras bases de datos y fuentes de anotación para el análisis de enriquecimiento, o considerar herramientas adicionales de visualización, otras metricas, etc."
  },
  {
    "objectID": "minimal_analysis.html#descarga-manual",
    "href": "minimal_analysis.html#descarga-manual",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "Descarga Manual",
    "text": "Descarga Manual\n\nNavega al sitio web de la Ontología de Fenotipos Humanos (HPO).\nBusca abnormal renal corpuscle morphology en la barra de búsqueda.\nHaz clic en el fenotipo para ver los detalles.\nLocaliza la lista de genes asociados y descárgala en formato de texto (Export Associations).\n\nANOTA el codigo HPO del fenotipo, nos va a hacer falta para el siguiente paso:"
  },
  {
    "objectID": "minimal_analysis.html#uso-de-la-api",
    "href": "minimal_analysis.html#uso-de-la-api",
    "title": "Flujo de análisis mínimo para un término HPO",
    "section": "Uso de la API",
    "text": "Uso de la API\n\n¿Qué es una API?\nUna Interfaz de Programación de Aplicaciones (API) permite que diferentes aplicaciones de software se comuniquen entre sí. En nuestro caso, nos permite acceder programáticamente a datos de la HPO. Puedes usar una API para obtener automáticamente la lista de genes sin tener que descargarla manualmente. PUEDES USAR OTRAS LENGUAJES DE PROGAMACION SI PREFERIS\nPara usar la API, aquí hay un ejemplo de cómo obtener genes programáticamente. Primero, necesitamos instalar y cargar las bibliotecas necesarias:\n\n# Install necessary packages if not already installed\nif (!requireNamespace(\"httr\", quietly = TRUE)) {\n  install.packages(\"httr\")\n}\nif (!requireNamespace(\"jsonlite\", quietly = TRUE)) {\n  install.packages(\"jsonlite\")\n}\n\nlibrary(httr)\nlibrary(jsonlite)\n\n# API request to get genes associated with the HPO term for abnormal renal corpuscle morphology\nhpo_id &lt;- \"HP:0031263\"  # HPO ID for abnormal renal corpuscle morphology\n\nurl &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id)\n\nresponse &lt;- GET(url)\ndata &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\ngenes &lt;- fromJSON(data)$genes\n\n# Display the first few genes\nhead(genes)\n\n               id    name\n1    NCBIGene:396 ARHGDIA\n2   NCBIGene:1286  COL4A4\n3   NCBIGene:1285  COL4A3\n4  NCBIGene:57728   WDR19\n5   NCBIGene:3075     CFH\n6 NCBIGene:254428 SLC41A1\n\n# Display all the genes (uncomment)\n# print(genes)"
  },
  {
    "objectID": "analisis_topo_2.html",
    "href": "analisis_topo_2.html",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "",
    "text": "La biología de sistemas se basa en el uso de redes para entender las interacciones complejas en sistemas biológicos. En este tutorial, exploraremos los conceptos fundamentales de grafos y redes utilizando el paquete igraph en R.\nPrimero, aseguramos de tener instalado el paquete igraph:\n\n\nUn grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos. Aquí, una arista se representa como un conjunto de nodos: \\(e = \\{u, v\\}\\).\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = k_4 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\n\nWarning: `graph()` was deprecated in igraph 2.1.0.\ni Please use `make_graph()` instead.\n\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(L\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 2) = 2.25\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo_2.html#qué-es-un-grafo",
    "href": "analisis_topo_2.html#qué-es-un-grafo",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "",
    "text": "Un grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos. Aquí, una arista se representa como un conjunto de nodos: \\(e = \\{u, v\\}\\).\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = k_4 = 2\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\n\nWarning: `graph()` was deprecated in igraph 2.1.0.\ni Please use `make_graph()` instead.\n\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(L\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 2) = 2.25\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo ( i ) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo_2.html#tipos-de-modelos-random-de-grafos",
    "href": "analisis_topo_2.html#tipos-de-modelos-random-de-grafos",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Tipos de modelos “random” de grafos",
    "text": "Tipos de modelos “random” de grafos\n\nGrafo de isla\nCreamos un grafo simple para ilustrar la funcionalidad básica.\n\n# Crear un grafo de isla\nset.seed(42)\ng &lt;- sample_islands(3, 10, 5/10, 1)\nplot(g, vertex.label=V(g)$name, main=\"Grafo de Isla\")\n\n\n\n\n\n\n\n\nLa función sample_islands genera un grafo que representa un conjunto de islas. En este modelo, cada “isla” es un conjunto de nodos altamente conectados, y hay pocas conexiones entre las islas. Este tipo de red se utiliza a menudo para modelar sistemas donde existen grupos interconectados, pero con poca interacción entre esos grupos.\nCaracterísticas:\nNodos dentro de una isla están densamente conectados. Pocas o ninguna conexión entre islas. Se observa un alto coeficiente de clustering dentro de las islas (More on this later :).\n\n**Que son los argumentos de la funcion? Como afectan las propiedades del grafo producido?\n\n\n\nEjemplos de modelos de grafos aleatorios\n\nModelo de Erdős-Rényi\n\n\n# Grafo Erdős-Rényi\ng_er &lt;- erdos.renyi.game(100, p = 0.05)\n\nWarning: `erdos.renyi.game()` was deprecated in igraph 0.8.0.\ni Please use `sample_gnp()` instead.\n\nplot(g_er, vertex.size=5, main=\"Grafo Erdős-Rényi\")\n\n\n\n\n\n\n\n\nLa función sample_gnp genera un grafo aleatorio utilizando el modelo de Erdős-Rényi, donde se crea un grafo al agregar aristas de forma aleatoria entre un conjunto de nodos. Cada arista se incluye con una probabilidad p. Este modelo es útil para estudiar propiedades de grafos en general y es una buena representación de redes donde cada conexión es independiente.\nCaracterísticas:\nCada par de nodos tiene una probabilidad p de estar conectado. Puede generar redes densas o dispersas, dependiendo de p. Generalmente, presenta un coeficiente de clustering más bajo en comparación con redes altamente agrupadas (More on this later :).\n\nModelo de Barabási-Albert (scale-free)\n\n\n# Grafo Barabási-Albert\ng_ba &lt;- barabasi.game(100)\n\nWarning: `barabasi.game()` was deprecated in igraph 2.0.0.\ni Please use `sample_pa()` instead.\n\nplot(g_ba, vertex.size=5, main=\"Grafo Barabási-Albert\")\n\n\n\n\n\n\n\n\nLa función sample_pa genera un grafo siguiendo el modelo de Barabási-Albert, que es un modelo de red de escala libre. Este modelo simula el crecimiento de redes donde nuevos nodos se conectan a nodos existentes con una probabilidad proporcional a su grado, lo que significa que los nodos más conectados tienen más probabilidades de recibir nuevas conexiones.\nCaracterísticas:\nGenera redes de escala libre con una distribución de grado que sigue una ley de potencia (more later). Presenta nodos hubs (nodos con un grado alto). Centralidad de grado generalmente alta en nodos muy conectados (more on this later)."
  },
  {
    "objectID": "analisis_topo_2.html#personalización-de-redes-en-igraph",
    "href": "analisis_topo_2.html#personalización-de-redes-en-igraph",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Personalización de redes en igraph",
    "text": "Personalización de redes en igraph\nAun mas ejemplos de personalización de redes, combinando factores, en un solo bloque de código con comentarios explicativos.\n\n# Personalización de redes en igraph\n\n# Grafo de ejemplo\ng &lt;- erdos.renyi.game(20, p = 0.1)\n\n# Personalizar atributos de nodos\nV(g)$color &lt;- ifelse(degree(g) &gt; 2, \"red\", \"blue\")  # Color por grado\nV(g)$size &lt;- degree(g) * 3  # Tamaño de nodo proporcional al grado\nV(g)$label &lt;- paste0(\"Node:\", V(g))  # Etiquetas de nodos\n\n# Personalizar atributos de aristas\nE(g)$color &lt;- \"gray\"  # Color de aristas\nE(g)$width &lt;- 2  # Ancho de aristas\n\n# Graficar el grafo personalizado\nplot(g, vertex.label=V(g)$label, edge.arrow.size=0.5, \n     main=\"Grafo Personalizado: Atributos de Nodos y Aristas\")"
  },
  {
    "objectID": "analisis_topo_2.html#coeficiente-de-clustering-local",
    "href": "analisis_topo_2.html#coeficiente-de-clustering-local",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Coeficiente de Clustering local",
    "text": "Coeficiente de Clustering local\nEl coeficiente de clustering es una medida que indica la tendencia de los nodos en una red a agruparse en clústeres. Un alto coeficiente de clustering para un nodo (local) sugiere que un nodo es parte de una comunidad densa. En biología, esto puede ser relevante para estudiar interacciones entre proteínas, donde un alto coeficiente de clustering entre varios genes puede indicar una comunidad de proteínas que interactúan fuertemente entre sí.\nSe puede definir como:\n\\[\nC(v) = \\frac{2 \\times \\text{number of triangles through } v}{\\text{degree}(v) \\times (\\text{degree}(v) - 1)}\n\\]\nO quizas mas intuitivemente, puede definirse en términos de la proporción de triángulos presentes en el grafo en comparación con el número total de triángulos posibles que pueden formarse a partir de los vecinos de un nodo. Esta definición se centra en la noción de “triángulos” y se expresa como:\n\\[\nC(v) = \\frac{\\text{Número de triángulos en los vecinos de } v}{\\text{Número total de triángulos posibles entre los vecinos de } v}\n\\]\n\nInterpretación\n\nUn coeficiente de clustering cercano a 1 indica que los vecinos de un nodo están muy interconectados, formando un clúster denso.\nUn coeficiente de clustering cercano a 0 indica que los vecinos de un nodo están poco interconectados.\n\nEsta definición es útil para visualizar cómo las interacciones locales entre los nodos contribuyen a la estructura global de la red, y es especialmente relevante en el contexto de redes sociales y biológicas, donde se pueden observar grupos de interacciones fuertes entre ciertos nodos.\n\n\nCódigo para Calcular y Visualizar el Coeficiente de Clustering local\n\n# Crear una red aleatoria\nset.seed(42)\ng_clustering &lt;- erdos.renyi.game(n = 15, p = 0.15, directed = FALSE)\n\n# Calcular el coeficiente de clustering por nodo\nvertex_clustering &lt;- transitivity(g_clustering, type = \"local\")\nV(g_clustering)$color &lt;- ifelse(vertex_clustering &gt; 0, \"red\", \"lightblue\")\n\n# Visualizar la red con coeficiente de clustering - si los vecinos estan conectadas, se visualiza en rojo!\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = \"Coeficiente de Clustering Local\")"
  },
  {
    "objectID": "analisis_topo_2.html#coeficiente-de-clustering-global",
    "href": "analisis_topo_2.html#coeficiente-de-clustering-global",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Coeficiente de Clustering Global",
    "text": "Coeficiente de Clustering Global\n\nDefinición: El coeficiente de clustering global es una medida global que describe la tendencia general de la red de formar triángulos (conexiones entre tres nodos). Proporciona una visión general de la densidad de la red en términos de interacciones entre vecinos de los nodos.\nCálculo:\n\nUna forma común de calcular el coeficiente de clustering global es tomando el promedio de los coeficientes de clustering locales de todos los nodos en la red:\n\n\n\\[\n  C_{\\text{global}} = \\frac{1}{N} \\sum_{v \\in G} C(v)\n\\]\nDonde (N) es el número de nodos en el grafo y (C(v)) es el coeficiente de clustering local del nodo (v).\n\nAlternativamente, se puede definir como la relación entre el número de triángulos (tripletas de nodos completamente conectados) y el número de tripletas conectadas (un triplete es cualquier conjunto de 3 nodos conectados por 2 aristas):\n\n\\[ C\\_{\\text{global}} = \\frac{3 \\times \\text{Número de triángulos}}{\\text{Número de tripletas conectadas}} \\]\n\nInterpretación: Un coeficiente de clustering global cercano a 1 significa que la red está altamente agrupada (muchos nodos tienen coeficientes de clustering altos), mientras que un valor cercano a 0 sugiere que la red es más aleatoria, con menos agrupamientos locales.\n\n# Visualizar la red de antes al nivel GLOBAL\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = paste(\"Coeficiente de Clustering Global:\", round(clustering_coeff, 3)))\nEste código calcula e imprime tanto los coeficientes de clustering locales como el global de un pequeño grafo aleatorio y visualiza los nodos con tamaños ajustados según el coeficiente de clustering local, donde los nodos rojos tienen un coeficiente alto y los nodos azules tienen un coeficiente bajo.\n\nEjemplo en biología\nEn las redes de interacción de proteínas, los genes que codifican proteínas que interactúan entre sí tienden a formar grupos o módulos con un alto coeficiente de clustering. Esto es relevante para identificar vías metabólicas o complejos proteicos."
  },
  {
    "objectID": "analisis_topo_2.html#centralidad",
    "href": "analisis_topo_2.html#centralidad",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Centralidad",
    "text": "Centralidad\nLa centralidad se refiere a la importancia de un nodo dentro de una red. Existen varios tipos de centralidad, entre ellos:\n\nCentralidad de grado (degree centrality): Número de conexiones directas de un nodo.\n\n\\[\nC_g(v) = \\text{degree}(v)\n\\]\n\nCentralidad de Intermediación (Betweenness Centrality):\nLa centralidad de intermediación es una medida clave en la teoría de redes que indica cuántas veces un nodo actúa como “puente” o intermediario entre otros nodos. Es un concepto crucial para entender la estructura de la red en términos de control o flujo de información, recursos, o influencia a través de los nodos de la red.\n\nDefinición Matemática:\nLa centralidad de intermediación de un nodo \\(v\\) en una red se define como:\n\\[\nC_b(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n\\]\n\n\\(\\sigma_{st}\\) es el número total de caminos más cortos entre los nodos \\(s\\) y \\(t\\).\n\\(\\sigma_{st}(v\\) es el número de esos caminos más cortos que pasan por el nodo \\(v\\).\n\nLa centralidad de intermediación calcula, para un nodo dado, la fracción de caminos más cortos entre todos los pares de nodos \\(s\\) y \\(t\\) en la red que pasan a través de él. Cuanto mayor sea este valor, más “importante” es ese nodo en la red en términos de conectar diferentes partes de la misma.\n\n\n\nExplicación Conceptual:\nLa centralidad de intermediación mide el papel de un nodo como intermediario entre otros nodos de la red. Un nodo con una centralidad de intermediación alta es uno que está en el medio de muchos caminos más cortos entre otros nodos. Esencialmente, estos nodos tienen un poder significativo en términos de control del flujo de información o recursos a través de la red.\n\n\nRelevancia en Biología:\nEn el contexto biológico, la centralidad de intermediación tiene aplicaciones en varias áreas, como las redes de interacción proteína-proteína (PPI), las redes metabólicas, y las redes de regulación génica. Identificar los nodos con alta centralidad de intermediación puede ayudar a entender los puntos de control clave o los “puentes” que facilitan la comunicación entre diferentes partes de una red biológica.\n\nEjemplos en Biología:\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nEn una red de interacción proteína-proteína, las proteínas con alta centralidad de intermediación pueden ser aquellas que conectan diferentes “modulos” funcionales dentro de la red. Estas proteínas actúan como puntos de control para la transmisión de señales entre distintas funciones celulares. Si una proteína con alta centralidad de intermediación se ve afectada por mutaciones, podría tener un impacto significativo en varias vías biológicas o incluso en la enfermedad.\nEjemplo: En una red PPI de una célula humana, una proteína como TP53 (p53), que tiene un papel central en la regulación del ciclo celular y la respuesta al daño del ADN, podría tener una alta centralidad de intermediación. Si p53 se ve alterada o desregulada, puede afectar numerosas vías celulares relacionadas con el cáncer, como la apoptosis, la reparación del ADN y la regulación del ciclo celular.\n\nRedes Metabólicas:\n\nEn una red metabólica, un metabolito o enzima con alta centralidad de intermediación puede ser clave para conectar diversas rutas metabólicas. Estos metabolitos actúan como puentes entre diferentes procesos metabólicos, lo que permite una integración eficiente de los recursos celulares.\nEjemplo: El ATP (adenosín trifosfato), que es esencial para casi todas las reacciones bioquímicas celulares, puede actuar como un nodo con alta centralidad de intermediación en una red metabólica. La alteración de la producción o el uso de ATP afecta una multitud de rutas metabólicas y es crucial para la función celular.\n\nRedes de Regulación Génica:\n\nEn las redes de regulación génica, los factores de transcripción que conectan diferentes conjuntos de genes pueden tener una alta centralidad de intermediación. Estos factores de transcripción no solo regulan la expresión de un conjunto de genes, sino que también actúan como intermediarios para la integración de diversas señales celulares.\nEjemplo: El factor de transcripción NF-kB es un nodo con alta centralidad de intermediación en las redes de regulación génica. Controla la expresión de genes implicados en la respuesta inmune y en procesos inflamatorios. Si NF-kB está desregulado, puede contribuir a enfermedades como el cáncer, enfermedades autoinmunes y trastornos inflamatorios.\n\n\n\n\nCódigo R para Calcular y Visualizar la Centralidad de Intermediación:\n\nset.seed(123)\ng &lt;- erdos.renyi.game(10, p = 0.5)\n\n# Calculate betweenness centrality for all nodes\nbetweenness_centrality &lt;- betweenness(g)\n\n# Normalize the betweenness values for better visualization (optional)\nbetweenness_normalized &lt;- (betweenness_centrality - min(betweenness_centrality)) / \n    (max(betweenness_centrality) - min(betweenness_centrality))\n\n# Visualize the graph with nodes colored by betweenness centrality\nplot(g, \n     vertex.size = 20, \n     vertex.color = heat.colors(100, rev=TRUE)[round(betweenness_normalized * 99) + 1], # Color nodes based on centrality # Optionally remove labels\n     main = \"Graph colored by Betweenness Centrality\")"
  },
  {
    "objectID": "analisis_topo_2.html#propiedades-de-las-redes-de-escala-libre",
    "href": "analisis_topo_2.html#propiedades-de-las-redes-de-escala-libre",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Propiedades de las Redes de Escala Libre:",
    "text": "Propiedades de las Redes de Escala Libre:\n\n1. Distribución de Grado:\nLa distribución de grado en las redes de escala libre sigue una ley de potencia, lo que significa que el número de nodos con un cierto grado ( k ) (número de conexiones) disminuye rápidamente a medida que ( k ) aumenta. Matemáticamente, esto se expresa como:\n\\[\nP(k) \\sim k^{-\\gamma}\n\\]\nDonde:\n\n\\(P(k)\\) es la probabilidad de que un nodo tenga un grado \\(k\\).\n\\(k\\) es el grado de un nodo (el número de conexiones que tiene).\n\\(\\gamma\\) es el exponente de la ley de potencia, que típicamente se encuentra entre 2 y 3 en la mayoría de redes de escala libre.\n\nEste tipo de distribución es característica de redes autoorganizadas o generadas por crecimiento preferencial, donde nuevos nodos tienden a conectarse preferentemente a los nodos que ya están muy conectados. Esta propiedad genera hubs o nodos centrales, que son cruciales para la conectividad de la red.\n\nEjemplo en Biología: Redes de Interacción Proteína-Proteína (PPI)\nEn redes de interacción proteína-proteína (PPI), las proteínas más fundamentales para las funciones celulares tienden a tener un alto grado de conectividad, es decir, son hubs. Estas proteínas suelen ser las que orquestan múltiples procesos celulares, como la transcripción genética, la reparación del ADN y la señalización celular.\n\nEjemplo: BRCA1 (Breast Cancer 1) es una proteína clave en la reparación del ADN y en la regulación del ciclo celular. En las redes de interacción proteína-proteína (PPI), BRCA1 actúa como un hub, conectando muchas otras proteínas involucradas en procesos esenciales como la reparación del ADN, el control del ciclo celular, y la respuesta al daño genético. Debido a su papel central en estas vías, BRCA1 es crucial para la estabilidad genética de la célula.\n\nLa alteración o mutación de BRCA1 está asociada con un mayor riesgo de desarrollar cáncer de mama y ovario. Las mutaciones en BRCA1 afectan su capacidad para interactuar con otras proteínas de la red, lo que compromete la reparación del ADN y aumenta la probabilidad de que ocurran mutaciones genéticas que conduzcan al cáncer. En este caso, BRCA1 no solo es un hub en una red de interacciones, sino que también es un punto crítico para mantener la integridad genética celular.\n\n\n\n2. Centralidad y Robustez:\nUna de las características interesantes de las redes de escala libre es que, debido a la existencia de hubs, estas redes son robustas frente a fallos aleatorios. Esto significa que si se eliminan nodos de la red de manera aleatoria, la conectividad global de la red no se verá gravemente afectada, ya que los nodos de baja conectividad no son esenciales para la red. Sin embargo, si se atacan los hubs (nodos altamente conectados), la red puede volverse muy vulnerable, ya que la eliminación de estos nodos puede desconectar grandes partes de la red.\n\nEjemplo en Biología: Redes Neuronales\nEn las redes neuronales, los hubs son neuronas clave que conectan diferentes regiones del cerebro. La red de conectividad cerebral sigue una estructura de escala libre, donde ciertas neuronas tienen muchas conexiones con otras, permitiendo una comunicación eficiente entre regiones cerebrales distantes. Estas neuronas de alto grado son críticas para el procesamiento de información en el cerebro.\n\nEjemplo: El córtex prefrontal tiene neuronas de alta centralidad en las redes neuronales, que facilitan la integración de información de diferentes áreas cerebrales. Si se dañan estas neuronas (por ejemplo, en enfermedades neurodegenerativas), pueden ocurrir disfunciones cognitivas importantes.\n\n\n\n\n3. Vulnerabilidad a Ataques Dirigidos:\nDebido a su estructura jerárquica, las redes de escala libre son vulnerables a ataques dirigidos a los hubs. Al eliminar estos nodos clave, la conectividad de la red puede colapsar rápidamente, lo que afecta su funcionamiento global.\n\nEjemplo en biología: En las redes de interacción proteína-proteína, eliminar las proteínas clave (hubs) podría interrumpir varias vías biológicas simultáneamente, lo que llevaría a enfermedades o disfunciones celulares.\n\n\n\nEjemplo de Análisis de Redes de Escala Libre\nEn R, podemos generar y analizar una red de escala libre utilizando el modelo de Barabási-Albert (BA), que es un modelo clásico para generar redes de escala libre. A continuación se muestra un código en R que genera una red de escala libre y visualiza la distribución de grados:\n\n# Cargar la librería igraph\nlibrary(igraph)\n\n# Crear una red de escala libre usando el modelo de Barabási-Albert\ng_sf &lt;- barabasi.game(1000)\n\n# Obtener la distribución de grado\ndegree_distribution &lt;- degree(g_sf)\n\n# Visualizar la distribución de grado\nhist(degree_distribution, breaks=50, main=\"Distribución de Grado de una Red de Escala Libre\", \n     xlab=\"Grado\", ylab=\"Frecuencia\")"
  },
  {
    "objectID": "analisis_topo_1.html",
    "href": "analisis_topo_1.html",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "",
    "text": "La biología de sistemas se basa en el uso de redes para entender las interacciones complejas en sistemas biológicos. En este tutorial, exploraremos los conceptos fundamentales de grafos y redes utilizando el paquete igraph en R.\nPrimero, aseguramos de tener instalado el paquete igraph:\n\n\nUn grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos.\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = 2\\), \\(k_4 = 1\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(E\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 1) = 2\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo \\(i\\) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- make_graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos.\n\n\n\n\nAntes de generar redes aleatorias, exploraremos un ejemplo de una red que consta de cinco nodos y seis aristas. Este ejemplo nos ayudará a entender cómo se pueden visualizar diferentes aspectos de una red.\n\n\n\n# Crear un grafo con 5 nodos y 6 aristas\ng_vis_examples &lt;- make_graph(c(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\"), directed = FALSE)\n\n# Visualizar la red básica\nplot(g_vis_examples, vertex.label = V(g_vis_examples)$name, main = \"Red para Visualizar\")\n\n\n\n\n\n\n\n\n\n\n\nEn una red cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\). Una table de pares de nodos se puede llamar como un “from-to list”.\nLa matriz de adyacencia es otra representación que indica la conexión entre los nodos. Se define como una matriz cuadrada \\(A\\) donde \\(A[i, j] = 1\\) si hay una arista entre el nodo \\(i\\) y el nodo \\(j\\), y \\(A[i, j] = 0\\) en caso contrario.\n\n# Convertir el grafo en data.frame con formato \"from-to\"\n\n# Convertir el grafo en una matriz de adyacencia\nadjacency_matrix &lt;- as.matrix(as_adjacency_matrix(g_vis_examples))\n\n# Mostrar la matriz de adyacencia\nadjacency_matrix\n\n  A B C D E\nA 0 1 1 0 0\nB 1 0 0 1 0\nC 1 0 0 1 1\nD 0 1 1 0 1\nE 0 0 1 1 0\n\n\nMatrices de adjacencia estan en general mas facil trabajar con ellos: mas facil hacer operaciones matematicas (aplicación de álgebra matricial) Tambien ofrecen acceso rápido a conexiones - no hay que traversar una lista.\nPero, sobre todo en redes grandes, pueden ser ineficiente - tienen \\(N x N\\) dimensiones, y en redes biologicas, la gran mayoria pueden ser ceros\nPor ejemplo, Si una red tiene 1,000 nodos, una matriz de adyacencia requeriría 1,000^2 =1,000,000 entradas, independientemente de cuántas conexiones realmente existan entre los nodos. Aunque solo una fracción de estas entradas podría representar enlaces reales, todas las celdas deben almacenarse en la memoria.\nTambien existe representaciones sparse, por ejemplo en R:\n\n# Instala el paquete si aún no está instalado\nif (!requireNamespace(\"Matrix\", quietly = TRUE)) {\n  install.packages(\"Matrix\")\n}\n# Cargar el paquete Matrix\nlibrary(Matrix)\n\n# Crear una matriz dispersa\n# Definimos una matriz de 5x5 con solo algunos enlaces\nadj_matrix &lt;- Matrix(c(0, 1, 0, 0, 1,\n                       1, 0, 1, 0, 0,\n                       0, 1, 0, 1, 0,\n                       0, 0, 1, 0, 1,\n                       1, 0, 0, 1, 0), \n                     nrow = 5, ncol = 5, sparse = TRUE)\n\n# Mostrar la matriz dispersa\nprint(adj_matrix)\n\n5 x 5 sparse Matrix of class \"dsCMatrix\"\n              \n[1,] . 1 . . 1\n[2,] 1 . 1 . .\n[3,] . 1 . 1 .\n[4,] . . 1 . 1\n[5,] 1 . . 1 .\n\n# igraph ahora usa matrices sparse por definicion:\nprint(as_adjacency_matrix(g_vis_examples))\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n  A B C D E\nA . 1 1 . .\nB 1 . . 1 .\nC 1 . . 1 1\nD . 1 1 . 1\nE . . 1 1 .\n\n\nPorque usa menos memoria el sparse matrix?\nUna matriz dispersa (o sparse matrix) utiliza menos memoria porque solo almacena los elementos no cero y sus posiciones, mientras que una matriz densa almacena todos los elementos, incluidos los ceros.\n\n# Cargar el paquete Matrix\nlibrary(Matrix)\n\n# Crear una matriz de adyacencia 20000x20000 en base R (estimada no. genes en genoma humano segun un articulo famoso)\n# Han estimado 650000 interacciones entre estos genes\nset.seed(42)\ndense_matrix &lt;- matrix(0, nrow = 20000, ncol = 20000)\npositions &lt;- sample(1:(1000*1000), size = 650000)  # Solo 650000 conexiones\ndense_matrix[positions] &lt;- 1\n\n# Mostrar el tamaño en memoria de la matriz densa\ndense_matrix_size &lt;- object.size(dense_matrix)\nprint(paste(\"Tamaño de la matriz densa:\", format(dense_matrix_size, units = \"auto\")))\n\n[1] \"Tama&lt;U+00F1&gt;o de la matriz densa: 3 Gb\"\n\n# Convertir la matriz densa a una matriz dispersa\nsparse_matrix &lt;- as(dense_matrix, \"sparseMatrix\")\n\n# Mostrar el tamaño en memoria de la matriz dispersa\nsparse_matrix_size &lt;- object.size(sparse_matrix)\nprint(paste(\"Tamaño de la matriz dispersa:\", format(sparse_matrix_size, units = \"auto\")))\n\n[1] \"Tama&lt;U+00F1&gt;o de la matriz dispersa: 7.5 Mb\"\n\n\n\n\n\nA continuación, se presentan diez maneras diferentes de visualizar la misma red, modificando colores, tipos de aristas y otros parámetros:\n\nColores de Nodos Diferentes\n\n\nplot(g_vis_examples, vertex.color = c(\"red\", \"green\", \"blue\", \"orange\", \"purple\"), vertex.label = V(g_vis_examples)$name, main = \"Colores de Nodos Diferentes\")\n\n\n\n\n\n\n\n\n\nTamaño de Nodos Basado en Grado\n\n\nvertex_sizes &lt;- degree(g_vis_examples) * 5\nplot(g_vis_examples, vertex.size = vertex_sizes, vertex.label = V(g_vis_examples)$name, main = \"Tamaño de Nodos Basado en Grado\")\n\n\n\n\n\n\n\n\n\nTipo de Arista Diferente (dotted)\n\n\nplot(g_vis_examples, edge.lty = \"dotted\", vertex.label = V(g_vis_examples)$name, main = \"Aristas Dotted\")\n\n\n\n\n\n\n\n\n\nColores de Aristas Diferentes\n\n\nplot(g_vis_examples, edge.color = \"purple\", vertex.label = V(g_vis_examples)$name, main = \"Colores de Aristas Diferentes\")\n\n\n\n\n\n\n\n\n\nEstructura Circular\n\n\nplot(g_vis_examples, layout = layout_in_circle, vertex.label = V(g_vis_examples)$name, main = \"Estructura Circular\")\n\n\n\n\n\n\n\n# No se ver muy bien - vamos a ver mejro\n# Crear un grafo aleatorio con 20 nodos y un número específico de aristas\nset.seed(1)\ng_20 &lt;- sample_gnp(20, p = 0.2)  # Generar una red aleatoria\n\n# Visualizar la red en un layout circular\nplot(g_20, layout = layout_in_circle, vertex.label = V(g_20)$name, \n     vertex.color = \"lightblue\", edge.color = \"gray\", main = \"Red Circular con 20 Nodos\")\n\n\n\n\n\n\n\n\n\nEstructura de Grid\n\n\nplot(g_vis_examples, layout = layout_on_grid, vertex.label = V(g_vis_examples)$name, main = \"Estructura de Grid\")\n\n\n\n\n\n\n\nplot(g_20, layout = layout_on_grid, vertex.label = V(g_20)$name, \n     vertex.color = \"lightgreen\", edge.color = \"gray\", main = \"Red Grid con 20 Nodos\")\n\n\n\n\n\n\n\n\n\nColores de Nodos según Grado\n\n\n# Calcular el grado para cada nodo\ndegree_values &lt;- degree(g_20)\n# Normalizar los valores del grado para que estén entre 0 y 1\ndegree_normalized &lt;- (degree_values - min(degree_values)) / (max(degree_values) - min(degree_values))\n# Asignar colores según el grado\n# Usaremos un gradiente de colores de azul (bajo grado) a rojo (alto grado)\nnode_colors &lt;- colorRampPalette(c(\"blue\", \"red\"))(length(degree_normalized))[rank(degree_normalized)]\n# Graficar el grafo\nplot(g_20, vertex.color = node_colors, main = \"Grafo con Nodos Coloreados por Grado\")\n\n\n\n\n\n\n\n\n\nHacer los enlaces con curvas\n\n\nset.seed(42) # Para reproducibilidad\nplot(g_vis_examples, vertex.label = V(g_vis_examples)$name, vertex.size = 10, edge.curved = 0.2, main = \"Curved edges\")\n\n\n\n\n\n\n\n\n\nColocación Aleatoria\n\n\nset.seed(42) # Para reproducibilidad\nplot(g_vis_examples, layout = layout_randomly, vertex.label = V(g_vis_examples)$name, main = \"Colocación Aleatoria\")\n\n\n\n\n\n\n\n\nEstas diferentes visualizaciones muestran cómo se puede alterar la apariencia de una red más compleja utilizando el paquete igraph. Además, la matriz de adyacencia proporciona una representación clara de las conexiones entre los nodos, lo que puede ser útil para análisis posteriores. Cada modificación visual puede ayudar a resaltar diferentes características de la red y facilitar la comprensión de su estructura y propiedades."
  },
  {
    "objectID": "analisis_topo_1.html#qué-es-un-grafo",
    "href": "analisis_topo_1.html#qué-es-un-grafo",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "",
    "text": "Un grafo es una estructura matemática que se compone de un conjunto de nodos (o vértices) y un conjunto de aristas (o enlaces) que conectan pares de nodos. Los grafos son útiles en diversas disciplinas, incluida la biología, para modelar relaciones y interacciones entre diferentes entidades, como proteínas, genes y metabolitos.\n\n\n\nNodos (Vértices): Los elementos individuales de un grafo. Un grafo se puede definir como \\(G = (V, E)\\), donde \\(V\\) es el conjunto de nodos y \\(E\\) es el conjunto de aristas. En biología, un nodo puede representar una proteína, un gen o cualquier otra entidad de interés.\nAristas (Enlaces): Las conexiones entre los nodos. En un grafo que representa interacciones proteína-proteína (como STRINGdb por ejemplo), una arista podría indicar que dos proteínas interactúan. Matemáticamente, cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\), donde \\(u, v \\in V\\).\nGrado (Degree): El grado de un nodo \\(v\\) es el número de aristas que inciden en él. Por ejemplo en el siguiente red, los nodos 1, 2 y 4 tienen un grado de dos. El nodo 3 tiene un grado de tres. Esto es una red no-dirigida, o un grafo en el que las aristas no tienen dirección, lo que implica una relación simétrica entre nodos.\n\nPara el nodo \\(i\\)-ésimo en una red, denotaremos su grado como \\(k_i\\). Por lo tanto, para el siguiente red, \\(k_1 = k_2 = 2\\), \\(k_4 = 1\\) y \\(k_3 = 3\\).\n\npar(mar = c(1, 1, 1, 1))\ng1 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = FALSE)\nplot(g1)\n\n\n\n\n\n\n\n\nComo se mencionó anteriormente, el número total de enlaces se denota como \\(E\\). En una red no dirigida, es fácil entender que \\(E\\) debería ser la mitad de la suma de todos los grados de los nodos. Esto es porque cada enlace pertenece a dos nodos y, por lo tanto, cada enlace se cuenta dos veces. Así tenemos:\n\\[\nE = \\frac{1}{2} \\sum_{i=1}^{N} k_i\n\\]\nEn la red anterior, \\(E = 4\\).\nEl grado medio, denotado como \\(\\langle k \\rangle\\), es simplemente la media de todos los grados de los nodos en una red. Para la red anterior (Figura 2.2), tenemos:\n\\[\n\\langle k \\rangle = \\frac{1}{4} \\cdot (k_1 + k_2 + k_3 + k_4) = \\frac{1}{4} \\cdot (2 + 2 + 3 + 1) = 2\n\\]\nEsto significa que, en promedio, cada nodo en la red tiene 2.25 enlaces.\nDe acuerdo con su definición, sabemos que:\n\\[\n\\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i\n\\]\nCombinando esto con la Ecuación (2.1), obtenemos:\n\\[\n\\langle k \\rangle = \\frac{2E}{N}\n\\]\nUn nodo con un alto grado tiene muchas conexiones, lo que puede indicar que es una proteína central o un hub en una red biológica.\n\nGrafo dirigido (Directed Graph): Un grafo en el que las aristas tienen una dirección, es decir, indican una relación asimétrica entre dos nodos. En este caso, cada arista se representa como un par ordenado \\(e = (u, v)\\), donde \\(u\\) apunta a \\(v\\). Por ejemplo:\n\n\ng2 &lt;- make_graph(edges = c(1, 2, 1, 3, 2, 3, 3, 4), n = 4, directed = TRUE)\npar(mar = c(1, 1, 1, 1))\nplot(g2)\n\n\n\n\n\n\n\n\nCada enlace en la red anterior es dirigido. Si calculamos el grado medio de la red según la ecuación para redes no dirigdas, perderemos información.\nPor lo tanto, distinguimos entre el grado de entrada, denotado como \\(k_{\\text{in}_i}\\), y el grado de salida, denotado como \\(k_{\\text{out}_i}\\). \\(k_{\\text{in}_i}\\) representa el número de enlaces de otros nodos que apuntan al nodo \\(i\\), y \\(k_{\\text{out}_i}\\) representa el número de enlaces que parten del nodo \\(i\\) y apuntan a otros nodos.\nPara un nodo \\(i\\) en una red dirigida, su grado es la suma del grado de entrada y el grado de salida. Por lo tanto,\n\\[\nk_i = k_{\\text{in}_i} + k_{\\text{out}_i}\n\\]\nY \\(E\\), el número total de enlaces en una red dirigida, es:\n\\[\nE = \\sum_{i=1}^{N} k_{\\text{in}_i} = \\sum_{i=1}^{N} k_{\\text{out}_i}\n\\]\nPara un enlace dirigido entre el nodo \\(i\\) y el nodo \\(j\\), es decir, \\((i, j)\\), este constituye un grado de entrada para un nodo, pero un grado de salida para el otro. Por ejemplo, en la red dirigida, el enlace \\((1,2)\\) cuenta como un grado de entrada para el nodo 2, pero como un grado de salida para el nodo 1.\n¿Cuál es el grado medio en una red dirigida?\n\\[\n\\langle k_{\\text{in}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{in}_i} = \\langle k_{\\text{out}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_{\\text{out}_i} = \\frac{E}{N}\n\\]\n\nCaminos y Ciclos:\n\nCamino (Path): Una secuencia de nodos \\(v_1, v_2, \\ldots, v_k\\) donde cada par de nodos adyacentes está conectado por una arista. Matemáticamente, esto se expresa como: \\[\nP = (v_1, v_2, \\ldots, v_k) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k\n\\]\nCiclo (Cycle): Un camino que comienza y termina en el mismo nodo sin repetir ninguna arista. Se define como: \\[\nC = (v_1, v_2, \\ldots, v_k, v_1) \\text{ tal que } (v_i, v_{i+1}) \\in E \\text{ para } 1 \\leq i &lt; k \\text{ y } (v_k, v_1) \\in E\n\\]\n\nSubgrafo (Subgraph): Un grafo que está compuesto por un subconjunto de los nodos y aristas de un grafo original \\(G\\). Se puede denotar como \\(H = (V_H, E_H)\\), donde \\(V_H \\subseteq V\\) y \\(E_H \\subseteq E\\).\nConectividad (Connectivity):\n\nEn teoría de grafos, la conectividad es una medida de la robustez de una red y describe la densidad con la que los nodos están conectados entre sí. La conectividad puede analizarse tanto a nivel de nodos como de aristas:\n\nConectividad de Nodos: refiere al número mínimo de nodos que deben eliminarse para que el grafo se vuelva disconexo o para separar un componente del resto de la red. Un grafo con alta conectividad de nodos es más robusto, ya que no se desconecta fácilmente ante la eliminación de unos pocos nodos.\nConectividad de Aristas: refiere al número mínimo de aristas que deben eliminarse para que el grafo se vuelva disconexo. La eliminación de una sola arista en un grafo con baja conectividad puede hacer que la red se divida en componentes.\n\n\n\n\nEn este ejemplo, mostramos un grafo completo de 5 nodos. En un grafo completo, cada nodo está conectado a todos los demás, lo que genera múltiples caminos alternativos entre los nodos y, por tanto, una alta conectividad.\n\n# Grafo completo de 5 nodos (alta conectividad)\ng_high &lt;- make_full_graph(5)\nplot(g_high, main = \"Grafo con Alta Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_high):\", vertex_connectivity(g_high), \"\\n\")\n\nConectividad de nodos (g_high): 4 \n\ncat(\"Conectividad de aristas (g_high):\", edge_connectivity(g_high), \"\\n\")\n\nConectividad de aristas (g_high): 4 \n\ncat(\"¿Es conexo (g_high)?\", is_connected(g_high), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_high)? TRUE \n\n\nFIGURA 1: Grafo con alta conectividad.\nEn este caso, la función vertex_connectivity(g_high) y edge_connectivity(g_high) muestran que el grafo tiene alta conectividad de nodos y de aristas, ya que ambos valores serán altos en un grafo completo. La función is_connected(g_high) devolverá TRUE, indicando que el grafo es conexo.\n\n\n\nEn el segundo ejemplo, tenemos un grafo lineal o en forma de cadena. Este grafo tiene baja conectividad de nodos y aristas, ya que la eliminación de un nodo o arista específico puede desconectar la red.\n\n# Grafo lineal de 5 nodos (baja conectividad)\ng_low &lt;- make_graph(edges = c(1, 2, 2, 3, 3, 4, 4, 5), n = 5, directed = FALSE)\nplot(g_low, main = \"Grafo con Baja Conectividad\")\n\n\n\n\n\n\n\n# Verificamos la conectividad de nodos y aristas\ncat(\"Conectividad de nodos (g_low):\", vertex_connectivity(g_low), \"\\n\")\n\nConectividad de nodos (g_low): 1 \n\ncat(\"Conectividad de aristas (g_low):\", edge_connectivity(g_low), \"\\n\")\n\nConectividad de aristas (g_low): 1 \n\ncat(\"¿Es conexo (g_low)?\", is_connected(g_low), \"\\n\")\n\n&lt;U+00BF&gt;Es conexo (g_low)? TRUE \n\n\nFIGURA 2: Grafo con baja conectividad.\nEn este grafo lineal, la conectividad de nodos y de aristas es baja. La eliminación del nodo central (nodo 3) o cualquiera de sus aristas adyacentes desconectaría el grafo, dividiéndolo en dos componentes separados. En este caso, la función is_connected(g_low) devolverá TRUE, indicando que el grafo es conexo en su estado actual, pero su conectividad es débil.\nEn redes grandes y complejas, la conectividad es crucial para determinar la robustez de la red frente a la eliminación de nodos o aristas. Un grafo con alta conectividad es menos susceptible a la desconexión, mientras que uno con baja conectividad puede dividirse fácilmente ante la pérdida de algunos elementos."
  },
  {
    "objectID": "analisis_topo_1.html#ejemplo-de-red---mas-igraph",
    "href": "analisis_topo_1.html#ejemplo-de-red---mas-igraph",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "",
    "text": "Antes de generar redes aleatorias, exploraremos un ejemplo de una red que consta de cinco nodos y seis aristas. Este ejemplo nos ayudará a entender cómo se pueden visualizar diferentes aspectos de una red.\n\n\n\n# Crear un grafo con 5 nodos y 6 aristas\ng_vis_examples &lt;- make_graph(c(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\", \"C\", \"D\", \"C\", \"E\", \"D\", \"E\"), directed = FALSE)\n\n# Visualizar la red básica\nplot(g_vis_examples, vertex.label = V(g_vis_examples)$name, main = \"Red para Visualizar\")\n\n\n\n\n\n\n\n\n\n\n\nEn una red cada arista se puede representar como un par ordenado de nodos: \\(e = (u, v)\\). Una table de pares de nodos se puede llamar como un “from-to list”.\nLa matriz de adyacencia es otra representación que indica la conexión entre los nodos. Se define como una matriz cuadrada \\(A\\) donde \\(A[i, j] = 1\\) si hay una arista entre el nodo \\(i\\) y el nodo \\(j\\), y \\(A[i, j] = 0\\) en caso contrario.\n\n# Convertir el grafo en data.frame con formato \"from-to\"\n\n# Convertir el grafo en una matriz de adyacencia\nadjacency_matrix &lt;- as.matrix(as_adjacency_matrix(g_vis_examples))\n\n# Mostrar la matriz de adyacencia\nadjacency_matrix\n\n  A B C D E\nA 0 1 1 0 0\nB 1 0 0 1 0\nC 1 0 0 1 1\nD 0 1 1 0 1\nE 0 0 1 1 0\n\n\nMatrices de adjacencia estan en general mas facil trabajar con ellos: mas facil hacer operaciones matematicas (aplicación de álgebra matricial) Tambien ofrecen acceso rápido a conexiones - no hay que traversar una lista.\nPero, sobre todo en redes grandes, pueden ser ineficiente - tienen \\(N x N\\) dimensiones, y en redes biologicas, la gran mayoria pueden ser ceros\nPor ejemplo, Si una red tiene 1,000 nodos, una matriz de adyacencia requeriría 1,000^2 =1,000,000 entradas, independientemente de cuántas conexiones realmente existan entre los nodos. Aunque solo una fracción de estas entradas podría representar enlaces reales, todas las celdas deben almacenarse en la memoria.\nTambien existe representaciones sparse, por ejemplo en R:\n\n# Instala el paquete si aún no está instalado\nif (!requireNamespace(\"Matrix\", quietly = TRUE)) {\n  install.packages(\"Matrix\")\n}\n# Cargar el paquete Matrix\nlibrary(Matrix)\n\n# Crear una matriz dispersa\n# Definimos una matriz de 5x5 con solo algunos enlaces\nadj_matrix &lt;- Matrix(c(0, 1, 0, 0, 1,\n                       1, 0, 1, 0, 0,\n                       0, 1, 0, 1, 0,\n                       0, 0, 1, 0, 1,\n                       1, 0, 0, 1, 0), \n                     nrow = 5, ncol = 5, sparse = TRUE)\n\n# Mostrar la matriz dispersa\nprint(adj_matrix)\n\n5 x 5 sparse Matrix of class \"dsCMatrix\"\n              \n[1,] . 1 . . 1\n[2,] 1 . 1 . .\n[3,] . 1 . 1 .\n[4,] . . 1 . 1\n[5,] 1 . . 1 .\n\n# igraph ahora usa matrices sparse por definicion:\nprint(as_adjacency_matrix(g_vis_examples))\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n  A B C D E\nA . 1 1 . .\nB 1 . . 1 .\nC 1 . . 1 1\nD . 1 1 . 1\nE . . 1 1 .\n\n\nPorque usa menos memoria el sparse matrix?\nUna matriz dispersa (o sparse matrix) utiliza menos memoria porque solo almacena los elementos no cero y sus posiciones, mientras que una matriz densa almacena todos los elementos, incluidos los ceros.\n\n# Cargar el paquete Matrix\nlibrary(Matrix)\n\n# Crear una matriz de adyacencia 20000x20000 en base R (estimada no. genes en genoma humano segun un articulo famoso)\n# Han estimado 650000 interacciones entre estos genes\nset.seed(42)\ndense_matrix &lt;- matrix(0, nrow = 20000, ncol = 20000)\npositions &lt;- sample(1:(1000*1000), size = 650000)  # Solo 650000 conexiones\ndense_matrix[positions] &lt;- 1\n\n# Mostrar el tamaño en memoria de la matriz densa\ndense_matrix_size &lt;- object.size(dense_matrix)\nprint(paste(\"Tamaño de la matriz densa:\", format(dense_matrix_size, units = \"auto\")))\n\n[1] \"Tama&lt;U+00F1&gt;o de la matriz densa: 3 Gb\"\n\n# Convertir la matriz densa a una matriz dispersa\nsparse_matrix &lt;- as(dense_matrix, \"sparseMatrix\")\n\n# Mostrar el tamaño en memoria de la matriz dispersa\nsparse_matrix_size &lt;- object.size(sparse_matrix)\nprint(paste(\"Tamaño de la matriz dispersa:\", format(sparse_matrix_size, units = \"auto\")))\n\n[1] \"Tama&lt;U+00F1&gt;o de la matriz dispersa: 7.5 Mb\"\n\n\n\n\n\nA continuación, se presentan diez maneras diferentes de visualizar la misma red, modificando colores, tipos de aristas y otros parámetros:\n\nColores de Nodos Diferentes\n\n\nplot(g_vis_examples, vertex.color = c(\"red\", \"green\", \"blue\", \"orange\", \"purple\"), vertex.label = V(g_vis_examples)$name, main = \"Colores de Nodos Diferentes\")\n\n\n\n\n\n\n\n\n\nTamaño de Nodos Basado en Grado\n\n\nvertex_sizes &lt;- degree(g_vis_examples) * 5\nplot(g_vis_examples, vertex.size = vertex_sizes, vertex.label = V(g_vis_examples)$name, main = \"Tamaño de Nodos Basado en Grado\")\n\n\n\n\n\n\n\n\n\nTipo de Arista Diferente (dotted)\n\n\nplot(g_vis_examples, edge.lty = \"dotted\", vertex.label = V(g_vis_examples)$name, main = \"Aristas Dotted\")\n\n\n\n\n\n\n\n\n\nColores de Aristas Diferentes\n\n\nplot(g_vis_examples, edge.color = \"purple\", vertex.label = V(g_vis_examples)$name, main = \"Colores de Aristas Diferentes\")\n\n\n\n\n\n\n\n\n\nEstructura Circular\n\n\nplot(g_vis_examples, layout = layout_in_circle, vertex.label = V(g_vis_examples)$name, main = \"Estructura Circular\")\n\n\n\n\n\n\n\n# No se ver muy bien - vamos a ver mejro\n# Crear un grafo aleatorio con 20 nodos y un número específico de aristas\nset.seed(1)\ng_20 &lt;- sample_gnp(20, p = 0.2)  # Generar una red aleatoria\n\n# Visualizar la red en un layout circular\nplot(g_20, layout = layout_in_circle, vertex.label = V(g_20)$name, \n     vertex.color = \"lightblue\", edge.color = \"gray\", main = \"Red Circular con 20 Nodos\")\n\n\n\n\n\n\n\n\n\nEstructura de Grid\n\n\nplot(g_vis_examples, layout = layout_on_grid, vertex.label = V(g_vis_examples)$name, main = \"Estructura de Grid\")\n\n\n\n\n\n\n\nplot(g_20, layout = layout_on_grid, vertex.label = V(g_20)$name, \n     vertex.color = \"lightgreen\", edge.color = \"gray\", main = \"Red Grid con 20 Nodos\")\n\n\n\n\n\n\n\n\n\nColores de Nodos según Grado\n\n\n# Calcular el grado para cada nodo\ndegree_values &lt;- degree(g_20)\n# Normalizar los valores del grado para que estén entre 0 y 1\ndegree_normalized &lt;- (degree_values - min(degree_values)) / (max(degree_values) - min(degree_values))\n# Asignar colores según el grado\n# Usaremos un gradiente de colores de azul (bajo grado) a rojo (alto grado)\nnode_colors &lt;- colorRampPalette(c(\"blue\", \"red\"))(length(degree_normalized))[rank(degree_normalized)]\n# Graficar el grafo\nplot(g_20, vertex.color = node_colors, main = \"Grafo con Nodos Coloreados por Grado\")\n\n\n\n\n\n\n\n\n\nHacer los enlaces con curvas\n\n\nset.seed(42) # Para reproducibilidad\nplot(g_vis_examples, vertex.label = V(g_vis_examples)$name, vertex.size = 10, edge.curved = 0.2, main = \"Curved edges\")\n\n\n\n\n\n\n\n\n\nColocación Aleatoria\n\n\nset.seed(42) # Para reproducibilidad\nplot(g_vis_examples, layout = layout_randomly, vertex.label = V(g_vis_examples)$name, main = \"Colocación Aleatoria\")\n\n\n\n\n\n\n\n\nEstas diferentes visualizaciones muestran cómo se puede alterar la apariencia de una red más compleja utilizando el paquete igraph. Además, la matriz de adyacencia proporciona una representación clara de las conexiones entre los nodos, lo que puede ser útil para análisis posteriores. Cada modificación visual puede ayudar a resaltar diferentes características de la red y facilitar la comprensión de su estructura y propiedades."
  },
  {
    "objectID": "analisis_topo_1.html#personalización-de-redes-en-igraph",
    "href": "analisis_topo_1.html#personalización-de-redes-en-igraph",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Personalización de redes en igraph",
    "text": "Personalización de redes en igraph\nAun mas ejemplos de personalización de redes, combinando factores, en un solo bloque de código con comentarios explicativos.\n\n# Personalización de redes en igraph\n\n# Grafo de ejemplo\ng &lt;- sample_gnp(20, p = 0.1)\n\n# Personalizar atributos de nodos\nV(g)$color &lt;- ifelse(degree(g) &gt; 2, \"red\", \"blue\")  # Color por grado\nV(g)$size &lt;- degree(g) * 3  # Tamaño de nodo proporcional al grado\nV(g)$label &lt;- paste0(\"Node:\", V(g))  # Etiquetas de nodos\n\n# Personalizar atributos de aristas\nE(g)$color &lt;- \"gray\"  # Color de aristas\nE(g)$width &lt;- 2  # Ancho de aristas\n\n# Graficar el grafo personalizado\nplot(g, vertex.label=V(g)$label, edge.arrow.size=0.5, \n     main=\"Grafo Personalizado: Atributos de Nodos y Aristas\")"
  },
  {
    "objectID": "analisis_topo_1.html#topología-de-redes",
    "href": "analisis_topo_1.html#topología-de-redes",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Topología de redes",
    "text": "Topología de redes\n\nCoeficiente de Clustering local\nEl coeficiente de clustering es una medida que indica la tendencia de los nodos en una red a agruparse en clústeres. Un alto coeficiente de clustering para un nodo (local) sugiere que un nodo es parte de una comunidad densa. En biología, esto puede ser relevante para estudiar interacciones entre proteínas, donde un alto coeficiente de clustering entre varios genes puede indicar una comunidad de proteínas que interactúan fuertemente entre sí.\nSe puede definir como:\n\\[\nC(v) = \\frac{2 \\times \\text{number of triangles through } v}{\\text{degree}(v) \\times (\\text{degree}(v) - 1)}\n\\]\nO quizas mas intuitivemente, puede definirse en términos de la proporción de triángulos presentes en el grafo en comparación con el número total de triángulos posibles que pueden formarse a partir de los vecinos de un nodo. Esta definición se centra en la noción de “triángulos” y se expresa como:\n\\[\nC(v) = \\frac{\\text{Número de triángulos en los vecinos de } v}{\\text{Número total de triángulos posibles entre los vecinos de } v}\n\\]\n\n\nInterpretación\n\nUn coeficiente de clustering cercano a 1 indica que los vecinos de un nodo están muy interconectados, formando un clúster denso.\nUn coeficiente de clustering cercano a 0 indica que los vecinos de un nodo están poco interconectados.\n\nEsta definición es útil para visualizar cómo las interacciones locales entre los nodos contribuyen a la estructura global de la red, y es especialmente relevante en el contexto de redes sociales y biológicas, donde se pueden observar grupos de interacciones fuertes entre ciertos nodos.\n\n\nCódigo para Calcular y Visualizar el Coeficiente de Clustering local\n\n# Crear una red aleatoria\nset.seed(42)\ng_clustering &lt;- sample_gnp(n = 15, p = 0.15, directed = FALSE)\n\n# Calcular el coeficiente de clustering por nodo\nvertex_clustering &lt;- transitivity(g_clustering, type = \"local\")\nV(g_clustering)$color &lt;- ifelse(vertex_clustering &gt; 0, \"red\", \"lightblue\")\n\n# Visualizar la red con coeficiente de clustering - si los vecinos estan conectadas, se visualiza en rojo!\nset.seed(321)\nplot(g_clustering, vertex.size = 5, vertex.label = NA, main = \"Coeficiente de Clustering Local\")\n\n\n\n\n\n\n\n\nEste código calcula e imprime los coeficientes local de un pequeño grafo aleatorio y visualiza los nodos según el coeficiente de clustering &gt; 1, donde los nodos rojos tienen un coeficiente &gt; 1 (por lo menos un par de interactores interaccionan entre ellos - en otras palabras - FORMAN UN TRIANGULO) y los nodos azules tienen un coeficiente bajo.\n\n\nCoeficiente de Clustering Global\n\nDefinición: El coeficiente de clustering global es una medida global que describe la tendencia general de la red de formar triángulos (conexiones entre tres nodos). Proporciona una visión general de la densidad de la red en términos de interacciones entre vecinos de los nodos.\nCálculo:\n\nUna forma común de calcular el coeficiente de clustering global es tomando el promedio de los coeficientes de clustering locales de todos los nodos en la red:\n\n\n\\[\n  C_{\\text{global}} = \\frac{1}{N} \\sum_{v \\in G} C(v)\n\\]\nDonde (N) es el número de nodos en el grafo y (C(v)) es el coeficiente de clustering local del nodo (v).\n\nAlternativamente, se puede definir como la relación entre el número de triángulos (tripletas de nodos completamente conectados) y el número de tripletas conectadas (un triplete es cualquier conjunto de 3 nodos conectados por 2 aristas):\n\n\\[ C\\_{\\text{global}} = \\frac{3 \\times \\text{Número de triángulos}}{\\text{Número de tripletas conectadas}} \\]\n\nInterpretación: Un coeficiente de clustering global cercano a 1 significa que la red está altamente agrupada (muchos nodos tienen coeficientes de clustering altos), mientras que un valor cercano a 0 sugiere que la red es más aleatoria, con menos agrupamientos locales.\n\n\nlibrary(igraph)\nset.seed(333)\n# High Global Clustering Coefficient - Small-World Network\ng_high_clustering &lt;- sample_smallworld(dim = 1, size = 30, nei = 3, p = 0.05)\nglobal_clustering_high &lt;- transitivity(g_high_clustering, type = \"global\")\ncat(\"Global Clustering Coefficient (High):\", global_clustering_high, \"\\n\")\n\nGlobal Clustering Coefficient (High): 0.4379085 \n\n# Low Global Clustering Coefficient - Random Network\ng_low_clustering &lt;- sample_gnp(30, p = 0.05, directed = FALSE)\nglobal_clustering_low &lt;- transitivity(g_low_clustering, type = \"global\")\ncat(\"Global Clustering Coefficient (Low):\", global_clustering_low, \"\\n\")\n\nGlobal Clustering Coefficient (Low): 0.1 \n\n# Plotting both networks\npar(mfrow = c(1, 2))\nplot(g_high_clustering, main = paste(\"High Clustering (Coeff:\", round(global_clustering_high, 2), \")\"),\n     vertex.size = 8, vertex.label = NA, edge.color = \"dodgerblue\")\nplot(g_low_clustering, main = paste(\"Low Clustering (Coeff:\", round(global_clustering_low, 2), \")\"),\n     vertex.size = 8, vertex.label = NA, edge.color = \"tomato\")\n\n\n\n\n\n\n\npar(mfrow = c(1, 1))\n\n\nEjemplo en biología\nEn las redes de interacción de proteínas, los genes que codifican proteínas que interactúan entre sí tienden a formar grupos o módulos con un alto coeficiente de clustering. Esto es relevante para identificar vías metabólicas o complejos proteicos.\n\n\n\nCentralidad\nLa centralidad se refiere a la importancia de un nodo dentro de una red. Existen varios tipos de centralidad, entre ellos:\n\nCentralidad de grado (degree centrality): Número de conexiones directas de un nodo.\n\n\\[\nC_g(v) = \\text{degree}(v)\n\\]\n\n\nCentralidad de Intermediación (Betweenness Centrality):\nLa centralidad de intermediación es una medida clave en la teoría de redes que indica cuántas veces un nodo actúa como “puente” o intermediario entre otros nodos. Es un concepto crucial para entender la estructura de la red en términos de control o flujo de información, recursos, o influencia a través de los nodos de la red.\n\nDefinición Matemática:\nLa centralidad de intermediación de un nodo \\(v\\) en una red se define como:\n\\[\nC_b(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n\\]\n\n\\(\\sigma_{st}\\) es el número total de caminos más cortos entre los nodos \\(s\\) y \\(t\\).\n\\(\\sigma_{st}(v\\) es el número de esos caminos más cortos que pasan por el nodo \\(v\\).\n\nLa centralidad de intermediación calcula, para un nodo dado, la fracción de caminos más cortos entre todos los pares de nodos \\(s\\) y \\(t\\) en la red que pasan a través de él. Cuanto mayor sea este valor, más “importante” es ese nodo en la red en términos de conectar diferentes partes de la misma.\n\n\n\nExplicación Conceptual:\nLa centralidad de intermediación mide el papel de un nodo como intermediario entre otros nodos de la red. Un nodo con una centralidad de intermediación alta es uno que está en el medio de muchos caminos más cortos entre otros nodos. Esencialmente, estos nodos tienen un poder significativo en términos de control del flujo de información o recursos a través de la red.\n\n\nRelevancia en Biología:\nEn el contexto biológico, la centralidad de intermediación tiene aplicaciones en varias áreas, como las redes de interacción proteína-proteína (PPI), las redes metabólicas, y las redes de regulación génica. Identificar los nodos con alta centralidad de intermediación puede ayudar a entender los puntos de control clave o los “puentes” que facilitan la comunicación entre diferentes partes de una red biológica.\n\nEjemplos en Biología:\n\nRedes de Interacción Proteína-Proteína (PPI):\n\nEn una red de interacción proteína-proteína, las proteínas con alta centralidad de intermediación pueden ser aquellas que conectan diferentes “modulos” funcionales dentro de la red. Estas proteínas actúan como puntos de control para la transmisión de señales entre distintas funciones celulares. Si una proteína con alta centralidad de intermediación se ve afectada por mutaciones, podría tener un impacto significativo en varias vías biológicas o incluso en la enfermedad.\nEjemplo: En una red PPI de una célula humana, una proteína como TP53 (p53), que tiene un papel central en la regulación del ciclo celular y la respuesta al daño del ADN, podría tener una alta centralidad de intermediación. Si p53 se ve alterada o desregulada, puede afectar numerosas vías celulares relacionadas con el cáncer, como la apoptosis, la reparación del ADN y la regulación del ciclo celular.\n\nRedes Metabólicas:\n\nEn una red metabólica, un metabolito o enzima con alta centralidad de intermediación puede ser clave para conectar diversas rutas metabólicas. Estos metabolitos actúan como puentes entre diferentes procesos metabólicos, lo que permite una integración eficiente de los recursos celulares.\nEjemplo: El ATP (adenosín trifosfato), que es esencial para casi todas las reacciones bioquímicas celulares, puede actuar como un nodo con alta centralidad de intermediación en una red metabólica. La alteración de la producción o el uso de ATP afecta una multitud de rutas metabólicas y es crucial para la función celular.\n\nRedes de Regulación Génica:\n\nEn las redes de regulación génica, los factores de transcripción que conectan diferentes conjuntos de genes pueden tener una alta centralidad de intermediación. Estos factores de transcripción no solo regulan la expresión de un conjunto de genes, sino que también actúan como intermediarios para la integración de diversas señales celulares.\nEjemplo: El factor de transcripción NF-kB es un nodo con alta centralidad de intermediación en las redes de regulación génica. Controla la expresión de genes implicados en la respuesta inmune y en procesos inflamatorios. Si NF-kB está desregulado, puede contribuir a enfermedades como el cáncer, enfermedades autoinmunes y trastornos inflamatorios.\n\n\n\n\nCódigo R para Calcular y Visualizar la Centralidad de Intermediación:\n\nset.seed(123)\ng &lt;- sample_gnp(10, p = 0.5)\n\n# Calculate betweenness centrality for all nodes\nbetweenness_centrality &lt;- betweenness(g)\n\n# Normalize the betweenness values for better visualization (optional)\nbetweenness_normalized &lt;- (betweenness_centrality - min(betweenness_centrality)) / \n    (max(betweenness_centrality) - min(betweenness_centrality))\n\n# Visualize the graph with nodes colored by betweenness centrality\nplot(g, \n     vertex.size = 20, \n     vertex.color = heat.colors(100, rev=TRUE)[round(betweenness_normalized * 99) + 1], # Color nodes based on centrality # Optionally remove labels\n     main = \"Graph colored by Betweenness Centrality\")\n\n\n\n\n\n\n\n\n\n\n\nRedes de Escala Libre (Scale-Free Networks)\nLas redes de escala libre son un tipo particular de red que se caracteriza por una distribución de grado que sigue una ley de potencia. En este tipo de redes, existen unos pocos nodos con un número muy alto de conexiones (hubs), mientras que la mayoría de los nodos tienen pocas conexiones. Esta estructura es fundamental para entender cómo funcionan muchas redes complejas en la naturaleza y en sistemas biológicos, como las redes de interacción proteína-proteína o las redes neuronales.\n\nPropiedades de las Redes de Escala Libre:\n\nDistribución de Grado:\n\nLa distribución de grado en las redes de escala libre sigue una ley de potencia, lo que significa que el número de nodos con un cierto grado ( k ) (número de conexiones) disminuye rápidamente a medida que ( k ) aumenta. Matemáticamente, esto se expresa como:\n\\[\nP(k) \\sim k^{-\\gamma}\n\\]\nDonde:\n\n\\(P(k)\\) es la probabilidad de que un nodo tenga un grado \\(k\\).\n\\(k\\) es el grado de un nodo (el número de conexiones que tiene).\n\\(\\gamma\\) es el exponente de la ley de potencia, que típicamente se encuentra entre 2 y 3 en la mayoría de redes de escala libre.\n\nEste tipo de distribución es característica de redes autoorganizadas o generadas por crecimiento preferencial, donde nuevos nodos tienden a conectarse preferentemente a los nodos que ya están muy conectados. Esta propiedad genera hubs o nodos centrales, que son cruciales para la conectividad de la red.\n\n\nEjemplo en Biología: Redes de Interacción Proteína-Proteína (PPI)\nEn redes de interacción proteína-proteína (PPI), las proteínas más fundamentales para las funciones celulares tienden a tener un alto grado de conectividad, es decir, son hubs. Estas proteínas suelen ser las que orquestan múltiples procesos celulares, como la transcripción genética, la reparación del ADN y la señalización celular.\n\nEjemplo: BRCA1 (Breast Cancer 1) es una proteína clave en la reparación del ADN y en la regulación del ciclo celular. En las redes de interacción proteína-proteína (PPI), BRCA1 actúa como un hub, conectando muchas otras proteínas involucradas en procesos esenciales como la reparación del ADN, el control del ciclo celular, y la respuesta al daño genético. Debido a su papel central en estas vías, BRCA1 es crucial para la estabilidad genética de la célula.\n\nLa alteración o mutación de BRCA1 está asociada con un mayor riesgo de desarrollar cáncer de mama y ovario. Las mutaciones en BRCA1 afectan su capacidad para interactuar con otras proteínas de la red, lo que compromete la reparación del ADN y aumenta la probabilidad de que ocurran mutaciones genéticas que conduzcan al cáncer. En este caso, BRCA1 no solo es un hub en una red de interacciones, sino que también es un punto crítico para mantener la integridad genética celular.\n\n\n2. Centralidad y Robustez:\nUna de las características interesantes de las redes de escala libre es que, debido a la existencia de hubs, estas redes son robustas frente a fallos aleatorios. Esto significa que si se eliminan nodos de la red de manera aleatoria, la conectividad global de la red no se verá gravemente afectada, ya que los nodos de baja conectividad no son esenciales para la red. Sin embargo, si se atacan los hubs (nodos altamente conectados), la red puede volverse muy vulnerable, ya que la eliminación de estos nodos puede desconectar grandes partes de la red.\n\n\nEjemplo en Biología: Redes Neuronales\nEn las redes neuronales, los hubs son neuronas clave que conectan diferentes regiones del cerebro. La red de conectividad cerebral sigue una estructura de escala libre, donde ciertas neuronas tienen muchas conexiones con otras, permitiendo una comunicación eficiente entre regiones cerebrales distantes. Estas neuronas de alto grado son críticas para el procesamiento de información en el cerebro.\n\nEjemplo: El córtex prefrontal tiene neuronas de alta centralidad en las redes neuronales, que facilitan la integración de información de diferentes áreas cerebrales. Si se dañan estas neuronas (por ejemplo, en enfermedades neurodegenerativas), pueden ocurrir disfunciones cognitivas importantes.\n\n\n\n3. Vulnerabilidad a Ataques Dirigidos:\nDebido a su estructura jerárquica, las redes de escala libre son vulnerables a ataques dirigidos a los hubs. Al eliminar estos nodos clave, la conectividad de la red puede colapsar rápidamente, lo que afecta su funcionamiento global.\n\nEjemplo en biología: En las redes de interacción proteína-proteína, eliminar las proteínas clave (hubs) podría interrumpir varias vías biológicas simultáneamente, lo que llevaría a enfermedades o disfunciones celulares.\n\n– Otro ejemplo: Se han usado esta propiedad para diseñar antibioticos - para atacar una proteina hub para afectar al maximo posible el funcionamiento de la bacteria\n\n\n\n\nEjemplo de Análisis de Redes de Escala Libre\nEn R, podemos generar y analizar una red de escala libre utilizando el modelo de Barabási-Albert (BA), que es un modelo clásico para generar redes de escala libre. A continuación se muestra un código en R que genera una red de escala libre y visualiza la distribución de grados:\n\n# Cargar la librería igraph\nlibrary(igraph)\n\n# Crear una red de escala libre usando el modelo de Barabási-Albert\ng_sf &lt;- sample_pa(1000)\n\n# Obtener la distribución de grado\ndegree_distribution &lt;- degree(g_sf)\n\n# Visualizar la distribución de grado\nhist(degree_distribution, breaks=50, main=\"Distribución de Grado de una Red de Escala Libre\", \n     xlab=\"Grado\", ylab=\"Frecuencia\")\n\n\n\n\n\n\n\n\n\n\nRelevancia en Biología:\nLas redes de escala libre están presentes en muchos sistemas biológicos:\n\nRedes Metabólicas: En las redes metabólicas, los metabolitos con alto grado pueden ser esenciales para varias rutas metabólicas y actúan como puntos de integración. Si estos metabolitos se alteran, pueden afectar varias funciones biológicas.\nRedes de Regulación Génica: En las redes de regulación génica, ciertos factores de transcripción actúan como hubs que conectan diferentes vías de regulación, lo que les permite controlar una gran cantidad de genes. Las alteraciones en estos hubs pueden tener efectos significativos en el desarrollo y la homeostasis celular.\nRedes de Interacción de Proteínas (PPI): Las proteínas que funcionan como hubs en una red de interacción proteína-proteína tienen un papel crucial en la regulación de procesos biológicos complejos. Alteraciones en estas proteínas clave pueden resultar en enfermedades graves, como el cáncer."
  },
  {
    "objectID": "analisis_topo_1.html#conclusión",
    "href": "analisis_topo_1.html#conclusión",
    "title": "Análisis de grafos y topología de redes (I): topología, clustering, scale-free networks",
    "section": "Conclusión",
    "text": "Conclusión\nEste tutorial proporciona una visión general de los conceptos fundamentales en el análisis de redes utilizando igraph en R. A lo largo de esta práctica, se han presentado ejemplos que ilustran la personalización de redes y la aplicación de estos conceptos en el contexto de la biología."
  }
]