visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(3222)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(123)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(12)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(11)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(11)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
probabilities
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(1)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
# Load igraph library
library(igraph)
# Create a simple graph (you can modify this for your graph)
set.seed(1)
g <- erdos.renyi.game(10, p = 0.3, directed = FALSE)
# Set the starting node for the random walk (e.g., node 1)
start_node <- 1
# Function to perform random walk with restart
random_walk_with_restart <- function(graph, start_node, steps = 1000, walks = 10, restart_prob = 0.1) {
node_count <- vcount(graph)
visited <- rep(0, node_count)  # Vector to keep track of visits to each node
for (walk in 1:walks) {
current_node <- start_node
for (i in 1:steps) {
visited[current_node] <- visited[current_node] + 1  # Mark the node as visited
# Decide whether to restart or continue the random walk
if (runif(1) < restart_prob) {
current_node <- start_node  # Restart from the starting node
} else {
neighbors <- neighbors(graph, current_node)  # Get neighbors of current node
if (length(neighbors) == 0) break  # Stop if no neighbors are left
current_node <- sample(neighbors, 1)  # Choose a random neighbor to move to
}
}
}
# Calculate probabilities
prob <- visited / sum(visited)  # Normalize the visits to get probabilities
return(prob)
}
# Run the random walk with restart simulation
set.seed(321)
probabilities <- random_walk_with_restart(g, start_node, steps = 1000, walks = 10, restart_prob = 0.1)
# Normalize the probabilities to create more distinct color contrasts
probabilities <- (probabilities - min(probabilities)) / (max(probabilities) - min(probabilities))
# Set node colors: use a reversed color palette (red for high probability, blue for low probability)
V(g)$color <- rev(heat.colors(length(probabilities)))[floor(probabilities * length(probabilities)) + 1]
# Highlight the start node with a different color (e.g., green)
V(g)$color[start_node] <- "green"
# Increase the size of the start node for emphasis
V(g)$size <- ifelse(1:vcount(g) == start_node, 30, 20)
# Plot the graph with improved color contrast
plot(g, vertex.label = NA, main = "Random Walk with Restart Diffusion on Graph",
vertex.size = V(g)$size, vertex.color = V(g)$color)
source("~/.active-rstudio-document", echo=TRUE)
install.packages("pathview")
BiocManager::install("pathview")
library(pathview)
exp_genes <- c(
"GAPDH" = 2.5,  # Gen sobreexpresado
"HK2" = -1.3,   # Gen subexpresado
"PFK1" = 1.2,   # Gen sobreexpresado
"ALDOA" = 0.5   # Gen con expresión moderada
)
# ID de la vía KEGG para Glicólisis (hsa00010)
id_via <- "hsa00010"
# Visualizar la vía con los datos de expresión génica
pathview(gene.data = exp_genes, pathway.id = id_via, species = "hsa")
exp_genes <- c(
"hsa:2597" = 2.5,  # GAPDH - Gen sobreexpresado
"hsa:3142" = -1.3, # HK2 - Gen subexpresado
"hsa:5225" = 1.2,  # PFK1 - Gen sobreexpresado
"hsa:2247" = 0.5   # ALDOA - Gen con expresión moderada
)
# ID de la vía KEGG para Glicólisis (hsa00010)
id_via <- "hsa00010"
# Visualizar la vía con los datos de expresión génica
pathview(gene.data = exp_genes, pathway.id = id_via, species = "hsa")
data(gse16873.d)
pv.out <- pathview(gene.data = gse16873.d[, 1], pathway.id = "04110",
+ species = "hsa", out.suffix = "gse16873")
data(gse16873.d)
pv.out <- pathview(gene.data = gse16873.d[, 1], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
gse16873.d[, 1]
pv.out <- pathview(gene.data = gse16873.d[, 1], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
pv.out
plot(pv.out)
library(SPIA)
BiocManager::install("SPIA")
library(pathview)
data(gse16873.d)
pv.out <- pathview(gene.data = gse16873.d[, 1], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
getwd()
dir()
library(igraph)
curl -o string_ints.txt "https://string-db.org/api/tsv/interaction_partners?identifiers=PTGS1%0dALOX5"
target_genes <- c("ALOX5", "PTGS1")
# Get the edge list from the network
edge_list <- as.data.frame(get.edgelist(network))
string_data <- read.csv("string_ints.txt", sep = "\t")
gene_pairs <- string_data[, 3:4]
gene_pairs_matrix <- as.matrix(gene_pairs)
head(gene_pairs_matrix)
library(igraph)
network <- graph_from_edgelist(gene_pairs_matrix)
plot(network)
target_genes <- c("ALOX5", "PTGS1")
# Get the edge list from the network
edge_list <- as.data.frame(get.edgelist(network))
# Initialize an edge color vector
edge_colors <- rep("gray", ecount(network))  # Default color for edges
# Color edges connecting ALOX5 and PTGS1
edge_colors[which((edge_list$V1 == "ALOX5" & edge_list$V2 == "PTGS1") |
(edge_list$V1 == "PTGS1" & edge_list$V2 == "ALOX5"))] <- "red"
# Color edges connecting to only PTGS1 (degree 1 or 2)
for (i in 1:nrow(edge_list)) {
if ("PTGS1" %in% edge_list[i, ] && !"ALOX5" %in% edge_list[i, ]) {
edge_colors[i] <- "blue"
}
}
# Add the colors to the graph and plot
E(network)$color <- edge_colors
# Plot the graph with custom edge colors
plot(network, edge.color = E(network)$color, vertex.color = "gray50")
# Identify the nodes of interest
target_genes <- c("ALOX5", "PTGS1")
# Get the edge list from the network
edge_list <- as.data.frame(get.edgelist(network))
# Initialize an edge color vector
edge_colors <- rep("gray", ecount(network))  # Default color for edges
# Color edges connected to both ALOX5 and PTGS1
for (i in 1:nrow(edge_list)) {
if (all(target_genes %in% edge_list[i, ])) {
edge_colors[i] <- "red"  # Edges connecting both ALOX5 and PTGS1
}
}
# Color edges connected to only one of ALOX5 or PTGS1 (but not both)
for (i in 1:nrow(edge_list)) {
if (any(edge_list[i, ] %in% target_genes) && !all(edge_list[i, ] %in% target_genes)) {
edge_colors[i] <- "blue"  # Edges connecting to one but not both
}
}
# Add the colors to the graph and plot
E(network)$color <- edge_colors
# Plot the graph with custom edge colors
plot(network, edge.color = E(network)$color, vertex.color = "gray50")
edge_list
target_genes
# Calculate the degree of each node
node_degrees <- degree(network, mode = "all")
# Assign colors based on the degree
node_colors <- ifelse(node_degrees == 1, "blue",
ifelse(node_degrees == 2, "red", "gray"))
# Add the colors to the graph
V(network)$color <- node_colors
# Plot the graph with custom node colors
plot(network, vertex.color = V(network)$color, edge.color = "gray50", vertex.label = NA)
undirected_network <- as.undirected(network, mode = "collapse")
undirected_network <- as_undirected(network, mode = "collapse")
undirected_network
# Calculate the degree of each node
node_degrees <- degree(network, mode = "all")
# Assign colors based on the degree
node_colors <- ifelse(node_degrees == 1, "blue",
ifelse(node_degrees == 2, "red", "gray"))
# Add the colors to the graph
V(network)$color <- node_colors
# Plot the graph with custom node colors
plot(undirected_network, vertex.color = V(network)$color, edge.color = "gray50", vertex.label = NA)
network <- graph_from_edgelist(gene_pairs_matrix, directed = FALSE)
setwd("//wsl.localhost/Ubuntu/home/jim/BS")
pac_exp <- read.csv2(file = "norm_pac.csv", row.names=1)
getwd()
setwd("C:/Users/Jim/Dropbox/projects/sevilla_olive_transcriptomics")
pac_exp <- read.csv2(file = "norm_pac.csv", row.names=1)
cont_exp <- read.csv2(file = "norm_cont.csv", row.names=1)
pac_exp[] <- lapply(pac_exp, as.numeric)
cont_exp[] <- lapply(cont_exp, as.numeric)
data.pca.cont <- princomp(cont_exp)
fviz_pca_var(data.pca.cont, col.var = "black")
install.packages("factoextra")
library(factoextra)
pac_exp <- read.csv2(file = "norm_pac.csv", row.names=1)
cont_exp <- read.csv2(file = "norm_cont.csv", row.names=1)
pac_exp[] <- lapply(pac_exp, as.numeric)
cont_exp[] <- lapply(cont_exp, as.numeric)
data.pca.cont <- princomp(cont_exp)
fviz_pca_var(data.pca.cont, col.var = "black")
data.pca.pac <- princomp(pac_exp)
fviz_pca_var(data.pca.pac, col.var = "black")
fviz_pca_var(data.pca.cont, col.var = "red")
fviz_pca_var(data.pca.pac, col.var = "red")
fviz_pca_ind(data.pca.cont, col.var = "black")
fviz_pca_var(data.pca.cont, col.var = "black")
fviz_pca_ind(princomp(t(cont_exp)))
pac_exp
dim(pac_exp)
pac_exp[] <- lapply(pac_exp, as.numeric)
dim(pac_exp)
data.pca.cont <- prcomp(cont_exp)
?fviz_pca_ind
library(factoextra)
?fviz_pca_ind
setwd("C:/Users/Jim/Dropbox/projects/sevilla_olive_transcriptomics")
pac_exp <- read.csv2(file = "norm_pac.csv", row.names=1)
cont_exp <- read.csv2(file = "norm_cont.csv", row.names=1)
pac_exp[] <- lapply(pac_exp, as.numeric)
cont_exp[] <- lapply(cont_exp, as.numeric)
library(FactoMineR)
library(factoextra)
# PCA(cont_exp, scale.unit = TRUE, ncp = 5, graph = TRUE)
res.pca.cont <- PCA(t(cont_exp), graph = FALSE, scale=TRUE)
colind <- ifelse(grepl("T9", colnames(cont_exp)), "Stimulated (T9)", "Unstimulated")
pdf("controls_pca.pdf")
fviz_pca_ind(res.pca.cont,
# geom.ind = "point", # show points only (nbut not "text")
col.ind = colind, # color by groups
palette = c("#0d7328", "darkgrey"),
addEllipses = TRUE, # Concentration ellipses
legend.title = "Groups", title="Healthy Controls"
)
dev.off()
res.pca.pac <- PCA(t(pac_exp), graph = FALSE, scale=TRUE)
colind <- ifelse(grepl("T9", colnames(pac_exp)), "Stimulated (T9)", "Unstimulated")
pdf("patients_pca.pdf")
fviz_pca_ind(res.pca.pac,
# geom.ind = "point", # show points only (nbut not "text")
col.ind = colind, # color by groups
palette = c("#0d7328", "darkgrey"),
addEllipses = TRUE, # Concentration ellipses
legend.title = "Groups", title="Patients"
)
dev.off()
